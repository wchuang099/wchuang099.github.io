<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>逆向初级 on 碎碎念念</title>
    <link>http://localhost:1313/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/</link>
    <description>Recent content in 逆向初级 on 碎碎念念</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="http://localhost:1313/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>01.进制基础</title>
      <link>http://localhost:1313/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/01.%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/01.%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h1 id=&#34;计算机与数字的关系&#34;&gt;计算机与数字的关系&lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%a1%e7%ae%97%e6%9c%ba%e4%b8%8e%e6%95%b0%e5%ad%97%e7%9a%84%e5%85%b3%e7%b3%bb&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;信息的二进制表示&#34;&gt;信息的二进制表示&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%a1%e6%81%af%e7%9a%84%e4%ba%8c%e8%bf%9b%e5%88%b6%e8%a1%a8%e7%a4%ba&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;计算机处理的任何信息，包括&lt;strong&gt;图片、视频、音乐、文字、程序&lt;/strong&gt;，最终都是以 &lt;strong&gt;二进制 0 和 1&lt;/strong&gt; 的形式存储和处理的。&lt;/li&gt;&#xA;&lt;li&gt;二进制是计算机唯一“能理解”的语言。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;为什么计算机使用二进制&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;二进制足够表达所有信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每一位只有 0 和 1，组合起来可以表示任意数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;受硬件制约&#xA;&lt;ul&gt;&#xA;&lt;li&gt;电子电路中开关只有两种状态：通/断、亮/灭，对应 1/0&lt;/li&gt;&#xA;&lt;li&gt;二进制与硬件自然匹配，可靠且稳定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;进制的本质&#34;&gt;进制的本质&lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9b%e5%88%b6%e7%9a%84%e6%9c%ac%e8%b4%a8&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;如果将进制定义成这样，你有何想法?&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;十进制的定义&#xD;&#xA;由十个符号组成&#xD;&#xA;如果改成这样呢? &#xD;&#xA;&#x9;9152476380            逢十进一，10是多少呢？用19表示&#xD;&#xA;-或写成这样呢？&#xD;&#xA;&#x9;@ # ! $ ^ &amp;amp; * ( =     逢十进一，十用#@表示&#xD;&#xA;了解事物的本质，如果将上面的符号用于加密，那会给解密者代理极大的麻烦&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;所以2+3=1成立吗？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;成立的，元素是可以自己定义的&#xD;&#xA;自定义符号：   0   2   3   1   8   7   6   9   5   4&#xD;&#xA;标准数值：     0   1   2   3   4   5   6   7   8   9&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;世界上有多少种进制&lt;/strong&gt;？&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;世界可以有任何进制，但一进制除外&#xD;&#xA;进制要求：满 N 进 1&#xD;&#xA;老师让学生数 5 只羊,&#xD;&#xA;学生画：| | | | | &#xD;&#xA;或者刻“正”字&#xD;&#xA;不进位，只是重复堆符号&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;常用的进制&#34;&gt;常用的进制&lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e7%94%a8%e7%9a%84%e8%bf%9b%e5%88%b6&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在计算机中，常用的数值进制包括二进制、八进制、十进制和十六进制。&lt;/p&gt;</description>
    </item>
    <item>
      <title>02.数据宽度</title>
      <link>http://localhost:1313/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/02.%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/02.%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/</guid>
      <description>&lt;h1 id=&#34;什么是数据宽度&#34;&gt;什么是数据宽度&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e6%95%b0%e6%8d%ae%e5%ae%bd%e5%ba%a6&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;计算机中存储的数据最终都是二进制存储的，计算机只认识1和0，但是不是一下子全部存进去的，而是分成很多的容器，每个容器都有最大容量，比如有的可以装4个二进制数，有的可以装8个二进制数。所以在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度）&lt;/p&gt;&#xA;&lt;p&gt;如果要存储的数超过了容器的数据宽度计算机怎么处理呢？直接将高位多出来的位丢弃！&lt;/p&gt;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;比如一个容器的数据宽度为4位，那么如果我现在存一个数16，化为二进制为10000，由于只能存4位，那么进位的多出来的位会被丢弃，最终读到的是0000，即0&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;存储过程&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;容器只有 &lt;strong&gt;4 位&lt;/strong&gt;，意味着它本质就是一个 &lt;strong&gt;4 位寄存器/存储单元&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;当你把 &lt;code&gt;16&lt;/code&gt;（二进制 &lt;code&gt;10000&lt;/code&gt;）写进去时，计算机会 &lt;strong&gt;只保留低 4 位&lt;/strong&gt;：&lt;/li&gt;&#xA;&lt;li&gt;10000   （5 位原始数据）&lt;/li&gt;&#xA;&lt;li&gt;↓ 截断高位&lt;/li&gt;&#xA;&lt;li&gt;0000    （只剩 4 位）&lt;/li&gt;&#xA;&lt;li&gt;结果：读出来是 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;再看几个例子&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;存  8（二进制 &lt;code&gt;1000&lt;/code&gt;） → &lt;code&gt;1000&lt;/code&gt;（还能放得下） → 结果 = 8&lt;/li&gt;&#xA;&lt;li&gt;存 15（二进制 &lt;code&gt;1111&lt;/code&gt;） → &lt;code&gt;1111&lt;/code&gt; → 结果 = 15&lt;/li&gt;&#xA;&lt;li&gt;存 16（二进制 &lt;code&gt;10000&lt;/code&gt;） → 截断 → &lt;code&gt;0000&lt;/code&gt; → 结果 = 0&lt;/li&gt;&#xA;&lt;li&gt;存 17（二进制 &lt;code&gt;10001&lt;/code&gt;） → 截断 → &lt;code&gt;0001&lt;/code&gt; → 结果 = 1&lt;/li&gt;&#xA;&lt;li&gt;存 18（二进制 &lt;code&gt;10010&lt;/code&gt;） → 截断 → &lt;code&gt;0010&lt;/code&gt; → 结果 = 2&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h1 id=&#34;无符号数有符号数&#34;&gt;无符号数、有符号数&lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b0%e6%9c%89%e7%ac%a6%e5%8f%b7%e6%95%b0&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;以前我们只是记住：如果一个存储单元只有 &lt;strong&gt;4 位&lt;/strong&gt;，&lt;/p&gt;</description>
    </item>
    <item>
      <title>03.逻辑运算</title>
      <link>http://localhost:1313/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/03.%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/03.%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/</guid>
      <description>&lt;h1 id=&#34;逻辑运算的引入&#34;&gt;逻辑运算的引入&lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97%e7%9a%84%e5%bc%95%e5%85%a5&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;如果现在只是将数据存到计算机的容器中，是没有任何意义的，我们还需要告诉计算机这些数据有什么用，让计算机对这些数做运算。所以我们知道计算机到底是如何做运算的，所以我们引入逻辑运算&lt;/p&gt;&#xA;&lt;h1 id=&#34;逻辑运算&#34;&gt;逻辑运算&lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;由于计算机受硬件的限制影响，CPU再复杂可以理解为一条条的线路组成的，而电信号只有两种形式0和1，所以一般计算机的逻辑运算的对象都是二进制数&lt;/p&gt;&#xA;&lt;p&gt;逻辑运算分为：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;逻辑运算&lt;/th&gt;&#xA;          &lt;th&gt;汇编符号&lt;/th&gt;&#xA;          &lt;th&gt;C语言符号&lt;/th&gt;&#xA;          &lt;th&gt;口诀&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;与&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;AND&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;有0则0，全1才1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;或&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;OR&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;`&lt;/td&gt;&#xA;          &lt;td&gt;`&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;异或&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;XOR&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;相同为0，相异为1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;非&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;NOT&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;!&lt;/code&gt; 或 &lt;code&gt;~&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;0变1，1变0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;cpu是如何计算23&#34;&gt;CPU是如何计算2+3&lt;a class=&#34;anchor&#34; href=&#34;#cpu%e6%98%af%e5%a6%82%e4%bd%95%e8%ae%a1%e7%ae%9723&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;初始数据&lt;/strong&gt;（二进制表示）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;code&gt;x = 2&lt;/code&gt;，二进制表示：&lt;code&gt;0010&lt;/code&gt;&#xA;&lt;code&gt;y = 3&lt;/code&gt;，二进制表示：&lt;code&gt;0011&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&#x9;0010&#x9;&#xD;&#xA;xor 0011&#xD;&#xA;------------&#xD;&#xA;&#x9;0001        R:0001&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;0010&#xD;&#xA;and 0011&#xD;&#xA;------------&#xD;&#xA;&#x9;0010  &amp;lt;&amp;lt;1  得   0100       #&amp;lt;&amp;lt;1表示左移一位&#xD;&#xA;&#x9;&#xD;&#xA;此时计算机会判断0100是否全为0,如果全为0表示运算结束,将R中此时的值作为结果输出,如果不为0则将R中的值赋给x。0100赋给y再做一次同样运算&#xD;&#xA;&#xD;&#xA;&#x9;0001&#xD;&#xA;xor 0100&#xD;&#xA;-------------&#xD;&#xA;&#x9;0101         R:0101&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;0001&#xD;&#xA;and 0100&#xD;&#xA;-------------&#xD;&#xA;&#x9;0000  &amp;lt;&amp;lt;1  得   0000&#xD;&#xA;&#xD;&#xA;判断0000全为0,则运算结束,将R中的值0101作为运算的结果,化成十进制即为5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结&lt;/p&gt;&#xA;&lt;p&gt;这个过程模拟了 &lt;strong&gt;加法运算&lt;/strong&gt;，通过 &lt;strong&gt;XOR&lt;/strong&gt; 来计算和，使用 &lt;strong&gt;AND&lt;/strong&gt; 来计算进位，然后通过 &lt;strong&gt;左移&lt;/strong&gt; 来处理进位，最终得到结果 &lt;code&gt;5&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>04.寄存器</title>
      <link>http://localhost:1313/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/04.%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/04.%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description>&lt;h1 id=&#34;寄存器&#34;&gt;寄存器&lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%84%e5%ad%98%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;寄存器的基本概念&#34;&gt;寄存器的基本概念&lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%84%e5%ad%98%e5%99%a8%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;计算机存储数据的地方，有三个地方：&lt;code&gt;CPU&lt;/code&gt; &amp;gt; &lt;code&gt;内存&lt;/code&gt; &amp;gt; &lt;code&gt;硬盘&lt;/code&gt;&#xA;其中，&lt;code&gt;寄存器&lt;/code&gt;是指 CPU 内部用来存储数据的高速存储单元。&#xA;如果你使用的是一个 32 位的 CPU，那么它能提供的寄存器通常有：8 位、16 位、32 位的访问形式。&lt;/p&gt;&#xA;&lt;h2 id=&#34;通用寄存器&#34;&gt;通用寄存器&lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%9a%e7%94%a8%e5%af%84%e5%ad%98%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在 CPU 里面，寄存器分很多类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;通用寄存器（General Purpose Register, GPR）&lt;/strong&gt;&#xA;→ 可以存数据、存地址、存中间运算结果，用途比较广。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;专用寄存器&lt;/strong&gt;&#xA;→ 有固定功能，不能随便用，比如：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EIP：指令指针寄存器，存放下一条要执行指令的地址&lt;/li&gt;&#xA;&lt;li&gt;EFLAGS：标志寄存器，存放运算结果的标志位（零/进位/溢出等）&lt;/li&gt;&#xA;&lt;li&gt;段寄存器：负责内存分段管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;因为通用寄存器不像 EIP、EFLAGS 那样被“锁死”在某个功能上，而是&lt;strong&gt;灵活多用&lt;/strong&gt;，所以才叫 &lt;strong&gt;通用&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;x86-架构中的-32-位通用寄存器&#34;&gt;x86 架构中的 32 位通用寄存器&lt;a class=&#34;anchor&#34; href=&#34;#x86-%e6%9e%b6%e6%9e%84%e4%b8%ad%e7%9a%84-32-%e4%bd%8d%e9%80%9a%e7%94%a8%e5%af%84%e5%ad%98%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在 32 位 CPU 中，常见的通用寄存器有 8 个：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;寄存器&lt;/th&gt;&#xA;          &lt;th&gt;编号&lt;/th&gt;&#xA;          &lt;th&gt;存储数据范围&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;EAX&lt;/td&gt;&#xA;          &lt;td&gt;0&lt;/td&gt;&#xA;          &lt;td&gt;0 - 0xFFFFFFFF&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ECX&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;0 - 0xFFFFFFFF&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;EDX&lt;/td&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;0 - 0xFFFFFFFF&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;EBX&lt;/td&gt;&#xA;          &lt;td&gt;3&lt;/td&gt;&#xA;          &lt;td&gt;0 - 0xFFFFFFFF&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ESP&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;0 - 0xFFFFFFFF&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;EBP&lt;/td&gt;&#xA;          &lt;td&gt;5&lt;/td&gt;&#xA;          &lt;td&gt;0 - 0xFFFFFFFF&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ESI&lt;/td&gt;&#xA;          &lt;td&gt;6&lt;/td&gt;&#xA;          &lt;td&gt;0 - 0xFFFFFFFF&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;EDI&lt;/td&gt;&#xA;          &lt;td&gt;7&lt;/td&gt;&#xA;          &lt;td&gt;0 - 0xFFFFFFFF&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个寄存器都是独立的存储单元&lt;/li&gt;&#xA;&lt;li&gt;每个寄存器固定大小：32 位 → 4 字节&lt;/li&gt;&#xA;&lt;li&gt;它们可以同时存储不同的数据，互不干扰，EAX 装的数据不会“占用” EBX、ECX 的空间。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;虽然名字上都算“通用寄存器”，但在实际编程时它们会有&lt;strong&gt;习惯性用途&lt;/strong&gt;：虽然名字上都叫“通用寄存器”，但在实际编程时，它们往往有&lt;strong&gt;习惯性用途&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>05.内存</title>
      <link>http://localhost:1313/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/05.%E5%86%85%E5%AD%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/05.%E5%86%85%E5%AD%98/</guid>
      <description>&lt;h1 id=&#34;cpu-的位&#34;&gt;CPU 的“位”&lt;a class=&#34;anchor&#34; href=&#34;#cpu-%e7%9a%84%e4%bd%8d&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;32-位指的是什么&#34;&gt;32 位指的是什么？&lt;a class=&#34;anchor&#34; href=&#34;#32-%e4%bd%8d%e6%8c%87%e7%9a%84%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;CPU 的位数&lt;/strong&gt; = &lt;strong&gt;寄存器宽度 + ALU 运算位宽 + 地址总线宽度&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;寄存器宽度 = 32 位&lt;/strong&gt; → 每个寄存器能存 4 字节数据&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ALU = 32 位&lt;/strong&gt; → 一次运算处理 32 位数据&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;地址总线 = 32 位&lt;/strong&gt; → 可寻址空间 = 2³² 字节 = 4GB&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;✅ 关键点：&lt;strong&gt;“32 位”不是随便说的，而是 CPU 各个核心部件设计的一致结果。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;寄存器宽度&lt;/strong&gt; → 决定数据存储/运算能力&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;地址总线宽度&lt;/strong&gt; → 决定最大内存寻址范围&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ALU 宽度&lt;/strong&gt; → 决定一次能处理多少位的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;cpu-操作寄存器与内存的区别&#34;&gt;CPU 操作寄存器与内存的区别&lt;a class=&#34;anchor&#34; href=&#34;#cpu-%e6%93%8d%e4%bd%9c%e5%af%84%e5%ad%98%e5%99%a8%e4%b8%8e%e5%86%85%e5%ad%98%e7%9a%84%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;cpu-访问寄存器的方式&#34;&gt;CPU 访问寄存器的方式&lt;a class=&#34;anchor&#34; href=&#34;#cpu-%e8%ae%bf%e9%97%ae%e5%af%84%e5%ad%98%e5%99%a8%e7%9a%84%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;位置&lt;/strong&gt;：CPU 内部的小型高速存储&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;寄存器存的是什么&lt;/strong&gt;：数据本身（整数、浮点数、指针等）&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;访问方式&lt;/strong&gt;：直接访问&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例：&lt;code&gt;MOV EAX, 5&lt;/code&gt; → EAX 直接存储数值 5（32 位）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：容量小、速度最快&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;cpu-访问内存的方式&#34;&gt;CPU 访问内存的方式&lt;a class=&#34;anchor&#34; href=&#34;#cpu-%e8%ae%bf%e9%97%ae%e5%86%85%e5%ad%98%e7%9a%84%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;位置&lt;/strong&gt;：CPU 外部的大容量存储&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
