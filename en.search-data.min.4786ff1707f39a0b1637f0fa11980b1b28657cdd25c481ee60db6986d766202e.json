[{"id":0,"href":"/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/01.%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/","title":"01.进制基础","section":"逆向初级","content":"计算机与数字的关系# 信息的二进制表示# 计算机处理的任何信息，包括图片、视频、音乐、文字、程序，最终都是以 二进制 0 和 1 的形式存储和处理的。 二进制是计算机唯一“能理解”的语言。 为什么计算机使用二进制\n二进制足够表达所有信息 每一位只有 0 和 1，组合起来可以表示任意数据。 受硬件制约 电子电路中开关只有两种状态：通/断、亮/灭，对应 1/0 二进制与硬件自然匹配，可靠且稳定 进制的本质# 如果将进制定义成这样，你有何想法?\n十进制的定义\r由十个符号组成\r如果改成这样呢? 9152476380 逢十进一，10是多少呢？用19表示\r-或写成这样呢？\r@ # ! $ ^ \u0026amp; * ( = 逢十进一，十用#@表示\r了解事物的本质，如果将上面的符号用于加密，那会给解密者代理极大的麻烦所以2+3=1成立吗？\n成立的，元素是可以自己定义的\r自定义符号： 0 2 3 1 8 7 6 9 5 4\r标准数值： 0 1 2 3 4 5 6 7 8 9世界上有多少种进制？\n世界可以有任何进制，但一进制除外\r进制要求：满 N 进 1\r老师让学生数 5 只羊,\r学生画：| | | | | 或者刻“正”字\r不进位，只是重复堆符号常用的进制# 在计算机中，常用的数值进制包括二进制、八进制、十进制和十六进制。\n二进制\n只有两个数字：0 和 1 每一位称为 bit（位） 适合计算机底层使用（电平高低） 示例：0b1010 表示十进制的 10 八进制\n符号：通常写作 0o，例如 0o17\n位数：每位数字 0~7\n用途：\n曾经用于计算机汇编编程\n方便把二进制每三位分组表示\n八进制的每一位正好对应二进制的三位\n十进制\n符号：普通数字 0~9 用途：人类日常使用，编程中输入/输出数据时通常用十进制表示 示例：1234 是标准的十进制表示 十六进制\n符号：通常以 0x 开头 位数：0 1 2 3 4 5 6 7 8 9 a b c d e f 用途：常用来表示内存地址、颜色、机器码等 一个十六进制位用4个二进制位表示 示例：0x1A3F == 二进制 0001 1010 0011 1111 == 十进制 6719 进制运算# 计算的核心，就是查数（掰手指）\n十进制表# 加法表\n1+1=2\r1+2=3 2+2=4\r1+3=4 2+3=5 3+3=6\r1+4=5 2+4=6 3+4=7 4+4=8\r1+5=6 2+5=7 3+5=8 4+5=9 5+5=10\r1+6=7 2+6=8 3+6=9 4+6=10 5+6=11 6+6=12\r1+7=8 2+7=9 3+7=10 4+7=11 5+7=12 6+7=13 7+7=14\r1+8=9 2+8=10 3+8=11 4+8=12 5+8=13 6+8=14 7+8=15 8+8=16\r1+9=10 2+9=11 3+9=12 4+9=13 5+9=14 6+9=15 7+9=16 8+9=17 9+9=18乘法表\n1×1=1\r1×2=2 2×2=4\r1×3=3 2×3=6 3×3=9\r1×4=4 2×4=8 3×4=12 4×4=16\r1×5=5 2×5=10 3×5=15 4×5=20 5×5=25\r1×6=6 2×6=12 3×6=18 4×6=24 5×6=30 6×6=36\r1×7=7 2×7=14 3×7=21 4×7=28 5×7=35 6×7=42 7×7=49\r1×8=8 2×8=16 3×8=24 4×8=32 5×8=40 6×8=48 7×8=56 8×8=64\r1×9=9 2×9=18 3×9=27 4×9=36 5×9=45 6×9=54 7×9=63 8×9=72 9×9=81八进制# 数数表\n0 1 2 3 4 5 6 7\r10 11 12 13 14 15 16 17\r20 21 22 23 24 25 26 27\r30 31 32 33 34 35 36 37\r40 41 42 43 44 45 46 47\r50 51 52 53 54 55 56 57\r60 61 62 63 64 65 66 67\r70 71 72 73 74 75 76 77\r100八进制加法表\n1+1=2\r1+2=3 2+2=4\r1+3=4 2+3=5 3+3=6\r1+4=5 2+4=6 3+4=7 4+4=10\r1+5=6 2+5=7 3+5=10 4+5=11 5+5=12\r1+6=7 2+6=10 3+6=11 4+6=12 5+6=13 6+6=14\r1+7=10 2+7=11 3+7=12 4+7=13 5+7=14 6+7=15 7+7=16八进制乘法表\n1×1=1\r1×2=2 2×2=4\r1×3=3 2×3=6 3×3=11\r1×4=4 2×4=10 3×4=14 4×4=20\r1×5=5 2×5=12 3×5=17 4×5=24 5×5=31\r1×6=6 2×6=14 3×6=22 4×6=30 5×6=36 6×6=44\r1×7=7 2×7=16 3×7=25 4×7=34 5×7=43 6×7=52 7×7=61十六进制# 数数表\n0 1 2 3 4 5 6 7 8 9 A B C D E F\r10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F\r20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F\r30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F\r40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F\r50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F\r60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F\r70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F\r80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F\r90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F\rA0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF\rB0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC BD BE BF\rC0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF\rD0 D1 D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF\rE0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF\rF0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF十六六乘法表\n1×1=1\r1×2=2 2×2=4\r1×3=3 2×3=6 3×3=9\r1×4=4 2×4=8 3×4=C 4×4=10\r1×5=5 2×5=A 3×5=F 4×5=14 5×5=19\r1×6=6 2×6=C 3×6=12 4×6=18 5×6=1E 6×6=24\r1×7=7 2×7=E 3×7=15 4×7=1C 5×7=23 6×7=2A 7×7=31\r1×8=8 2×8=10 3×8=18 4×8=20 5×8=28 6×8=30 7×8=38 8×8=40\r1×9=9 2×9=12 3×9=1B 4×9=24 5×9=2D 6×9=36 7×9=3F 8×9=48 9×9=51\r1×A=A 2×A=14 3×A=1E 4×A=28 5×A=32 6×A=3C 7×A=46 8×A=50 9×A=5A A×A=64\r1×B=B 2×B=16 3×B=21 4×B=2C 5×B=37 6×B=42 7×B=4D 8×B=58 9×B=63 A×B=6E B×B=79\r1×C=C 2×C=18 3×C=24 4×C=30 5×C=3C 6×C=48 7×C=54 8×C=60 9×C=6C A×C=78 B×C=84 C×C=90\r1×D=D 2×D=1A 3×D=27 4×D=34 5×D=41 6×D=4E 7×D=5B 8×D=68 9×D=75 A×D=82 B×D=8F C×D=9C D×D=A9\r1×E=E 2×E=1C 3×E=2A 4×E=38 5×E=46 6×E=54 7×E=62 8×E=70 9×E=7E A×E=8C B×E=9A C×E=A8 D×E=B6 E×E=C4\r1×F=F 2×F=1E 3×F=2D 4×F=3C 5×F=4B 6×F=5A 7×F=69 8×F=78 9×F=87 A×F=96 B×F=A5 C×F=B4 D×F=C3 E×F=D2 F×F=E1加法表\n1+1=2\r1+2=3 2+2=4\r1+3=4 2+3=5 3+3=6\r1+4=5 2+4=6 3+4=7 4+4=8\r1+5=6 2+5=7 3+5=8 4+5=9 5+5=A\r1+6=7 2+6=8 3+6=9 4+6=A 5+6=B 6+6=C\r1+7=8 2+7=9 3+7=A 4+7=B 5+7=C 6+7=D 7+7=E\r1+8=9 2+8=A 3+8=B 4+8=C 5+8=D 6+8=E 7+8=F 8+8=10\r1+9=A 2+9=B 3+9=C 4+9=D 5+9=E 6+9=F 7+9=10 8+9=11 9+9=12\r1+A=B 2+A=C 3+A=D 4+A=E 5+A=F 6+A=10 7+A=11 8+A=12 9+A=13 A+A=14\r1+B=C 2+B=D 3+B=E 4+B=F 5+B=10 6+B=11 7+B=12 8+B=13 9+B=14 A+B=15 B+B=16\r1+C=D 2+C=E 3+C=F 4+C=10 5+C=11 6+C=12 7+C=13 8+C=14 9+C=15 A+C=16 B+C=17 C+C=18\r1+D=E 2+D=F 3+D=10 4+D=11 5+D=12 6+D=13 7+D=14 8+D=15 9+D=16 A+D=17 B+D=18 C+D=19 D+D=1A\r1+E=F 2+E=10 3+E=11 4+E=12 5+E=13 6+E=14 7+E=15 8+E=16 9+E=17 A+E=18 B+E=19 C+E=1A D+E=1B E+E=1C\r1+F=10 2+F=11 3+F=12 4+F=13 5+F=14 6+F=15 7+F=16 8+F=17 9+F=18 A+F=19 B+F=1A C+F=1B D+F=1C E+F=1D F+F=1E进制进位技巧# 标准三进制# 0 1 2 10 11 12\r20 21 22 #三进制只有012三个数。到22这里，已经没符号可表示了需要进位22后续如何进位，我们来拆解：\n2 2\r+ 1\r------第一步：个位 2 + 1• 2 + 1 = 3 → 但三进制中没有 3•所以：3 ÷ 3 = 1 余 0 → 写 0，向前进位 1\n1←\r2 2\r+ 1\r------\r0第二步：十位 2 + 进位1 2 + 1 = 3 → 又满 3 了！•所以：3 ÷ 3 = 1 余 0 → 写 0，再向前进位 1\n1←\r2 2\r+ 1\r------\r0 0第三步：百位没有数字了，但还有进位 1•所以：在百位写 1\n2 2\r+ 1\r------\r1 0 0继续写\n100 101 102\r110 111 112\r120 121 122 #122 如何进位? 同上方法三进制举例更数值更明显。其他进制也是如此计算\n自定义三进制# 自定义：9 4 6 标准值：0 1 2\n9 4 6\r49 44 46\r69 64 66 #如何进位？\r499 494 496\r6 6\r+ 1\r------\r1 0 0 #100换成三进制499二进制转换进制方法# 二进制权重作用# 权重的本质\n二进制每一位的权重 = 2 的位次\n权重只跟二进制本身有关，和你最终要转换成什么进制无关\n位数 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 权重 32768 16384 8192 4096 2048 1024 512 256 128 64 32 16 8 4 2 1 二进制转换# 1️⃣ 分组法（快速法）# 优点快速、直观、运算量小\n适用条件：\n适用于目标进制是 2 的幂（4、8、16、32、64 …） 每组二进制最大值刚好能表示目标进制的一位 如果目标进制不是 2 的整数次方（比如 3、5、6、7、9、10），就不能分组，只能先转十进制，再转目标进制。 二进制：`10101111`\r- 每 4 位一组：`1010 1111`\r- 左边 1010 = 10 → A\r- 右边 1111 = 15 → F\r- 十六进制 = `AF`\r二进制： 1 0 1 0 1 1 1 1\r位次： 7 6 5 4 3 2 1 0\r权重： 128 64 32 16 8 4 2 1\r分组后： [1010] [1111]\r分组权重： 8 4 2 1 8 4 2 1\r十进制： 10 15\r十六进制： A F\r组合 → AF 目标进制 2 的幂 分组二进制位数 4 2² 2次方,2位二进制一组 2 8 2³ 3次方,3位二进制一组 3 16 2⁴ 4次方,4位二进制一组 4 32 2⁵ 5次方,5位二进制一组 5 64 2⁶ 6次方,6位二进制一组 6 2️⃣ 十进制中转法（通用法）# 适用条件：目标进制 不是 2 的幂（3、5、6、7、9、10、12 …） 方法：二进制 → 十进制 → 任意进制 优点：通用，适用于所有进制 缺点：步骤多、计算量大 二进制 → 十进制（权重求和法） 示例：二进制 101101\n位次 5 4 3 2 1 0 二进制 1 0 1 1 0 1 权重 32 16 8 4 2 1 乘积 32 0 8 4 0 1 十进制 = 32 + 0 + 8 + 4 + 0 + 1 = 45\n十进制 → 目标进制（除基取余法） 公式：十进制数÷目标进制=商\u0026hellip;余数十进制数 ÷ 目标进制 = 商 \u0026hellip; 余数十进制数÷目标进制=商\u0026hellip;余数 余数 = 目标进制的最低位 商继续除基，直到商 = 0 余数 倒序排列 = 最终目标进制表示 示例：45 → 七进制\n45 ÷ 7 = 6 余 3 → 低位 = 3 6 ÷ 7 = 0 余 6 → 高位 = 6 七进制 = 63_7 ✅ 总结口诀：# 目标进制 二进制权重作用 二转十进制 权重求和法 → 直接算 二转二的幂进制 分组法 → 每组权重内部依旧用 2 的幂求和 二转奇数进制 / 其他 十进制中转法 → 权重先算十进制，再除基取余 2进制转16进制表(必背)# 每1个16进制位对应4个二进制位。\n三个关键点记忆\n2 -\u0026gt;10 #进位 3-\u0026gt;11 4-\u0026gt;100 4 -\u0026gt;100 #进位 5-101 6-\u0026gt;110 7-\u0026gt;111 8 -\u0026gt;1000 8 4 2 记前9个 后面记住关键点 A=1010 D=1100 然后都+1\n这个对应关系表需要熟练掌握，做到看见二进制可以直接转为十六进制，反之亦然。\n二进制 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 十六进制 0 1 2 3 4 5 6 7 8 9 A B C D E F "},{"id":1,"href":"/Other/hugo/","title":"hugo使用","section":"Other","content":"https://www.elegantcrazy.com/posts/blog/build-blog-with-github-pages-hugo-and-papermod/\rhttps://jimmysong.io/book/hugo-handbook/introduction/quick-start/ 安装 Git# Hugo 项目通常需要 Git 进行版本控制和主题管理\nhttps://git-scm.com/downloads/win创建仓库# 在Github创建仓库，仓库名填写**[用户名].github.io**，注意[用户名]部分必须是Github用户名，否则Github Pages不会正常工作。\n新建两个仓库\rwchuang099.github.io #博客仓库\rmy-notes-source #备份博客源文件安装 Hugo# 下载安装包，hugo免安装，解压添加环境变量即可\n# 注意 hugo和主题都找最新版的下载即可，老版本会有兼容的问题 https://github.com/gohugoio/hugo/releases/download/v0.148.2/hugo_extended_0.148.2_windows-amd64.zip hugo version生成项目# hugo new site my-notes\rcd my-notes 这将创建标准的项目目录结构，包括： •\tarchetypes/ - 内容模板 •\tassets/ - 资源文件 •\tcontent/ - 内容源文件 •\tdata/ - 数据文件 •\tlayouts/ - 布局模板 •\tstatic/ - 静态文件 •\tthemes/ - 主题 •\thugo.toml – 配置文件，旧版本文件为config.toml\n下载主题# #可以去官网找自己喜欢的主题 https://themes.gohugo.io/\rgit init\rgit submodule add https://github.com/alex-shpak/hugo-book themes/book配置文件hugo.yaml# baseURL: http://localhost:1313/ languageCode: zh-CN title: 我的技术笔记 theme: book # 关键行为 disablePathToLower: true enableGitInfo: false # Markdown 支持（按需保留） markup: goldmark: renderer: unsafe: true # 如果你要用 Mermaid/KaTeX/HTML，必须开 highlight: style: monokai # 可选，代码高亮主题 # Book 主题参数 params: BookToC: true # 右侧目录 BookSection: \u0026#34;*\u0026#34; # 左侧显示所有分类 BookSearch: true # 搜索功能（可选）文章组织结构# my-notes/content/\r└── python/\r├── _index.md\r├── Python基础知识/\r│ ├── _index.md\r│ ├── 01-数据类型.md\r│ └── images/ # 如在01-数据类型.md引用：![图](../images/test.png)\r│ └── test.png\r│\r└── Python应用代码/\r├── _index.md\r├── pandas.md\r└── images/ └── test.png文档元数据信息# 推荐配置模板（可直接套用）\r1. 父分类（如 python/_index.md）\r---\rtitle: \u0026#34;Python\u0026#34;\rbookCollapseSection: true\rweight: 1\r---\r2. 子分类首页（如 基础语法/_index.md）\r---\rtitle: \u0026#34;基础语法\u0026#34;\rbookCollapseSection: true\rweight: 1\r---\r3. 具体笔记页（01-数据类型.md）\r---\rtitle: \u0026#34;变量\u0026#34;\rweight: 1\r---开发与测试# 启动开发服务器 hugo server -D -D 标志表示构建草稿内容。服务器会： •\t在本地构建网站并提供服务（通常在 http://localhost:1313） •\t监控项目目录中的文件变化 •\t检测到变化时自动重建并实时刷新浏览器（LiveReload）\n发布站点# 准备发布 将草稿状态设置为 false或者直接删掉，默认false 将元数据调整如下，更符合自己的主题 --- title: \u0026#34;hugo使用\u0026#34; date: 2025-08-06 lastmod: 2025-08-07T10:30:00+08:00 tags: [\u0026#34;hugo\u0026#34;] categories: [\u0026#34;博客\u0026#34;] description: \u0026#34;如何使用hugo\u0026#34; --- 生成静态文件,运行构建命令： hugo 这会在项目根目录下的 public 目录中生成完整的静态网站，包括： •\tHTML 文件 •\tCSS 和 JavaScript 文件 •\t图像等静态资源\n重要注意事项 •\tHugo 不会自动清空 public 目录 •\t构建时会覆盖现有文件，但不会删除旧文件 •\t根据需要手动清理该目录以避免文件残留 •\t默认情况下不包含草稿、未来或过期内容 调试工具 •\t使用 hugo server \u0026ndash;debug 获取详细日志 •\t使用 hugo config 查看完整站点配置 •\t使用 hugo list drafts 查看所有草稿文件 4.在Github Pages上部署网站# 进入 public 目录（Hugo 生成的页面）\ngit config --global https.proxy http://127.0.0.1:15715 git config --global http.proxy http://127.0.0.1:15715 cd public git init git remote add origin https://github.com/wchuang099/wchuang099.github.io.git git add . git commit -m \u0026#34;deploy\u0026#34; git branch -M main git push -f origin main过几分钟访问即可：wchuang099.github.io\n更新流程 每次你写完文章或改完配置，只需要将以下保存bat执行：\n@echo off chcp 65001 REM 切换到博客源码目录 cd /d D:\\AllFile\\my-notes REM 删除旧 public rmdir /s /q public REM 生成静态文件 hugo REM 进入 public cd public REM 确保 Git 仓库存在 if not exist \u0026#34;.git\u0026#34; ( git init git checkout -b main git remote add origin https://github.com/wchuang099/wchuang099.github.io.git ) else ( git remote set-url origin https://github.com/wchuang099/wchuang099.github.io.git ) REM 提交并推送 git add . git commit -m \u0026#34;自动部署：%date% %time%\u0026#34; git push -f origin main echo ✅ 博客已成功部署！ pause备份网站# 为了备份你的博客原始文件（包括 Markdown 笔记、配置文件、主题等），建议再建一个 源码仓库。\n✅ 推荐的结构：两个 Git 仓库\n用途 内容 GitHub 仓库 部署用 public/ 静态页面 yourusername.github.io 源码备份 所有博客源文件 my-notes-source 添加 .gitignore 文件，避免上传 public/ 内容\r在博客根目录下创建 .gitignore 文件，内容如下：\rpublic/\rresources/\r*.DS_Store\r*.log\r.hugo_build.lock\rdesktop.ini\r.idea\r第一次提交\rcd my-notes # 你博客项目的根目录\rgit init\rgit add .\rgit commit -m \u0026#34;first commit\u0026#34;\rgit branch -M main\rgit remote add origin https://github.com/wchuang099/my-notes-source.git\rgit push -u origin main自动发布备份脚本\n@echo off\rchcp 65001\rREM === Hugo 博客源码备份脚本 ===\rREM === 将源码（含文章、主题等）备份到 GitHub ===\rREM 提交并推送源码到 my-notes 仓库\rgit add .\rgit commit -m \u0026#34;备份博客源码：%date% %time%\u0026#34;\rgit remote remove origin\rgit remote add origin https://github.com/wchuang099/my-notes-source.git\rgit branch -M main\rgit push -u origin main\recho ✅ 博客源码备份完成！\rpause"},{"id":2,"href":"/Python/Python%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81/Jupyter%E4%BD%BF%E7%94%A8/","title":"Jupyter使用","section":"Python应用代码","content":"Jupyter 是一个交互式的计算环境，主要用于写、运行和展示代码（Python、R、Julia 等），非常适合做数据分析、可视化、机器学习实验或者写教程笔记。\n安装 Jupyter# Jupyter 需要 Python 环境\npip install notebook pip install jupyterlab-language-pack-zh-CN jupyter notebook #进入你想工作的文件夹，然后启动。 jupyter lab #这是另一种启动方式,jupyterlab是jupyter notebook的下一代产品，集成了更多功能 浏览器会自动打开 http://localhost:8888 如果浏览器没自动打开，会在终端看到一个链接，复制到浏览器即可。 启动后在Settings\u0026ndash;Language-Chinese (Simplified, China)-中文(简体,中国)，进行切换显示语言。\n基本使用# 创建新 Notebook# 在网页右上角选择 New → Python 3（或其它语言） 会出现一个 .ipynb 文件，分为 Cell（单元格）\n单元格类型\nCode：写代码并运行（Shift + Enter 执行） Markdown：写文字说明（支持标题、公式、图片） Raw：原始文本，不执行常用快捷键（命令模式下）# Esc 进入命令模式，Enter 进入编辑模式 A 在上方插入单元格 B 在下方插入单元格 DD 删除单元格 M 把单元格改为 Markdown Y 把单元格改为 Code Shift + Enter 运行并跳到下一格 在 Jupyter Notebook 里，打开帮助文档的快捷键是： 按 Shift + Tab，把光标放到函数或对象名后面，按一次 Shift + Tab 会弹出简要帮助提示（参数说明）。 连续按 Shift + Tab 两次或三次，会展开更详细的文档窗口。进阶技巧# 可视化示例 import matplotlib.pyplot as plt x = [1, 2, 3, 4] y = [1, 4, 9, 16] plt.plot(x, y) plt.show()Jupyter + Pandas 数据分析入门示例# 安装必要的库\npip install pandas matplotlib 代码示例\nimport pandas as pd import matplotlib.pyplot as plt # 让图表直接显示在 Notebook 中 %matplotlib inline # 设置中文字体 plt.rcParams[\u0026#34;font.family\u0026#34;] = [\u0026#34;Microsoft YaHei\u0026#34;] plt.rcParams[\u0026#34;axes.unicode_minus\u0026#34;] = False # ===== 1. 创建模拟账单数据 ===== data = { \u0026#34;日期\u0026#34;: [\u0026#34;2025-08-01\u0026#34;, \u0026#34;2025-08-01\u0026#34;, \u0026#34;2025-08-02\u0026#34;, \u0026#34;2025-08-02\u0026#34;, \u0026#34;2025-08-03\u0026#34;], \u0026#34;分类\u0026#34;: [\u0026#34;餐饮\u0026#34;, \u0026#34;交通\u0026#34;, \u0026#34;餐饮\u0026#34;, \u0026#34;购物\u0026#34;, \u0026#34;交通\u0026#34;], \u0026#34;金额\u0026#34;: [35.5, 12.0, 58.0, 200.0, 18.0], \u0026#34;备注\u0026#34;: [\u0026#34;早餐\u0026#34;, \u0026#34;地铁\u0026#34;, \u0026#34;午餐\u0026#34;, \u0026#34;超市\u0026#34;, \u0026#34;公交\u0026#34;] } df = pd.DataFrame(data) df[\u0026#34;日期\u0026#34;] = pd.to_datetime(df[\u0026#34;日期\u0026#34;]) print(\u0026#34;=== 原始数据 ===\u0026#34;) print(df) print(\u0026#34;\\n=== 餐饮类消费 ===\u0026#34;) print(df[df[\u0026#34;分类\u0026#34;] == \u0026#34;餐饮\u0026#34;]) category_sum = df.groupby(\u0026#34;分类\u0026#34;)[\u0026#34;金额\u0026#34;].sum().reset_index() print(\u0026#34;\\n=== 按分类汇总 ===\u0026#34;) print(category_sum) plt.figure(figsize=(5, 5)) plt.pie(category_sum[\u0026#34;金额\u0026#34;], labels=category_sum[\u0026#34;分类\u0026#34;], autopct=\u0026#34;%.1f%%\u0026#34;) plt.title(\u0026#34;各类消费占比\u0026#34;) plt.show() daily_sum = df.groupby(\u0026#34;日期\u0026#34;)[\u0026#34;金额\u0026#34;].sum().reset_index() plt.figure(figsize=(6, 4)) plt.plot(daily_sum[\u0026#34;日期\u0026#34;], daily_sum[\u0026#34;金额\u0026#34;], marker=\u0026#34;o\u0026#34;) plt.title(\u0026#34;每日总消费趋势\u0026#34;) plt.xlabel(\u0026#34;日期\u0026#34;) plt.ylabel(\u0026#34;金额 (元)\u0026#34;) plt.grid(True) plt.show()"},{"id":3,"href":"/Python/Python%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81/Loguru-%E5%89%AF%E6%9C%AC/","title":"Loguru","section":"Python应用代码","content":"1\n"},{"id":4,"href":"/Python/Python%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81/Loguru/","title":"Loguru","section":"Python应用代码","content":"1\n"},{"id":5,"href":"/Other/Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"Markdown使用教程","section":"Other","content":"一、Markdown简介# Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\nMarkdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\nMarkdown 编写的文档后缀为 .md, .markdown。\nMarkdown 能被使用来撰写电子书，如：Gitbook。/\n当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。 markdown编写Hello World!语法：\n# Hello World!二、Markdown标题# 使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。\n使用#号标记标题语法格式：\n# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题三、Markdown段落# Markdown的段落没有特殊的格式，直接编写文字就好，段落的换行号是使用两个以上的空格加回车。\n3.1 字体\nMarkdown 可以使用以下几种字体：\n用1个星号*或底线_表示斜体 用2个星号*或底线_表示粗体 用3个星号*或底线_表示粗斜体 语法格式：\n*斜体文字* _斜体文字_ **粗体文字** __粗体文字__ ***粗斜体文字*** ___粗斜体文字___显示效果：\n斜体文字\n斜体文字\n粗体文字\n粗体文字\n*粗斜体文字*\n*粗斜体文字*\n3.2 分隔线\n可以在一行中用三个以上的星号*、减号-、底线_来建立一个分隔线，行内不能有其他东西，你也可以在星号或减号蹭插入空格。下面这种写法都可以建立分隔线：\n*** * * * ****** - - - ------显示效果：\n3.3 删除线\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线~~即可。\n语法格式：\nbaidu.com sina.com ~~tencent.com~~显示效果如下：\nhttp://baidu.com http://sina.com tencent.com\n3.4 下划线\n下划线可以通过HTML的标签来实现\n\u0026lt;u\u0026gt;带下划线文本\u0026lt;/u\u0026gt;显示效果如下： 带下划线文本\n3.5 脚注\n脚注是对文本的补充说明。\nMarkdown脚注的格式如下：\n[^要注明的文本]：显示效果： [^要注明的文本]：\n四、Markdown 列表# 4.1 有序列表和无序列表\nMarkdown支持有序列表和无序列表，无序列表使用星号(*)、加号(+)或者减号(-)作为标记：\n* 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项显示效果：\n第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 有序列表直接在文字有加上1. 2. 3. 来表示，符号和文字之间加上一个空格字符，如：\n1. 第一项 2. 第二项 3. 第三项 第一项 第二项 第三项 4.2 列表嵌套\n列表嵌套只需在子列表的选项前添加四个空格即可：\n1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素显示效果：\n第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第二个元素 五、Markdown区块# Markdown区块引用是在段落开头使用\u0026gt;符号，然后后面紧跟一个空格符号：\n\u0026gt; 区块引用 \u0026gt; Markdown教程 \u0026gt; 学的不仅是技术更是梦想显示效果如下：\n区块引用 Markdown教程 学的不仅是技术更是梦想\n另外区块是可以嵌套的，一个\u0026gt;符号是最外层，两个符号是第一层嵌套，以此类推：\n\u0026gt; 最外层 \u0026gt;\u0026gt; 第一层嵌套 \u0026gt;\u0026gt;\u0026gt; 第二层嵌套显示效果如下：\n最外层 第一层嵌套 第二层嵌套\n5.1 区块中使用列表\n区块中使用列表实例如下：\n\u0026gt; 区块中使用列表 \u0026gt; 1. 第一项 \u0026gt; 2. 第二项 \u0026gt; + 第一项 \u0026gt; + 第二项 \u0026gt; + 第三项显示效果：\n区块中使用列表 1. 第一项 2. 第二项 + 第一项 + 第二项 + 第三项\n5.2 列表中使用区块\n如果要在列表项目内放进区块，那么就需要在\u0026gt;前添加四个空格和缩进。\n* 第一项 \u0026gt; Markdown教程 \u0026gt; 学的不仅是技术更是梦想 * 第二项显示效果如下：\n第一项 \u0026gt; Markdown教程 \u0026gt; 学的不仅是技术更是梦想 第二项 六、Markdown代码框# 如果是段落上的一个函数或片段的代码可以用两个\u0026rsquo;把它包起来。\n\u0026#39;print()\u0026#39; 函数\u0026lsquo;print()\u0026rsquo; 函数\n6.1 代码区块\n代码区块使用4个空格或者一个制表符（Tab键）。\n\u0026lt;?Python print(\u0026#39;Markdown\u0026#39;) def test(): print(\u0026#39;Markdown test!\u0026#39;)也可以用\u0026rsquo;\u0026lsquo;\u0026lsquo;包裹一段代码，并指定一种语言（也可以不指定）：\n\u0026#39;\u0026#39;\u0026#39;javascript $(document).read(function(){ alert(\u0026#39;Markdown\u0026#39;); }); \u0026#39;\u0026#39;\u0026#39;显示效果：\n\u0026#39;\u0026#39;\u0026#39;javascript $(document).read(function){ alert(\u0026#39;Markdown\u0026#39;); }); \u0026#39;\u0026#39;\u0026#39;七、Markdown链接# 链接使用方法如下：\n[链接名称](链接地址) 或者 \u0026lt;链接地址\u0026gt;例如：\n这是一个链接 [新浪新闻](https://news.sina.com.cn/) \u0026lt;https://news.sina.com.cn/\u0026gt;显示效果如下：\n这是一个链接 新浪新闻\nhttps://news.sina.com.cn/\n7.1 高级链接\n链接也可以用变量来代替，文档末尾附带变量地址： 这个链接用1作为网址变量[baidu][1] 这个链接用markdown作为网址变量[Markdown][markdown] 然后文档的结尾为变量赋值(网址) [1]: http://www.baidu.com [markdown]: http://www.markdown.com显示效果如下：\n链接也可以用变量来代替，文档末尾附带变量地址： 这个链接用1作为网址变量baidu 这个链接用markdown作为网址变量Markdown 然后文档的结尾为变量赋值(网址)\n八、Markdown图片# Markdown图片语法格式为：\n![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \u0026#34;可选标题\u0026#34;) 开头一个感叹号! 接着一个方括号，里面放上图片的代替文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的\u0026rsquo;title\u0026rsquo;属性文字。 实例如下：\n![有问题上知乎 图标](https://pic4.zhimg.com/80/v2-a47051e92cf74930bedd7469978e6c08_hd.png) --- ![通信人家园 图标](http://www.txrjy.com/static/image/common/logo.gif)显示效果如下：\n也可以像网址那样对图片使用变量：\n这个图片链接用1作为网址变量[zhihu][1] 然后在文档的结尾为变量赋值（网址） [1]: (https://pic4.zhimg.com/80/v2-a47051e92cf74930bedd7469978e6c08_hd.png)显示效果如下：\n这个图片链接用1作为网址变量zhihu 然后在文档的结尾为变量赋值（网址）\nMarkdown 没有办法指定图片的高度与宽度，如果需要的话，可以使用普通的\n标签。\n\u0026lt;img src=“https://pic4.zhimg.com/80/v2-a47051e92cf74930bedd7469978e6c08_hd.png” width=10%\u0026gt;显示效果：\n九、Markdown表格# Markdown制作表格使用|来分隔不同的单元格，使用-来分隔表头和其他行。\n语法格式：\n|表头1|表头2| |----|----| |单元格11|单元格12| |单元格21|单元格22|显示效果：\n| 表头1 | 表头2 | | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026ndash; | | 单元格11 | 单元格12 | | 单元格21 | 单元格22 |\n9.1 对齐方式\n可以设置表头的对齐方式：\n-: 设置内容或标题栏右对齐 :- 设置内容或标题栏左对齐 :-: 设置内容或标题栏居中对齐 语法格式：\n|左对齐|居中对齐|右对齐| |:----|:----:|----:| |单元格11|单元格12|单元格13| |单元格21|单元格22|单元格23|显示效果：\n| 左对齐 | 居中对齐 | 右对齐 | | :\u0026mdash;\u0026mdash;- | :\u0026mdash;\u0026mdash;: | \u0026mdash;\u0026mdash;-: | | 单元格11 | 单元格12 | 单元格13 | | 单元格21 | 单元格22 | 单元格23 |\n十、Markdown高级技巧# 支持的HTML元素\n不在Markdown涵盖范围之内的标签，都可以直接在文档里面用HTML撰写。\n目前支持的HTML元素有： *等 ，如：*\n使用\u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Alt\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Del\u0026lt;/kbd\u0026gt;重启电脑*显示效果如下：*\n*使用Ctrl+Alt+Del重启电脑*\n*10.1 转义*\n*Markdown使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown使用反斜杠转义特殊字符：*\n**文本加粗** \\*\\*正常显示星号\\*\\**显示效果:*\n*文本加粗 *正常显示星号**\n*Mrkdown支持以下这些符号前面加上反斜杠来帮助插入普通符号：*\n\\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号*10.2 数学公式*\n*当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。*\n*实例如下：*\n$$ \\int_0^1 {x^2} \\,{\\rm d}x $$十一、标题自动编号# https://blog.csdn.net/jyn15159/article/details/122978472\n打开Typora这款软件，点击左上角的“文件”，接着点击“偏好设置” 选择“外观”，点击“打开主题文件夹” 打开Typora的theme文件夹，新建样式文件base.user.css\n/** initialize css counter */ #write { counter-reset: h1 } h1 { counter-reset: h2 } h2 { counter-reset: h3 } h3 { counter-reset: h4 } h4 { counter-reset: h5 } h5 { counter-reset: h6 } /** put counter result into headings */ #write h1:before { counter-increment: h1; content: counter(h1) \u0026#34;. \u0026#34; } #write h2:before { counter-increment: h2; content: counter(h1) \u0026#34;.\u0026#34; counter(h2) \u0026#34;. \u0026#34; } #write h3:before, h3.md-focus.md-heading:before /** override the default style for focused headings */ { counter-increment: h3; content: counter(h1) \u0026#34;.\u0026#34; counter(h2) \u0026#34;.\u0026#34; counter(h3) \u0026#34;. \u0026#34; } #write h4:before, h4.md-focus.md-heading:before { counter-increment: h4; content: counter(h1) \u0026#34;.\u0026#34; counter(h2) \u0026#34;.\u0026#34; counter(h3) \u0026#34;.\u0026#34; counter(h4) \u0026#34;. \u0026#34; } #write h5:before, h5.md-focus.md-heading:before counter-increment: h5; content: counter(h1) \u0026#34;.\u0026#34; counter(h2) \u0026#34;.\u0026#34; counter(h3) \u0026#34;.\u0026#34; counter(h4) \u0026#34;.\u0026#34; counter(h5) \u0026#34;. \u0026#34; } #write h6:before, h6.md-focus.md-heading:before { counter-increment: h6; content: counter(h1) \u0026#34;.\u0026#34; counter(h2) \u0026#34;.\u0026#34; counter(h3) \u0026#34;.\u0026#34; counter(h4) \u0026#34;.\u0026#34; counter(h5) \u0026#34;.\u0026#34; counter(h6) \u0026#34;. \u0026#34; } /** override the default style for focused headings */ #write\u0026gt;h3.md-focus:before, #write\u0026gt;h4.md-focus:before, #write\u0026gt;h5.md-focus:before, #write\u0026gt;h6.md-focus:before, h3.md-focus:before, h4.md-focus:before, h5.md-focus:before, h6.md-focus:before { color: inherit; border: inherit; border-radius: inherit; position: inherit; left:initial; float: none; top:initial; font-size: inherit; padding-left: inherit; padding-right: inherit; vertical-align: inherit; font-weight: inherit; line-height: inherit; }保存base.user.css文件，重启Typora软件\n"},{"id":6,"href":"/Windows/nssm%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/","title":"nssm进程管理工具","section":"Windows","content":"nssm注册系统服务# 对于Windows平台来说，很多软件或系统的后台服务是基于windows服务的方式运行的，它的优势是稳定可靠，有进程保护，但对于一些普通exe程序（控制台程序或带界面的windows程序）或bat文件是否也可以封装成windows服务进行运行呢？其实windows本身就有SC.exe，它为Windows系统自带工具，可对Windows系统服务进行创建，查询，启动，停止，删除等操作。但是SC.exe 只支持操作服务控制管理器(SCM)接口规范的系统服务，比如一般的网络服务进程如nginx 等无法作为服务直接启动了，因此本文介绍一个可以封装普通exe程序或bat文件的windows服务工具：NSSM。\nNSSM是一个服务封装程序，它可以将普通exe程序或bat文件封装成服务，使之像windows服务一样运行。同类型的工具还有微软自己的srvany，不过nssm更加简单易用，并且功能强大。它的特点如下：\n支持普通exe程序（控制台程序或者带界面的Windows程序都可以）或bat文件 安装简单又方便 可以重定向输出（并且支持Rotation） 可以自动守护封装了的服务，程序挂掉了后可以自动重启 可以自定义环境变量 可以自定义启动参数 从以上可以得知，NSSM每个功能都很实用，可以大大简化开发流程，降低了开发难度，使用和调试起来也非常方便，特别不需要考虑开发一个服务实现服务守护功能，以确保稳定可靠。 NSSM常用命令# 1.安装服务：nssm install 服务名称 2.删除服务：nssm remove 服务名称 3.删除服务确定：nssm remove 服务名称 confirm 4.修改服务（显示界面修改）：nssm edit 服务名称 5.启动服务：nssm start 服务名称 6.停止服务：nssm stop 服务名名称 7.停止服务：nssm stop 服务名称NSSM使用步骤# 下载NSSM# 1.下载NSSM 2.根据windows平台，将32/64位nssm.exe文件解压至任意文件夹 3.cmd进入到nssm.exe所在目录，如你操作系统是32bit，请对应32位的nssm.exe文件，如你操作系统是64bit，请对应64位的nssm.exe 4.输入 nssm install {服务名称}，即注册Windows服务的名称。\n注册服务# 设置说明，如下： 1.Application Path: 选择系统安装的exe或bat。 2.Startup directory: 选择exe或bat项目的根目录。 3.Arguments: 输入启动参数。 4.Service name: 服务名称 上述步骤操作完成，即可点击Install service来注册服务。 在系统服务中services.msc找到刚刚注册的服务，右键属性 - 恢复即可设置此服务挂掉重启等内容。 需要注意一点，安装完服务后，需要启动服务，否则没有生效。\n"},{"id":7,"href":"/Python/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Numpy/","title":"Numpy","section":"Python数据处理","content":"数据分析：是把隐藏在一些看似杂乱无章的数据背后的信息提炼出来，总结出所研究对象的内在规律 数据分析三剑客：Numpy,Pandas,Matplotlib\nNumpy是Python语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。 NumPy 核心功能：\nNumPy 的核心是 ndarray（多维数组对象），它相比 Python 的 list 有几个优势： 存储更紧凑（同类型数据，连续内存） 运算速度快（底层 C 实现） 支持广播机制（不同形状数组自动匹配运算） 提供大量数学函数和线性代数工具 安装导入# pip install numpy import numpy as np print(np.__version__)创建数组# 一维数组（1D Array）# 就像一个数字列表，只有一个维度。 结构类似 Python 里的列表 [1, 2, 3, 4]。 表示一条“线”上的数据。 arr_1d = np.array([10, 20, 30, 40]) print(arr_1d) # 输出: [10 20 30 40] print(arr_1d.shape) # 输出: (4,) 表示长度是4的一维数组 二维数组（2D Array）# 类似于一个表格（矩阵），有“行”和“列”两个维度。\n结构类似 Python 里的嵌套列表 [[1, 2], [3, 4]]。\n表示“矩阵”或“二维平面”上的数据。\narr_2d = np.array([[1, 2, 3], [4, 5, 6]]) print(arr_2d) # 输出:# [[1 2 3] # [4 5 6]] print(arr_2d.shape) # 输出: (2, 3) 表示2行3列的二维数组三维数组（3D Array）# 形状是 (层数, 行数, 列数)，就是多张二维矩阵叠加在一起。 类似于一个“数据立方体”。 常用于表示彩色图片（宽×高×RGB三通道）、视频帧序列，或者多组二维数据集合。 import numpy as np arr_3d = np.array([ [[1, 2, 3], # 第1层，第一行 [4, 5, 6]], # 第1层，第二行 [[7, 8, 9], # 第2层，第一行 [10, 11, 12]] # 第2层，第二行 ]) print(arr_3d) # 输出： # [[[ 1 2 3] # [ 4 5 6]] # # [[ 7 8 9] # [10 11 12]]] print(arr_3d.shape) # 输出：(2, 2, 3) # 表示2层，每层2行3列 维度 用途举例 视觉形象 1维 数组、向量 线 2维 矩阵、表格 面 3维 立体数据（视频、彩色图） 体（立方体） 更多维度就是在三维基础上继续“叠加”更多维度，但在实际应用中，超过 5~10 维的数组就非常少见了，太高维的数组很难直观理解和处理。\n注意: numpy默认ndarray的所有元素的类型是相同的 如果传进来的列表中包含不同的类型，则统一为同一类型，优先级:str\u0026gt;fioat\u0026gt;int\narr_2d = np.array([[1,2.1,3],[4,5,\u0026ldquo;six\u0026rdquo;]]) print(arr_ad) #([[\u0026lsquo;1\u0026rsquo;, \u0026lsquo;2.1\u0026rsquo;, \u0026lsquo;3\u0026rsquo;], #[\u0026lsquo;4\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;six\u0026rsquo;]], dtype=\u0026rsquo;\u0026lt;U32\u0026rsquo;)\n数组属性# arr.shape # 形状 arr.ndim # 维度 arr.size # 元素总数 arr.dtype # 数据类型数组运算# a + b # 加 a - b # 减 a * b # 元素相乘 a / b # 元素相除 np.dot(a, b) # 矩阵乘法 np.sum(a) # 求和 np.mean(a) # 均值 np.max(a) # 最大值 np.min(a) # 最小值 np.sqrt(a) # 平方根索引与切片# a[0, 2] # 第1行第3列 a[:, 0] # 第一列 a[1, :] # 第二行 a[0:2, 1:3] # 子数组切片 a[a \u0026gt; 5] # 布尔索引形状变换# a.reshape(2, 3) # 改形状 a.flatten() # 拉平成一维 a.T # 转置拼接与分割# np.concatenate([a, b], axis=0) # 行拼接 np.concatenate([a, b], axis=1) # 列拼接 np.split(a, 2, axis=0) # 按行分割随机数# np.random.rand(2, 3) # 0-1均匀分布 np.random.randn(2, 3) # 标准正态分布 np.random.randint(0, 10, (2, 3)) # 整数 np.random.seed(42) # 固定随机数种子"},{"id":8,"href":"/Python/Pyside/pyside%E5%9F%BA%E7%A1%80/","title":"PySide基础","section":"Pyside-GUI开发","content":"一、Qt 是什么？PySide 又是什么？# 名称 说明 Qt 一个跨平台的 C++ 应用程序框架，用于开发 GUI 程序（也支持无界面后台服务）。由 Trolltech 创立，现属 The Qt Company。 PySide Qt 官方提供的 Python 绑定（即用 Python 调用 Qt 功能）。\n• PySide2 → 对应 Qt 5\n• PySide6 → 对应 Qt 6 PyQt Riverbank Computing（第三方公司）提供的 Python 绑定（即用 Python 调用 Qt 功能）。\nPyQt5 → 对应 Qt 5\nPyQt 6 → 对应 Qt 6 如from PySide2.QtWidgets import QPushButton，本质上是在用 Python 调用 C++ 写的 Qt 控件。\n共同基础：PySide和PyQt两者都是 Python 对 Qt C++ 框架的绑定（bindings），用于开发跨平台桌面 GUI 应用（Windows/macOS/Linux）。 功能几乎一致：API 设计高度兼容，95%+ 代码可互换。 PySide = 官方亲儿子 + 免费商用；PyQt = 社区老大哥 + 要求衍生作品开源,闭源需买授权。 二、Qt GUI 架构# QtWidgets ← 高层 UI 控件（widget-based 界面） - 提供窗口（QMainWindow、QWidget）、按钮、标签、表格、布局等 - 所有控件的绘制与事件处理依赖 QtGui 实现 ↓ QtGui ← 图形与窗口系统底层 - 2D 绘图支持（QPainter、QPixmap、QImage） - 字体（QFont）、颜色（QColor）、光标（QCursor） - 键盘/鼠标等输入事件（QKeyEvent、QMouseEvent） - 平台窗口抽象（如屏幕、DPI、原生窗口句柄） - OpenGL/Vulkan 集成支持 ↓ QtCore ← 核心非 GUI 功能（所有 Qt 应用的基础） - 信号与槽机制（由 QObject 提供） - 元对象系统（支持运行时类型识别、动态属性） - 线程（QThread）、定时器（QTimer） - 文件 I/O（QFile）、配置存储（QSettings） - 字符串、容器、国际化等基础工具 依赖关系说明：\nQtWidgets依赖QtGui \u0026ndash;\u0026gt; QtGui依赖QtCore \u0026ndash;\u0026gt; 因此使用 QtWidgets时，自动获得了 QtGui 和 QtCore 的能力（如信号槽） 注意：Qt6 中部分功能（如 QApplication）移到了 QtGui，但 PySide2（Qt5）仍保持上述结构。\n三、PySide2 核心类# 所有控件（如 QPushButton、QLabel）都是独立的类，应按需显式导入 它们分别定义在以下模块中：\nPySide2.QtWidgets：界面控件（窗口、按钮、布局等） PySide2.QtGui：图形、图像、字体、事件等 PySide2.QtCore：核心功能（信号槽、线程、定时器、文件等） from PySide2.QtWidgets import QApplication, QPushButton, QLabel from PySide2.QtGui import QIcon, QFont # 避免 import * from PySide2.QtCore import QTime, Qt1、QtWidgets（界面层：控件 + 应用/窗口类）# 1️⃣ 应用类（非控件）\n类名 说明 QApplication GUI 程序入口，事件循环管理（不是控件） 2️⃣ 窗口类（可作为顶层窗口）\n类名 说明 QWidget 所有控件基类 QMainWindow 主窗口（菜单 / 工具栏 / 状态栏） QDialog 对话框窗口 QFrame 带边框的容器窗口 3️⃣ 布局类（非控件，但必用）\n类名 说明 QHBoxLayout 水平布局 QVBoxLayout 垂直布局 QGridLayout 网格布局 QFormLayout 表单布局 QLayout 布局基类 4️⃣ 基础显示控件\n类名 说明 QLabel 文本 / 图片显示 QProgressBar 进度条 QLCDNumber LCD 数字 QStatusBar 状态栏 5️⃣ 输入与交互控件\n类名 说明 QLineEdit 单行输入框 QTextEdit 富文本编辑 QPlainTextEdit 纯文本编辑 QSpinBox 整数输入 QDoubleSpinBox 浮点输入 QComboBox 下拉框 QCheckBox 复选框 QRadioButton 单选按钮 QSlider 滑动条 6️⃣ 按钮类\n类名 说明 QPushButton 普通按钮 QToolButton 工具按钮 QCommandLinkButton 命令链接按钮 7️⃣ 视图控件（数据展示）\n类名 说明 QListWidget 列表控件 QTreeWidget 树控件 QTableWidget 表格控件 QListView 列表视图（MVC） QTreeView 树视图（MVC） QTableView 表视图（MVC） QHeaderView 表头控制 8️⃣ 容器控件\n类名 说明 QTabWidget 标签页 QStackedWidget 堆叠页面 QGroupBox 分组框 QScrollArea 滚动区域 QSplitter 可拖拽分割 9️⃣ 菜单 / 对话框\n类名 说明 QMenuBar 菜单栏 QMenu 菜单 QAction 动作 QToolBar 工具栏 QMessageBox 消息框 QFileDialog 文件选择 QInputDialog 输入对话框 QColorDialog 颜色选择 QFontDialog 字体选择 2、QtGui（图形 / 字体 / 事件）# 1️⃣ 图像与绘制类\n类名 说明 QPixmap GUI 显示图片 QImage 图像处理 QPainter 绘图 QPen 画笔 QBrush 画刷 QColor 颜色 QIcon 图标 2️⃣ 字体与文本\n类名 说明 QFont 字体 QFontMetrics 字体尺寸 QTextCursor 文本光标 QTextDocument 文本文档 3️⃣ 输入事件\n类名 说明 QKeyEvent 键盘事件 QMouseEvent 鼠标事件 QWheelEvent 滚轮事件 QDrag 拖拽 QClipboard 剪贴板 3、QtCore（核心逻辑 / 多线程 / 工具）# 1️⃣ 对象与信号槽\n类名 说明 QObject 所有 Qt 类基类 Signal 自定义信号 Slot 槽 QEvent 事件基类 2️⃣ 时间与定时\n类名 说明 QTimer 定时器 QTime 时间 QDate 日期 QDateTime 日期时间 3️⃣ 多线程与并发（重点）\n类名 说明 QThread 线程 QRunnable 任务 QThreadPool 线程池 QMutex 互斥锁 QWaitCondition 条件变量 4️⃣ 文件 / 路径 / 设置\n类名 说明 QFile 文件操作 QDir 目录操作 QFileInfo 文件信息 QSettings 配置存储 QStandardPaths 标准路径 5️⃣ 基础数据类型\n类名 说明 QPoint 点 QSize 尺寸 QRect 矩形 QVariant 通用类型 QUrl URL Qt 枚举集合 "},{"id":9,"href":"/Python/Python%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81/PySimpleGUI/","title":"PySimpleGUI","section":"Python应用代码","content":"PySimpleGUI 学习指南\n什么是 PySimpleGUI# PySimpleGUI 是一个封装了 Tkinter（默认）、Qt、WxPython、Remi 的 简易 GUI 框架。 它的目标：用最少的代码，快速写出桌面应用 GUI。 特点：语法直观、学习曲线低，适合初学者和快速原型开发。\nPySimpleGUI 的三大核心# 布局（Layout） 界面由控件（如按钮、文本、输入框）组成，控件排布在一个二维列表中。 每一行是一个列表，整个窗口是一个大的列表。\n窗口（Window） 用 sg.Window 创建窗口。 接收标题、布局等参数。\n事件循环（Event Loop） GUI 需要不断等待用户操作（事件），比如点击按钮、输入文本。 用 window.read() 获取 event 和 values。 在 PySimpleGUI 中，event 的值通常就是你为控件设置的 key。 没有指定 key 参数，那么它的事件标识（event）就是按钮上显示的文字内容。\nPySimpleGUI 常用控件速查表# 一、基础元素# 控件类型 代码示例 说明 文本 sg.Text(\u0026quot;显示文本\u0026quot;, key=\u0026quot;text\u0026quot;) 显示静态文字；不支持 text_container 参数 输入框 sg.Input(key=\u0026quot;input\u0026quot;, size=(20, 1)) 单行文本输入 多行输入 sg.Multiline(size=(40, 5), key=\u0026quot;multiline\u0026quot;, disabled=True) 多行文本，可设为只读 按钮 sg.Button(\u0026quot;确定\u0026quot;, key=\u0026quot;submit\u0026quot;) 点击触发事件 图片 sg.Image(\u0026quot;logo.png\u0026quot;, key=\u0026quot;image\u0026quot;) 支持 PNG/JPG 等格式 二、选择类控件# 控件类型 代码示例 说明 复选框 sg.Checkbox(\u0026quot;同意协议\u0026quot;, key=\u0026quot;chk_agree\u0026quot;) 返回 True/False 单选框 sg.Radio(\u0026quot;男\u0026quot;, \u0026quot;gender\u0026quot;, key=\u0026quot;radio_male\u0026quot;) 同一组名（如 \u0026quot;gender\u0026quot;）互斥 下拉框 sg.Combo([\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot;], key=\u0026quot;combo_selection\u0026quot;) 可编辑或只读（加 readonly=True） 列表框 sg.Listbox(values=[\u0026quot;苹果\u0026quot;, \u0026quot;香蕉\u0026quot;], size=(20, 3), key=\u0026quot;list_items\u0026quot;) 返回选中项列表 滑块 sg.Slider(range=(0, 100), key=\u0026quot;slider_value\u0026quot;, orientation='h') 水平/垂直滑块 三、文件与文件夹# 功能 代码示例 说明 选择文件 sg.FileBrowse(key=\u0026quot;file_browse\u0026quot;) 需配合 Input 使用 保存文件 sg.FileSaveAs(key=\u0026quot;file_saveas\u0026quot;) 弹出“另存为”对话框 选择文件夹 sg.FolderBrowse(key=\u0026quot;folder_browse\u0026quot;) 返回目录路径 输入+选择 [sg.Input(key=\u0026quot;file_path\u0026quot;), sg.FileBrowse(target=\u0026quot;file_path\u0026quot;)] target 指定输入框 key FileBrowse 默认将路径填入前一个 Input，用 target 可指定任意 key。\n四、进度与状态# 控件类型 代码示例 说明 进度条 sg.ProgressBar(100, orientation='h', size=(20, 20), key=\u0026quot;pbar\u0026quot;) 更新：window[\u0026quot;pbar\u0026quot;].update(current_value) 状态栏 sg.Text(\u0026quot;就绪\u0026quot;, text_color=\u0026quot;gray\u0026quot;, key=\u0026quot;status\u0026quot;) PySimpleGUI 无原生 StatusBar，常用 Text 模拟 五、容器布局（核心！）# 容器类型 代码示例 说明 列容器 sg.Column([[sg.Button(\u0026quot;A\u0026quot;)]], scrollable=True, vertical_scroll_only=True) 控制布局的核心：可设固定宽高、滚动、隐藏 框架 sg.Frame(\u0026quot;测试\u0026quot;,[[sg.Button(\u0026quot;a\u0026quot;)]],pad=(10, 10)) 视觉分组，带标题边框；可加 size= 强制尺寸 页签 sg.Tab(\u0026quot;首页\u0026quot;, [[sg.Text(\u0026quot;内容\u0026quot;)]]) 单个标签页 页签组 sg.TabGroup([[tab1, tab2]]) 包含多个 Tab #Column 是实现复杂布局（如可折叠面板、滚动区域）的关键；Frame 只是装饰性分组。 六、菜单与底部信息# 功能 代码示例 说明 顶部菜单 sg.Menu([['文件', ['退出']], ['帮助', ['关于']]]) 菜单项点击后，event 为菜单文字 底部信息（左+右对齐） [sg.Text(\u0026quot;左\u0026quot;), sg.Push(), sg.Text(\u0026quot;右\u0026quot;)] ` Push = 弹簧，撑开左右 水平分隔线 sg.HSeparator() 视觉分割区域 垂直分隔线 sg.VSeperator() 分隔左右区域 七、弹窗（Popup）# 弹窗类型 代码示例 返回值 / 说明 普通提示 sg.popup(\u0026quot;消息\u0026quot;) 返回 \u0026quot;OK\u0026quot;，阻塞程序直到关闭 是/否选择 sg.popup_yes_no(\u0026quot;确定吗?\u0026quot;) 返回 \u0026quot;Yes\u0026quot; 或 \u0026quot;No\u0026quot; 确定/取消 sg.popup_ok_cancel(\u0026quot;继续吗?\u0026quot;) 返回 \u0026quot;OK\u0026quot; 或 \u0026quot;Cancel\u0026quot; 文件选择 sg.popup_get_file(\u0026quot;选择文件\u0026quot;) 返回路径字符串或 None 错误提示 sg.popup_error(\u0026quot;出错了!\u0026quot;) 红色背景，强调错误 可滚动文本 sg.popup_scrolled(\u0026quot;长文本...\u0026quot;) 自动添加滚动条 所有的 sg.popup* 系列函数都不接受 key 参数。不参与事件循环\nresponse = sg.popup_yes_no(\u0026#34;确定要删除吗？\u0026#34;) if response == \u0026#34;Yes\u0026#34;: # 执行删除操作 print(\u0026#34;用户确认删除\u0026#34;) # 例如：删除文件、清空输入框、调用函数等 elif response == \u0026#34;No\u0026#34;: # 用户取消，可选：提示或什么都不做 print(\u0026#34;用户取消操作\u0026#34;) else: # 用户点击了关闭按钮（X） print(\u0026#34;用户关闭了弹窗\u0026#34;)八、窗口创建# 1.创建窗口\nwindow = sg.Window( title=\u0026#34;窗口标题\u0026#34;, layout=your_layout, # 必填：界面布局 resizable=True, # 可选：是否可调整大小 finalize=True, # 可选：立刻把窗口和所有控件真正创建出来（用于初始化后立即操作控件） font=(\u0026#34;微软雅黑\u0026#34;, 10), size=(600, 400), # 初始尺寸 (宽, 高) icon=\u0026#34;\u0026#34; )window 是通过 sg.Window(\u0026hellip;) 创建的窗口实例，是与界面交互的核心对象。几乎所有动态操作都通过它完成。\n2.读取事件与值（主循环）\nevent, values = window.read()•event：触发的事件（如按钮文字、key、sg.WIN_CLOSED） •values：字典，包含所有带 key 的输入控件的当前值 •values[\u0026quot;-INPUT-\u0026quot;] # 获取 Input 内容 •values[\u0026quot;-CHECK-\u0026quot;] # 获取 Checkbox 状态 (True/False) window.read() 是阻塞调用，程序会停在这里等待用户操作。\n3.更新控件内容\nwindow[\u0026#34;key\u0026#34;].update(new_value, **kwargs)适用于： •Text：更新显示文字 •Input / Multiline：设置文本 •Button：改文字、禁用等 •Image：换图 •ProgressBar：更新进度 示例：\nwindow[\u0026#34;-STATUS-\u0026#34;].update(\u0026#34;处理中...\u0026#34;, text_color=\u0026#34;blue\u0026#34;) window[\u0026#34;-PROGRESS-\u0026#34;].update(50) # 进度条到 50% window[\u0026#34;-SUBMIT-\u0026#34;].update(disabled=True) # 禁用按钮4.控制控件可见性\nwindow[\u0026ldquo;key\u0026rdquo;].update(visible=False) # 隐藏 window[\u0026ldquo;key\u0026rdquo;].update(visible=True) # 显示 常用于动态面板切换（配合 Column 或 Frame）。\n5.聚焦与清空\nwindow[\u0026quot;-INPUT-\u0026quot;].set_focus() # 光标聚焦到输入框 window[\u0026quot;-INPUT-\u0026quot;].update(\u0026quot;\u0026quot;) # 清空内容 6.关闭窗口\nwindow.close() •释放资源 •必须在程序结束前调用，否则可能卡住或报错\n九、事件循环模板（必背！）# window = sg.Window(\u0026#34;标题\u0026#34;, layout) while True: event, values = window.read() if event in (sg.WIN_CLOSED, \u0026#34;退出\u0026#34;): # 关闭窗口或点击退出 break elif event == \u0026#34;关于\u0026#34;: sg.popup(\u0026#34;关于信息\u0026#34;) elif event == \u0026#34;执行\u0026#34;: # 处理逻辑 window[\u0026#34;output\u0026#34;].update(\u0026#34;完成！\u0026#34;) window.close()十、全局样式设置（必须在创建窗口前！）# sg.theme(\u0026#34;LightGrey2\u0026#34;) # 设置主题 sg.set_options(font=(\u0026#34;微软雅黑\u0026#34;, 10)) # 设置默认字体 主题决定颜色，字体需单独设置；两者都必须在 Window 之前调用。应用示例# 一个简单的gui# sg.theme(\u0026#34;LightGrey2\u0026#34;) sg.set_options(font=(\u0026#34;Microsoft YaHei\u0026#34;, 30)) menu = [[\u0026#34;帮助\u0026#34;, [\u0026#34;关于\u0026#34;]]] # 左右区域（用 Column 固定宽度） left = sg.Column( [ [ sg.Button(\u0026#34;功能A\u0026#34;), ] ], size=(150, None), ) right = sg.Column( [ [ sg.Input(), sg.Button(\u0026#34;执行\u0026#34;) ] ], size=(300, None), ) # 底部 footer = [ sg.Text(\u0026#34;MyApp v1.0\u0026#34;, text_color=\u0026#34;gray\u0026#34;), sg.Push(), sg.Text(\u0026#34; 2025\u0026#34;, text_color=\u0026#34;gray\u0026#34;), ] # 布局 layout = [[sg.Menu(menu)], [left, sg.VSeperator(), right], [sg.HSeparator()], footer] # 窗口 \u0026amp; 事件循环 window = sg.Window(\u0026#34;示例\u0026#34;, layout) while True: event, values = window.read() if event in (sg.WIN_CLOSED, \u0026#34;退出\u0026#34;): break if event == \u0026#34;功能A\u0026#34;: response = sg.popup_yes_no(\u0026#34;你确定吗\u0026#34;) window.close()引用注册装饰器注册事件# import PySimpleGUI as sg # ============================== # 全局登记本：按钮 → 对应函数 # ============================== event_handlers = {} def register_event(event_name): \u0026#34;\u0026#34;\u0026#34;装饰器：登记事件处理函数\u0026#34;\u0026#34;\u0026#34; def decorator(func): event_handlers[event_name] = func return func return decorator # ============================== # 功能函数：加减乘除 # ============================== @register_event(\u0026#34;加法\u0026#34;) def add(values): try: a, b = float(values[\u0026#34;num1\u0026#34;]), float(values[\u0026#34;num2\u0026#34;]) sg.popup(f\u0026#34;结果: {a} + {b} = {a + b}\u0026#34;) except ValueError: sg.popup_error(\u0026#34;请输入数字！\u0026#34;) @register_event(\u0026#34;减法\u0026#34;) def sub(values): try: a, b = float(values[\u0026#34;num1\u0026#34;]), float(values[\u0026#34;num2\u0026#34;]) sg.popup(f\u0026#34;结果: {a} - {b} = {a - b}\u0026#34;) except ValueError: sg.popup_error(\u0026#34;请输入数字！\u0026#34;) @register_event(\u0026#34;乘法\u0026#34;) def mul(values): try: a, b = float(values[\u0026#34;num1\u0026#34;]), float(values[\u0026#34;num2\u0026#34;]) sg.popup(f\u0026#34;结果: {a} × {b} = {a * b}\u0026#34;) except ValueError: sg.popup_error(\u0026#34;请输入数字！\u0026#34;) @register_event(\u0026#34;除法\u0026#34;) def div(values): try: a, b = float(values[\u0026#34;num1\u0026#34;]), float(values[\u0026#34;num2\u0026#34;]) if b == 0: sg.popup_error(\u0026#34;除数不能为 0！\u0026#34;) else: sg.popup(f\u0026#34;结果: {a} ÷ {b} = {a / b}\u0026#34;) except ValueError: sg.popup_error(\u0026#34;请输入数字！\u0026#34;) # ============================== # GUI 布局 # ============================== layout = [ [sg.Text(\u0026#34;数字1:\u0026#34;), sg.Input(key=\u0026#34;num1\u0026#34;)], [sg.Text(\u0026#34;数字2:\u0026#34;), sg.Input(key=\u0026#34;num2\u0026#34;)], [sg.Button(\u0026#34;加法\u0026#34;), sg.Button(\u0026#34;减法\u0026#34;), sg.Button(\u0026#34;乘法\u0026#34;), sg.Button(\u0026#34;除法\u0026#34;)], [sg.Button(\u0026#34;退出\u0026#34;)] ] window = sg.Window(\u0026#34;装饰器计算器\u0026#34;, layout) # ============================== # 事件循环 # ============================== while True: event, values = window.read() if event in (sg.WIN_CLOSED, \u0026#34;退出\u0026#34;): break handler = event_handlers.get(event) if handler: handler(values) window.close()"},{"id":10,"href":"/Python/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/Pystand/","title":"Pystand打包工具","section":"其它知识","content":"https://zhuanlan.zhihu.com/p/691339803\n一、什么是嵌入式打包？# 嵌入式解释器（Windows embeddable package） 是 Python 官方专门提供给“打包场景”的：\n从 python.org/downloads/windows/ 下载 Windows embeddable package (32/64-bit)。 它是一个绿色版 zip 包，不需要安装，解压后就是一个最小可运行的 Python。 适合用来嵌入到 PyStand / PyInstaller / cx_Freeze 等打包工具里。 适用版本：Python 3.5 及以上（因为嵌入式解释器是 3.5 开始提供的）。 嵌入式解释器和开发环境的版本保持一致 打包原理 你把这个 embeddable 包解压到你的项目目录。 把你写的 Python 脚本（或编译成 .pyc/.pyd/.pyo）放进去。 配置好 pythonXY._pth 文件（类似虚拟环境的 sys.path 设置），让它能找到你项目的依赖。 区别于 PyInstaller、cx_Freeze 等工具 PyInstaller：把代码和解释器打成一个单独 exe。 Embeddable：保留一个完整的独立 Python 环境 + 你的程序，更像是“便携版 Python + 应用”。 如果你下载了 python-3.12.9-embed-amd64.zip，解压后结构大概是：\n|-- python.exe |-- python312.zip ← 标准库，不用解压占用空间小，Python 启动时直接从 zip 里加载模块。 |-- python312._pth ← 配置搜索路径二、打包准备# 准备代码# main.py\nimport sys import numpy as np import pandas as pd from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget, QLabel from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas from matplotlib.figure import Figure class MplCanvas(FigureCanvas): \u0026#34;\u0026#34;\u0026#34;Ultimately, this is a QWidget (as well as a FigureCanvasAgg, etc.).\u0026#34;\u0026#34;\u0026#34; def __init__(self, parent=None, width=5, height=4, dpi=100): fig = Figure(figsize=(width, height), dpi=dpi) self.axes = fig.add_subplot() # 初始化父类 super(MplCanvas, self).__init__(fig) class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() # 创建MplCanvas实例作为窗口中的中央部件 self.canvas = MplCanvas(self, width=5, height=4, dpi=100) # 生成数据并绘制 x_values = np.linspace(0, 2 * np.pi, num=200) y_values = np.sin(x_values) df = pd.DataFrame({\u0026#39;x\u0026#39;: x_values, \u0026#39;sin(x)\u0026#39;: y_values}) self.canvas.axes.plot(x_values, y_values, label=\u0026#39;Sine Function\u0026#39;) # 设置图表标题、坐标轴标签等 self.canvas.axes.set_xlabel(\u0026#39;X axis (x)\u0026#39;) self.canvas.axes.set_ylabel(\u0026#39;Y axis(sin(x))\u0026#39;) self.canvas.axes.set_title(\u0026#39;y = sin(x)\u0026#39;) self.canvas.axes.legend() # 布局管理 layout = QVBoxLayout() layout.addWidget(self.canvas) self.text=QLabel(str(df.info)) layout.addWidget(self.text) container = QWidget() container.setLayout(layout) self.setCentralWidget(container) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) main_win = MainWindow() main_win.show() sys.exit(app.exec_())准备虚拟环境# pycharm创建虚拟环境项目，将代码文件放进去,运行一次\n使用pystand壳打包# 1.下载pystand项目中的pystand程序，这是一个C++编写的壳，用来调用python解释器运行代码。\n你也可以不用这个壳，直接bat命令调用python解释器运行main.py文件，但这样多少显得不太美观。\nhttps://github.com/skywind3000/PyStand/releases\n只需要看这两个就行，一个是py38-x64，一个是py38，分别对应64位解释器和32位解释器，同时也对应了64位的pystand及32位的pystand，请注意这俩一定要对应上。不能用32位的pystand去运行64位的python解释器。\n其他Releases版本内包含的pyqt5,pyside2等，都是32位的 pystand-v1.1.1-exe.zip，这个Releases版本也挺重要的，里面包含了无界面与有界面的pystand壳，适用于不同的应用场合，看你的项目是否需要命令行界面（那个黑框）。\n2.本文以64位为例，下载PyStand-py38-x64.7z。下载到本地后，它应该长这样。 runtime文件夹里面放的是python embeddable解释器，这里面自带的是python3.8.10。 site-packages里面放的是第三方库，空的。 pystand.exe是一个c++写的壳，双击即可运行 pystand.int中保存的是python代码，你可以理解为main.py文件，这个文件中必须是python代码（注意哦，必须是明文代码，原因可以去看pystand源码），用作程序入口。 你可以选择将runtime文件夹里面的内容删掉，自己去官网下载其他版本的python embeddable解释器，我这里以python 3.12为例， python.org/downloads/windows/ 去官网下载，并替换runtime文件夹中的文件。\n3.将你的项目所依赖的虚拟环境下的site-package文件夹下所有内容copy到pystand的site-package文件夹下，请注意，如果你的项目所依赖的虚拟环境并不是特别的干净，比如还有项目根本没用到的scipy库等，我建议你重新新建虚拟环境，安装好依赖后拷贝。（其实拷贝系统环境也行，就是一般没那么干净。有很多冗余的库）\n（这步操作一般没啥问题，但是有些第三方库不讲武德，比如最新版torch库，它把二进制依赖dll文件扔到sitepackage外面，只复制sitepackage里面的内容，会报错dll load failed，这种时候有其他的处理办法）\n到这儿，打包程序的环境配置完毕。\n4，在pystand目录下，新建script目录，将程序代码拷贝到里面去。并对代码入口做简要修改，注释掉 if name == \u0026lsquo;main\u0026rsquo;:，新建入口函数，名称随意，这里以start为例。\ndef start(): app = QApplication(sys.argv) main_win = MainWindow() main_win.show() sys.exit(app.exec_()) # if __name__ == \u0026#39;__main__\u0026#39;: # app = QApplication(sys.argv) # main_win = MainWindow() # main_win.show() # sys.exit(app.exec_())5，修改pystand.int中的代码，以文本编辑器打开该文件，直接清空内容，输入以下代码。这样就表示，从start函数启动程序。\nfrom main import start if __name__ == \u0026#34;__main__\u0026#34;: #运行入口函数 start()但是第4步我们将main.py文件扔到了scripts文件夹下，程序是不知道main.py文件在哪儿的，所以会报错： from main import start ModuleNotFoundError: no module named \u0026ldquo;main\u0026rdquo; 去改runtime文件夹里面的._pth文件，加一行../scripts就ok了\npython312.zip\r.\r../scripts\r# Uncomment to run site.main() automatically\rimport site6，双击pystand.exe，运行程序，可得到如期结果。到这儿，打包算初步完成。\n如果不能如期运行，可以使用cmd命令运行pystand.exe，可以查看到报错信息。\n如果需要自定义程序名字，需要同时修改pystand.exe及http://pystand.int两个文件，保持同名即可。\n如果觉得保持同名很麻烦，想允许用户自己随便改名，那么请将http://pystand.int改名为http://pystand_static.int即可。\n如果觉得int文件有点碍眼，那就得修改pystand源码了，稍微改一下就可以让pystand去runtime里面找int文件，就可以藏起来了。（但是不推荐改，最好用韦神提供的exe，他拿去报白名单了，报毒概率低哦）\n如果需要自定义程序图标，请使用Resource Hacker 更换图标，非常简单。\n程序源代码是以源码形式放在script目录中的，建议使用nuitka批量将py文件转为pyd文件，提升运行速度的同时隐藏了源码。\n三、体积优化# 优化第一步# 删除不需要的固有第三方库，请删除sitepackage文件夹下的pip，pip-info，wheel，wheel-info，setuptools，setuptools-info，合计6个文件夹，这大概是15M。请删除runtime文件夹下的get-pip.py文件，这个是python官方提供拿来安装pip的，不需要。\n优化第二步# 使用神秘脚本删除程序运行不需要的第三方库文件。\n请到下面的链接获取，如果觉得好用，请大力宣传哦！\n打包瘦身脚本：https://github.com/mengdeer589/PythonSizeCruncher\n请仔细阅读该脚本使用说明，本文仅展示瘦身效果。\n注意注意：请对sitepackage文件夹使用哦，本脚本对runtime文件夹内的文件没有识别能力。\n四、加密源码# 按照本文所推荐的打包方式，源码其实是放在script文件夹中，以python源码的形式存放的。现在我们来简单加密一下，不让别人随随便看见。\n请安装nuitka，然后对你的代码文件夹，使用\u0026ndash;module命令，将源码编译为pyd文件。上面已经提到了详细命令。\n而pyd文件比pyc文件安全的多，它类似于dll文件，一般人很难破解，想逆向还原源码，那更是不可能。\n但是pyd文件作为一个依赖模块，是可以直接通过dir函数查看其暴露的接口的，所以请将重要变量匿名化（不能被import，dir出来）\n五、常见问题# 打包tkinter模块# 官方提供的嵌入式解释器并不包含pip工具，以及tkinter模块，下面的步骤是怎么补上这个tkinter模块。\n注：本方法目的在于后续可以复用，所以并不按照官方的目录结构来。\n①复制tkinter模块。从已经安装了tkinter模块的相同python解释器环境中复制，该模块通常位于解释器的Lib文件夹下，将tkinter文件夹复制到pystand/runtime/Lib文件夹下，注意，这里需要新建一个Lib文件夹。\n②复制tcl文件夹里面所有的文件，到pystand/runtime/Lib文件夹下，tcl文件夹通常位于解释器的同级目录。\n③复制二进制模块。复制_tkinter.pyd，tcl86t.dll，tk86t.dll三个文件到pystand/runtime/Lib文件夹下，这三个文件通常位于解释器的DLLs文件夹下。\n④修改路径。修改runtime文件夹里面的python310._pth文件，增加一行./Lib。注意，这里有个点，代表同级目录的Lib文件夹。\ntips:20240907更新，若打包python版本为3.12，tkinter打包时，需复制系统python3.12解释器dlls文件夹下的zlib1.dll到pystand/runtime/Lib文件夹下。\n现在可以运行程序了。如果后续还需要打包tkinter模块。直接复制这里弄好的Lib文件夹跟._pth文件到runtime文件夹下即可实现复用。\n"},{"id":11,"href":"/Python/Python%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81/watchdog/","title":"WatchDog","section":"Python应用代码","content":"watchdog 是 Python 中非常常用的一个文件系统监控库，可以实时监听文件/目录的变化（增删改、移动等），经常用在日志监控、自动化构建、配置热更新、爬虫等场景。\n安装# pip install watchdog基本使用示例# import time from watchdog.observers import Observer from watchdog.events import FileSystemEventHandler # 自定义事件处理器，继承 FileSystemEventHandler # 你可以重写里面的 on_created、on_deleted、on_modified、on_moved 等方法 class MyHandler(FileSystemEventHandler): def on_created(self, event): # 当有新文件/目录被创建时触发 print(f\u0026#34;新建: {event.src_path}\u0026#34;) def on_deleted(self, event): # 当有文件/目录被删除时触发 print(f\u0026#34;删除: {event.src_path}\u0026#34;) def on_modified(self, event): # 当有文件/目录内容被修改时触发 print(f\u0026#34;修改: {event.src_path}\u0026#34;) def on_moved(self, event): # 当有文件/目录被移动或重命名时触发 print(f\u0026#34;移动: 从 {event.src_path} 到 {event.dest_path}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: # 要监听的目录，这里用 \u0026#34;.\u0026#34; 表示当前目录 path = \u0026#34;.\u0026#34; # 创建一个事件处理器对象（即上面定义的 MyHandler） event_handler = MyHandler() # 创建一个“观察者对象”，用于监控文件系统事件 observer = Observer() # 把事件处理器和要监听的目录绑定起来 # recursive=True 表示递归监听子目录 observer.schedule(event_handler, path, recursive=True) # 启动观察者（会在后台线程里跑） observer.start() try: # 主线程保持运行，不然程序会退出 while True: time.sleep(1) # 每秒休眠一次，降低 CPU 占用 except KeyboardInterrupt: # 捕获 Ctrl+C，停止观察者 observer.stop() # 等待观察者线程退出，确保资源释放干净 observer.join()在 watchdog 里主要有两个角色：\nHandler（处理器） 就是你写的 MyHandler 类，里面定义了 “文件发生变化时要做什么”。 例如：文件创建时发通知、文件修改时自动运行脚本等等。 Observer（观察者） 真正的“监控器”，底层调用系统的文件监控 API（比如 Windows 的 ReadDirectoryChangesW、Linux 的 inotify）。 它会不断监听指定目录，一旦发现变化，就把事件交给 Handler 处理。 "},{"id":12,"href":"/Game/Yolo/yolo%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","title":"YOLO环境安装","section":"Yolo","content":"https://docs.ultralytics.com/zh/quickstart/ https://blog.csdn.net/Scoful/article/details/131209347\nYOLO发展历史# 1.起源与核心思想的开放性 (Open Source) 开创者：YOLO最初确实是由Joseph Redmon等人作为学术研究项目创建的，并发表了论文。 开源：他们秉承开源精神，将代码公开。这一举动瞬间吸引了全世界的研究者和开发者。这意味着，任何人都可以获取、使用、修改和分发这些代码。\n2.创始人的“退出”与社区的“接管” 这是一个非常关键的转折点。 伦理担忧：在YOLOv3之后，创始人Joseph Redmon因担心其技术被用于军事、监控等恶性用途，产生了严重的伦理担忧，并宣布停止继续参与YOLO相关的研究。 权力真空与机遇：核心创始人的离开，并没有让市场和研究对高效目标检测的需求消失。这直接催生了两个结果：\n官方分支的延续：YOLOv4由原YOLOv3社区的活跃维护者（Alexey Bochkovskiy等）接手开发，延续了“官方”血脉。 新玩家的涌入：巨大的需求和开源代码的可得性，使得其他有实力的团队可以基于YOLO的核心思想，开发自己的版本。 3.不同的团队，不同的目标和优势 各个团队基于自身的技术栈和商业目标，对YOLO进行了不同的优化：\n团队 / 维护者 背景与目标 主要YOLO版本 版本特点与优势 Ultralytics 一家专注于AI工具的软件公司 YOLOv5, v8, v10, v11 工程化极致：基于PyTorch，易用性无敌，文档完善，生态强大，非常适合工业界和初学者。 美团 中国领先的生活服务电子商务平台 YOLOv6 工业应用驱动：针对自身业务中的硬件进行极致优化，追求在特定芯片上的最快速度。 Academic Researchers 大学和研究机构的人员 YOLOv7, YOLOv9 学术创新：关注于发表顶会论文，提出新的网络结构、训练方法等前沿思想。 Deci.ai 一家专注于AI模型效率的公司 YOLO-NAS 工具驱动：使用神经架构搜索工具，自动搜索出在精度和速度上最优的模型结构。 环境准备# 安装Miniconda和PyCharm# 用于管理 Python 虚拟环境和依赖库，下载地址：Anaconda 官网\n更新最新的显卡驱动# 打开NVIDA更新驱动的官网地址\n根据下图的选择，记得Windows驱动程序类型要选标准，如图\n点击搜索，下面就会列出一大堆的历史驱动，选择第一个，也就是最新的，当前是472.12，点开再点下载，再点同意并下载 下载完毕后，双击安装，会提示选择一个解压缩的目录，建议选一个空闲空间大一点的盘来存放，这个安装完毕后会自动删除的 等解压缩完毕后，会自动检查系统是否可以安装这个驱动，等检查完毕后，选择NVIDA图形驱动程序，上面的NVIDIA显卡驱动和GeForce Experience，会多安装GeForce Experience，给可怜的C盘更多的负担，不建议选择 同意并继续后，选择精简，下一步 等待安装完成，关闭就行了，建议重启电脑一下 右键点击桌面空白处，选择NVIDIA 控制面板，打开后，点击左下角的系统信息，查看驱动程序版本是否是安装的472.12 安装CUDA# 打开cmd，输入命令：nvidia-smi，会列出当前的驱动版本和支持的CUDA的最高版本，如果提示命令不存在，建议用软件everything，搜索nvidia-smi.exe，然后自行把目录添加到环境变量里，或者直接进入nvidia-smi.exe的目录里再运行命令\n检查显卡驱动兼容性：命令行输入 nvidia-smi，确认 CUDA 版本\nnvidia-smi #查看驱动版本，最高支持13.0，可以向下兼容 +-----------------------------------------------------------------------------------------+ | NVIDIA-SMI 581.57 Driver Version: 581.57 CUDA Version: 13.0 | +-----------------------------------------+------------------------+----------------------+ 右上角显示的13.0就是当前电脑能够支持CUDA的最高版本，可以向下兼容，去CUDA的官方地址下载，选择低于可支持版本的，比如我选择了CUDA Toolkit 11.8.0 下载完毕后，双击安装，会提示选择一个解压缩的目录，建议选一个空闲空间大一点的盘来存放，这个安装完毕后会自动删除的 等解压缩完毕后，会自动检查系统是否可以安装这个驱动，等检查完毕后，同意并继续 选自定义，下一步 点开CUDA，找到Visual Studio Integration，取消勾选，如图所示 跟CUDA同级别的也都取消勾选，如图所示，下一步\n等待安装完成，下一步，关闭就行了，建议重启电脑一下 打开cmd，输入命令：nvcc -V ，能正常输出版本信息等，就说明安装成功了 (可选)，做一下GPU带宽测试，用软件everything，搜bandwidthTest.exe，找到文件所在地址，然后打开cmd，输入命令：bandwidthTest.exe，看到结果有输出pass，说明测试成功 (可选)，获取CUDA可使用的GPU的信息，用软件everything，搜deviceQuery.exe，找到文件所在地址，然后打开cmd，输入命令：deviceQuery.exe，看到结果有输出pass，说明测试成功，根据结果也可知，集显是不能被CUDA操控的。 安装cuDNN# 先注册一个NVIDIA的开发者账号，打开地址，根据提示验证并注册\n打开cuDNN的官方下载地址，需要根据已经安装的CUDA的版本选择 cuda11 点开后，找到Windows的，点开，下载\ncuDNN其实称不上安装，只需要将下载下来的压缩包解压后，将对应文件夹的文件放到CUDA安装路径下的对应文件夹里即可(cuDNN可以认为是CUDA的补充，可以加速深层神经网络的速度) 复制上图的三个文件夹里面文件，然后找到CUDA的安装文件夹，也是一样有bin、include、lib，分别复制到里面即可，如果找不到，用软件everything，搜CUDA_Toolkit_Release_Notes.txt或者nvcc.exe，\n安装pytorch# https://pytorch.org/get-started/previous-versions/\n#创建名字yolov10环境，指定python版本3.9 conda create -n yolov10 python=3.9 -y #激活yolov10环境 conda activate yolov10 #安装PyTorch pip install torch==2.0.1 torchvision==0.15.2 --index-url https://download.pytorch.org/whl/cu118 #如果没有显卡，可以安装CPU版本 pip install torch torchvision torchaudio 同一个 PyTorch 版本有两种安装方式 pip：一般pip安装会比conda安装较高效 conda：需要安装Anaconda 或 Miniconda\n安装yolo# 获取YOLOv10源码\n1.三种安装方式 1）直接使用源码(不推荐，无法使用命令行工具) https://github.com/ultralytics/ultralytics 2）pip直接安装(官方推荐) pip install ultralytics 3）pip源码安装(个人推荐) 我是采用此方法\n#激活yolov10环境 conda activate yolov10 #进入项目目录 cd D:\\PyProject\\yolov10-main #!!!打开requirements.txt，把torch和torchvision注释掉,防止安装的不匹配.#如果不小心安装了torch,先卸载所有torch相关包，再重新安装 pip uninstally torch torchvision torchaudio torchtext #安装依赖 pip install -r requirements.txt #安装项目 -e参数必须要有，否则后续修改代码无效 pip install -e . #可以看到已经安装了ultralytics ，并且源码在D:\\PyProject\\ultralytics-8.2.0目录下 pip list ultralytics 8.1.34 D:\\PyProject\\yolov10-main #源码方式安装 #验证安装 python -c \u0026#34;from ultralytics import YOLOv10;print(\u0026#39;成功导入YOLOv10!\u0026#39;)\u0026#34; #验证cuda import torch print(f\u0026#34;CUDA available:{torch.cuda.is available()}\u0026#34;)#状态正常返回True (D:\\conda_envs\\yolov10) C:\\Users\\wchuang\u0026gt; python Python 3.9.25 (main, Nov 3 2025, 22:44:01) [MSC v.1929 64 bit (AMD64)] on win32 Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import torch \u0026gt;\u0026gt;\u0026gt; print(torch.__version__) 2.0.1+cu118 \u0026gt;\u0026gt;\u0026gt; torch.cuda.is_available() True \u0026gt;\u0026gt;\u0026gt; torch.version.cuda \u0026#39;11.8\u0026#39; #验证CuDNN \u0026gt;\u0026gt;\u0026gt; torch.backends.cudnn.version() 8700 #输出cudnn版本号 \u0026gt;\u0026gt;\u0026gt; torch.backends.cudnn.enabled True #是否启用 //常见问题 NVIDIA-SMI有显示但torch.cuda.is_available()返回 False: //重新安装 PyTorch 匹配 CUDA 版本 pip uninstall torch torchvision (D:\\conda_envs\\yolov10) D:\\PyProject\\yolov10-main\u0026gt;yolo predict model=yolov10n.pt source=ultralytics/assets/bus.jpg Ultralytics YOLOv8.1.34 🚀 Python-3.9.25 torch-2.0.1+cu118 CUDA:0 (NVIDIA GeForce MX250, 2048MiB) YOLOv10n summary (fused): 285 layers, 2762608 parameters, 63840 gradients, 8.6 GFLOPs image 1/1 D:\\PyProject\\yolov10-main\\ultralytics\\assets\\bus.jpg: 640x480 4 0s, 1 5, 55.8ms Speed: 5.3ms preprocess, 55.8ms inference, 5.0ms postprocess per image at shape (1, 3, 640, 480) Results saved to runs\\detect\\predict #预测结果输出在 runs/detect/predict 文件夹 💡 Learn more at https://docs.ultralytics.com/modes/predictpycharm# pycharm打开项目D:\\PyProject\\yolov10-main\nfrom ultralytics import YOLOv10 yolo = YOLO(\u0026#34;yolov10n.pt\u0026#34;) # result = yolo(source=\u0026#34;./test.mp4\u0026#34;) #逐帧视频检测 # result = yolo(source=\u0026#34;screen\u0026#34;) #屏幕检测 # result = yolo(source=\u0026#34;0\u0026#34;) #摄像头检测 result = yolo(source=\u0026#34;./ultralytics/assets/bus.jpg\u0026#34;,save=True,conf=0.3) #图片检测 print(result) sava参数：保存结果到runs目录下 conf参数：置信度阈值 取值范围： 0.0 ~ 1.0 conf 含义 结果 0.05 “模型只要稍微觉得像，我就信” 检测多，误检也多 0.25 “模型要比较确定我才信” 默认设置，平衡准确率 0.5 “模型要很确定我才信” 检测少，误检少 1.0 “模型必须百分百确定我才信” 几乎检测不到任何目标 "},{"id":13,"href":"/Python/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"基础知识","section":"Python基础知识","content":"代码首行# Python代码首行一般用下面的,两句分别是用于Linux系统下指定解释器的，第二句是声明代码使用的编码规则的，虽然在Windows系统下作用不大，但是仪式感还是要的\n#!/usr/bin/env python3 # -*- coding: utf-8 -*-代码注释# 用#字符开头的是单行注释 \u0026quot;\u0026quot;\u0026quot; 多行字符串用三个引号\u0026quot;\u0026quot;\u0026quot;\n保留字# 我们知道公司起名字不是随便取得，肯定会有些名字是不能用的，在Python中也是，有些名字是不可以用的，这些名字叫保留字，以下是全部保留字\n[\u0026#39;False\u0026#39;, \u0026#39;None\u0026#39;, \u0026#39;True\u0026#39;, \u0026#39;and\u0026#39;, \u0026#39;as\u0026#39;, \u0026#39;assert\u0026#39;, \u0026#39;break\u0026#39;, \u0026#39;class\u0026#39;, \u0026#39;continue\u0026#39;, \u0026#39;def\u0026#39;, \u0026#39;del\u0026#39;, \u0026#39;elif\u0026#39;, \u0026#39;else\u0026#39;, \u0026#39;except\u0026#39;, \u0026#39;finally\u0026#39;, \u0026#39;for\u0026#39;, \u0026#39;from\u0026#39;, \u0026#39;global\u0026#39;, \u0026#39;if\u0026#39;, \u0026#39;import\u0026#39;, \u0026#39;in\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;lambda\u0026#39;, \u0026#39;nonlocal\u0026#39;, \u0026#39;not\u0026#39;, \u0026#39;or\u0026#39;, \u0026#39;pass\u0026#39;, \u0026#39;raise\u0026#39;, \u0026#39;return\u0026#39;, \u0026#39;try\u0026#39;, \u0026#39;while\u0026#39;, \u0026#39;with\u0026#39;, \u0026#39;yield\u0026#39;]代码缩进# Python是强制缩进的语言，如果缩进不当，程序会直接无法运行，Python可以使用4个空格作为一个缩进，或者1个TAB作为一个缩进，但是一个代码中不能混用TAB缩进和空格缩进，否则会造成程式报错\n数据类型# Number（数字）# 数字包含整数int，浮点数float以及复数complex\n123 2.36 4 + 3jString（字符串）# \u0026#39;我是字符串\u0026#39; \u0026#34;我是字符串\u0026#34;bool（布尔类型，注意首字母是大写）# True FalseList（列表）# [1, 2, 3] [1, \u0026#39;321\u0026#39;, True]Tuple（元组）# (\u0026#39;Go\u0026#39;, \u0026#39;Run\u0026#39;, 19, 20) 不写括号其实也可以，但是建议是写括号 \u0026#39;Go\u0026#39;, \u0026#39;Run\u0026#39;, 19, 20 (20,) # 当只有一个元素，需要在元素后添加逗号Set（集合）# 创建一个空集合必须用 set( ) {1, 2, 3, 4}Dictionary（字典）# {\u0026#39;name\u0026#39;: \u0026#39;jake\u0026#39;, \u0026#39;age\u0026#39;: \u0026#39;12\u0026#39;}判断数据类型# 使用type()可查看数据类型\ntype(233) # int type(\u0026#39;233\u0026#39;) # str但是比较严谨的判断方法建议使用isinstance()\na = 3 isinstance(a, int) # True简单数学计算# #算术没有什么出乎意料的 1 + 1 # =\u0026gt; 2 8 - 1 # =\u0026gt; 7 10 * 2 # =\u0026gt; 20 # 但是除法例外，会自动转换成浮点数 35 / 5 # =\u0026gt; 7.0 10.0 / 3 # =\u0026gt; 3.3333333333333335 # 整数除法的结果都是向下取整 5 // 3 # =\u0026gt; 1 5.0 // 3.0 # =\u0026gt; 1.0 # 浮点数也可以 -5 // 3 # =\u0026gt; -2 -5.0 // 3.0 # =\u0026gt; -2.0 # 浮点数的运算结果也是浮点数 3 * 2.0 # =\u0026gt; 6.0 # 模除 7 % 3 # =\u0026gt; 1 # i % j 结果的正负符号会和 j 相同，而不是和 i 相同 -7 % 3 # =\u0026gt; 2 # x 的 y 次方 2 ** 4 # =\u0026gt; 16 # 用括号决定优先级 1 + 3 * 2 # =\u0026gt; 7 (1 + 3) * 2 # =\u0026gt; 8判断语法# 最基础的判断语法 if 判断条件: 条件成功则执行的代码 举例说明 if 2 \u0026gt; 1: print(\u0026#39;2大于1\u0026#39;) 判断语法本质是对布尔值的判断 # 布尔值 (注意: 首字母大写) True # =\u0026gt; True False # =\u0026gt; False # 用 not 取非 not True # =\u0026gt; False not False # =\u0026gt; True # 逻辑运算符，注意 and 和 or 都是小写 True and False # =\u0026gt; False False or True # =\u0026gt; True # True 和 False 实质上就是数字 1 和0 True + True # =\u0026gt; 2 True * 8 # =\u0026gt; 8 False - 5 # =\u0026gt; -5 # 数值与 True 和 False 之间的比较运算 0 == False # =\u0026gt; True 2 == True # =\u0026gt; False 1 == True # =\u0026gt; True -5 != False # =\u0026gt; True # 使用布尔逻辑运算符对数字类型的值进行运算时，会把数值强制转换为布尔值进行运算 # 但计算结果会返回它们的强制转换前的值 # 注意不要把 bool(ints) 与位运算的 \u0026#34;按位与\u0026#34;、\u0026#34;按位或\u0026#34; (\u0026amp;, |) 混淆 bool(0) # =\u0026gt; False bool(4) # =\u0026gt; True bool(-6) # =\u0026gt; True 0 and 2 # =\u0026gt; 0 -5 or 0 # =\u0026gt; -5 # 用==判断相等 True 2 == 1 # =\u0026gt; False # 用!=判断不等 False 2 != 1 # =\u0026gt; True # 比较大小 1 \u0026lt; 10 # =\u0026gt; True 1 \u0026gt; 10 # =\u0026gt; False 2 \u0026lt;= 2 # =\u0026gt; True 2 \u0026gt;= 2 # =\u0026gt; True # 判断一个值是否在范围里 1 \u0026lt; 2 and 2 \u0026lt; 3 # =\u0026gt; True 2 \u0026lt; 3 and 3 \u0026lt; 2 # =\u0026gt; False # 大小比较可以连起来！ 1 \u0026lt; 2 \u0026lt; 3 # =\u0026gt; True 2 \u0026lt; 3 \u0026lt; 2 # =\u0026gt; False # (is 对比 ==) is 判断两个变量是否引用同一个对象,是内存级别的比较 # 而 == 判断两个对象是否含有相同的值 a = [1, 2, 3, 4] # 变量 a 是一个新的列表, [1, 2, 3, 4] b = a # 变量 b 赋值了变量 a 的值 b is a # =\u0026gt; True, a 和 b 引用的是同一个对象 b == a # =\u0026gt; True, a 和 b 的对象的值相同 b = [1, 2, 3, 4] # 变量 b 赋值了一个新的列表, [1, 2, 3, 4] b is a # =\u0026gt; False, a 和 b 引用的不是同一个对象 b == a # =\u0026gt; True, a 和 b 的对象的值相同 # None是一个对象 None # =\u0026gt; None # 当与 None 进行比较时不要用 ==，要用 is。is 是用来比较两个变量是否指向同一个对象。 \u0026#34;etc\u0026#34; is None # =\u0026gt; False None is None # =\u0026gt; True # is和in的反义 1 is not None not in导入包/模块# 关于包/模块\n在Python中，包是一个已经写好的软件，可以通俗的理解为Python语言的一个插件，利用各种包可以节省很多时间，提高开发效率，Python自带呢很多的标准库还有海量的第三方包，后续的很多基本都是要学习各种第三方包\n导入包就是一个拆箱子取东西的过程\n#从functools 包里单独导入wraps函数 from functools import wraps #导入的包也可以重命名，主要是节省打字内容 import math as m # 下面是偷懒的做法，一次性导入包里面全部函数，等于是把箱子里东西全部扔出来的，一般不建议这样 from math import * # 也可以从包里面一次性导入多个函数 from math import ceil, floor # 也可以就这样默认的导入一个包 import math # 这个是从当前目录导入一个库 from . import mymodul 导入包一般有个约定俗成的顺序，先导入标准包，然后导入第三方包，最后导入自己开发的本地包字符串处理# # 创建字符串可以使用单引号（\u0026#39;）或者双引号（\u0026#34;） \u0026#34;这是个字符串\u0026#34; \u0026#39;这也是个字符串\u0026#39; # 字符串可以使用加号连接成新的字符串 \u0026#34;Hello \u0026#34; + \u0026#34;world!\u0026#34; # =\u0026gt; \u0026#34;Hello world!\u0026#34; # 非变量形式的字符串甚至可以在没有加号的情况下连接 \u0026#34;Hello \u0026#34; \u0026#34;world!\u0026#34; # =\u0026gt; \u0026#34;Hello world!\u0026#34; # 字符串可以被当作字符列表 \u0026#34;Hello world!\u0026#34;[0] # =\u0026gt; \u0026#39;H\u0026#39; # 你可以获得字符串的长度 len(\u0026#34;This is a string\u0026#34;) # =\u0026gt; 16 # 你可以使用 f-strings 格式化字符串（python3.6+） name = \u0026#34;Reiko\u0026#34; f\u0026#34;She said her name is {name}.\u0026#34; # =\u0026gt; \u0026#34;She said her name is Reiko\u0026#34; # 你可以在大括号内几乎加入任何 python 表达式，表达式的结果会以字符串的形式返回 f\u0026#34;{name} is {len(name)} characters long.\u0026#34; # =\u0026gt; \u0026#34;Reiko is 5 characters long.\u0026#34; # 用 .format 来格式化字符串，但是优先使用f-string \u0026#39;strings can be interpolated\u0026#39; # 可以重复参数以节省时间 \u0026#34;{0} be nimble, {0} be quick, {0} jump over the {1}\u0026#34;.format( \u0026#34;Jack\u0026#34;, \u0026#34;candle stick\u0026#34;) # =\u0026gt; \u0026#34;Jack be nimble, Jack be quick, Jack jump over the candle stick\u0026#34; # 如果不想数参数，可以用关键字 \u0026#34;{name} wants to eat {food}\u0026#34;.format(name=\u0026#34;Bob\u0026#34;, food=\u0026#34;lasagna\u0026#34;) # =\u0026gt; \u0026#34;Bob wants to eat lasagna\u0026#34; # 转为字符串 str(\u0026#39;2\u0026#39;) # 字符串去除空格 str.strip() # 字符串转大写 str.upper() # 字符串转小写 str.lower() # 判断某个字符是否包含另外一个字母 \u0026#39;Py\u0026#39; in \u0026#39;Python\u0026#39; # =\u0026gt; True # 生成随机字符串 import random import string salt = \u0026#39;\u0026#39;.join(random.sample(string.ascii_letters + string.digits, 16)) # 获取字符开头和结尾 str.startswith(\u0026#39;start\u0026#39;) str.endswith(\u0026#39;end\u0026#39;) # 把字符分割为列表 str.split(\u0026#39;,\u0026#39;) # 列表按照分隔符组合成字符 \u0026#39;,\u0026#39;.join(list)列表List处理# Python中的列表List类似于其他语言中的数组，另外列表是可以修改的\n注意 列表里面的绝大多数操作也都适用于元组，集合和字典等数据类型\n# 直接使用[]可以新建一个空的列表 li = [] # 也可以使用list(),但是优先使用[]，这个主要是格式化 li = list() # 创建列表时也可以同时赋给元素 li = [1, 2, 3, 4, 5, 6] ## 增加数据 # 用append在列表最后追加元素，增加的内容可以是字符，数字，等等 li.append(7) # li现在是[1,2,3,4, 5, 6,7] # 在指定索引处插入一个新的元素，这句就是在第4个位置插入2 li.insert(3, 2) # 注意：li 和 other_li 的值都不变，是被拼接到一起的 li = li + other_li # 上面这个也可以简写为 li += other_li # 也可以用 \u0026#34;extend()\u0026#34; 拼接列表 li.extend(other_li) ## 查看数据 # 查看列表数量 len(li) # 列表存取跟数组一样 li[0] # =\u0026gt; 1 # 取出最后一个元素 li[-1] # =\u0026gt; 3 # 越界存取会造成 IndexError li[4] # 抛出 IndexError ## 列表也支持切片语法 # 取前面第2个到第3个 li[1:3] # 前2个去掉不要，其他都要 li[2:] # 取前3个 li[:3] # 取后3个 li[-3:] # 后3个去掉不要，其他都要 li[:-3] # 隔一个取一个，也就是每2个取1个 li[::2] # 颠倒列表排序 li[::-1] # =\u0026gt; [3, 4, 2, 1] # 也可以用这个 li.reverse() # 统计列表中同样值的个数，和len(0)不一样的 li.count(1) # 可以用三个参数的任何组合来构建切割 # li[始:终:步伐] # 获得列表第一个匹配的值的索引,也就是根据值查序号 li.index(2) # =\u0026gt; 1 li.index(4) # 值不存在会抛出一个 ValueError: 4 is not in the list # 用 \u0026#34;in\u0026#34; 测试列表是否包含值 1 in li # =\u0026gt; True ## 值的修改 li[1] = \u0026#39;新的值\u0026#39; # 用pop默认删除最后一个 li.pop() # =\u0026gt; 3 且li现在是[1, 2, 4] # 用pop也可以删除指定序号的 li.pop(0) # 删除第一个，返回被删除的那个， # 删除第一个匹配的元素 li.remove(2) # li 现在为 [1, 3] li.remove(2) # 抛出错误 ValueError: 2 is not in the list # 注意remove和pop的区别，pop是根据序号删除，remove是根据值找序号，再根据序号删除 # 可清空整个列表 li.clear()元组# 元组是非常类似于列表的一种数据类型，很多方法和列表一样，最大的区别就是元组是只读的，所以在某些时候，元组可以认为是安全的\n# 元组类似列表，但是不允许修改 tup = (1, 2, 3) tup[0] # =\u0026gt; 1 tup[0] = 3 # 抛出 TypeError,因为元组是不可以修改的 # 如果元素数量为 1 的元组必须在元素之后加一个逗号 tup = (1,) # 其他元素数量的元组，包括空元组，都不需要 type((1)) # =\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; type((1,)) # =\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; type(()) # =\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; # 列表允许的操作元组大多都可以 len(tup) # =\u0026gt; 3 tup + (4, 5, 6) # =\u0026gt; (1, 2, 3, 4, 5, 6) tup[:2] # =\u0026gt; (1, 2) 2 in tup # =\u0026gt; True # 可以把元组合列表解包，赋值给变量 a, b, c = (1, 2, 3) # 现在 a 是 1，b 是 2，c 是 3 # 也可以做扩展解包 a, *b, c = (1, 2, 3, 4) # 现在 a 是 1, b 是 [2, 3]， c 是 4 # 元组周围的括号是可以省略的 d, e, f = 4, 5, 6 # 元组 4, 5, 6 通过解包被赋值给变量 d, e, f # 交换两个变量的值就这么简单 e, d = d, e # 现在 d 是 5，e 是 4字典# # 字典用来存储 key 到 value 的映射关系 empty_dict = {} # 初始化的字典 filled_dict = {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3} # 字典的 key 必须为不可变类型。 这是为了确保 key 被转换为唯一的哈希值以用于快速查询 # 不可变类型包括整数、浮点、字符串、元组 invalid_dict = {[1, 2, 3]: \u0026#34;123\u0026#34;} # =\u0026gt; 抛出 TypeError: unhashable type: \u0026#39;list\u0026#39; valid_dict = {(1, 2, 3): [1, 2, 3]} # 然而 value 可以是任何类型 # 用[]取值 filled_dict[\u0026#34;one\u0026#34;] # =\u0026gt; 1 # 用items可以返回键值关系对 list(filled_dict.items()) # 用 keys 获得所有的键。 # 因为 keys 返回一个可迭代对象，所以我们需要把它包在 \u0026#34;list()\u0026#34; 里才能转换为列表。 # 我们下面会详细介绍可迭代。 # 注意: 对于版本 \u0026lt; 3.7 的 python, 字典的 key 的排序是无序的。你的运行结果 # 可能与下面的例子不符，但是在 3.7 版本，字典中的项会按照他们被插入到字典的顺序进行排序 list(filled_dict.keys()) # =\u0026gt; [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;] Python 版本 3.7+ # 用 \u0026#34;values()\u0026#34; 获得所有的值。跟 keys 一样也是可迭代对象，要使用 \u0026#34;list()\u0026#34; 才能转换为列表。 # 注意: 排序顺序和 keys 的情况相同。 list(filled_dict.values()) # =\u0026gt; [1, 2, 3] Python 版本 3.7+ # 用in测试一个字典是否包含一个键 \u0026#34;one\u0026#34; in filled_dict # =\u0026gt; True 1 in filled_dict # =\u0026gt; False # 访问不存在的键会导致 KeyError filled_dict[\u0026#34;four\u0026#34;] # KeyError # 用 \u0026#34;get()\u0026#34; 来避免KeyError,所以最好是用get()来获取数据 filled_dict.get(\u0026#34;one\u0026#34;) # =\u0026gt; 1 # 当键不存在的时候 \u0026#34;get()\u0026#34; 方法可以返回默认值 filled_dict.get(\u0026#34;one\u0026#34;, 4) # =\u0026gt; 1 # \u0026#34;setdefault()\u0026#34; 方法只有当键不存在的时候插入新值 filled_dict.setdefault(\u0026#34;five\u0026#34;, 5) # filled_dict[\u0026#34;five\u0026#34;] 设为5 # 字典赋值 # =\u0026gt; {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3, \u0026#34;four\u0026#34;: 4} filled_dict[\u0026#34;four\u0026#34;] = 5 # 另一种赋值方法 # 用 del 删除项 del filled_dict[\u0026#34;one\u0026#34;] # 从 filled_dict 中把 one 删除集合# # 用 set 表达集合 empty_set = set() # 初始化一个集合，语法跟字典相似。 some_set = {1, 2, 3, 4} # 类似字典的 keys，set 的元素也必须是不可变类型 invalid_set = {[1], 1} # =\u0026gt; Raises a TypeError: unhashable type: \u0026#39;list\u0026#39; valid_set = {(1,), 1} # 可以把集合赋值于变量 filled_set = some_set # 为集合添加元素 filled_set.add(5) # filled_set 现在是 {1, 2, 3, 4, 5} # set 没有重复的元素 filled_set.add(5) # filled_set 依然是 {1, 2, 3, 4, 5},不报错也不会增加 # \u0026#34;\u0026amp;\u0026#34; 取交集 other_set = {3, 4, 5, 6} filled_set \u0026amp; other_set # =\u0026gt; {3, 4, 5} # \u0026#34;|\u0026#34; 取并集 filled_set | other_set # =\u0026gt; {1, 2, 3, 4, 5, 6} # \u0026#34;-\u0026#34; 取补集 {1, 2, 3, 4} - {2, 3, 5} # =\u0026gt; {1, 4} # \u0026#34;^\u0026#34; 取异或集（对称差） {1, 2, 3, 4} ^ {2, 3, 5} # =\u0026gt; {1, 4, 5} # 判断左边的集合是否是右边集合的超集 {1, 2} \u0026gt;= {1, 2, 3} # =\u0026gt; False # 判断左边的集合是否是右边集合的子集 {1, 2} \u0026lt;= {1, 2, 3} # =\u0026gt; True日期时间处理# Python里面处理日期主要是time和datetime模块\n# 需要导入这两个模块 # 只处理时间可以用time，如果包含日期就要用datetime了 import time from datetime import date, timedelta, datetime # 获取现在时间 now = time.strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;) now = datetime.now().strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;) # 获取第几周 time.strftime(\u0026#39;%U\u0026#39;) 在处理时间中，有2个函数是非常重要的，分别是strftime函数和strptime,分别是时间格式转化为字符串格式和字符串格式转化为时间格式，大致用法如下 # strftime用法 time.strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;) # 把时间转化为%Y-%m-%d %H:%M:%S 类型字符串 time.strftime(\u0026#39;%Y/%m/%d %H:%M:%S\u0026#39;) # 把时间转化为%Y/%m/%d %H:%M:%S 类型字符串 # strptime用法 # 时间日期字符串转换 str111 = \u0026#39;2022-04-14 16:41:03\u0026#39; date = datetime.strptime(str111, \u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;) # 字符串转日期，注意字符串时间格式需要和后面的规则匹配，不一致会报错 date.strftime(\u0026#39;%Y-%m-%d\u0026#39;) # 一般进行strptime之后，还是会进行strftime一次的，时间格式的无法输出的 #超时保护机制，主要用于防止无限循环或长时间阻塞。 import time timeout = 5 # 设置5秒超时 #1970年1月1日00:00:00 start = time.time() while True: # 执行某些操作 print(\u0026#34;hello\u0026#34;) # 当前时间 - 开始时间 \u0026gt; 大于超时时间 if time.time() - start \u0026gt; timeout: print(\u0026#34;操作超时，重新开始...\u0026#34;) #start = time.time() # 重置计时器 continue # 或其他处理逻辑循环# Python中循环类型较少，只有while和for，其实都差不多\n# for 循环，循环一个列表 for animal in [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;mouse\u0026#34;]: # 你可以使用 format() 格式化字符串并插入值 print(f\u0026#34;{animal} is a mammal\u0026#34;) # 有时候不仅仅要循环，还要看循环的第几个 animals = [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;mouse\u0026#34;] for i, value in enumerate(animals): print(i, value) # 0 dog # 1 cat # 循环一个字典 ddict = {\u0026#34;key1\u0026#34;: \u0026#34;val1\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;val2\u0026#34;} for k, v in ddict.items(): print(k, v) # key1 val1 # key2 val2 # 指定循环次数 # range(lower, upper, step)\u0026#34; 会返回一个，从 lower 到 upper、并且间隔值为 step 的迭代器。如果 step 未传入则会使用默认值 1 # 注意 range(4) = 0,1,2,3，其中4是不包含的 for i in range(4): print(i) # 有时候也可以跳着循环 # range(4, 8) 是指4,5,6,7 for i in range(4, 8): print(i) # 有时候会需要跳着循环 # range(4, 8, 2) = 4,6 for i in range(4, 8, 2): print(i) # 计数循环也可以用while x = 0 while x \u0026lt; 4: print(x) x += 1 # x = x + 1 的简写 # 通过一个while True来个死循环 x = 0 while True: print(x) x += 1 # x = x + 1 的简写变量/常量与函数# 变量和函数是Python中最常用的类型【在其他语言里面也一样】 变量和函数有些命名规则一样，主要由以下几点：\n由大小写字母和下划线和数字组成 不能用数字开头 不能和Python内置关键字和内置函数重复 区分大小写 不能包含空格 可以是汉字，但是真心没必要 应该简短且可意义识别\n# Python中变量创建的时候必须要赋值 # = 是赋值符号 # 基本语法是：name = value my_age = 18 # 常量一般定义那些不会修改的内容 # 常量一般用全部大写来表示 DEVELOPER = \u0026#39;Pein\u0026#39; # 变量的最基础用法就是和其他数据组合 print(f\u0026#39;我的年龄是{my_age}\u0026#39;) # 如下，直接定义但是不赋值，会被认为是调用，而报错 some_var # 变量是不可以同名的，否则会被替换 some_var = 5 # 输出5 some_var = 2 # 输出2 # 变量名不能是Python关键字以及不可以是数字开头 # 变量命名要能简单认识,如下从名字就可以猜出来意义 my_pc_size = 123 # 下面这种，语法上是可以的，就是容易会被打，极度不推荐 aaaaaaaaaaaa = 123 # 变量是有作用域的 # 主要是分为局部变量和全局变量 a = 1 # a 是全局变量，任何函数都可以使用，属于公交车 def add(): b = 2 # b是局部变量，只能在add函数下使用，属于私家车 return b # 调用变量看下 a # 输出1 b # 报错，提示未定义，因为他不是全局变量 # 使用global关键字可以调用全局变量 def add(): global a b = 2 # b是局部变量，只能在add函数下使用，属于私家车 return a + b add() # 输出3 # 全局变量使用内存较多，局部变量内存较小，所以能使用局部变量的就不要使用全局变量 函数本质上是一套代码的组合封装，做到代码的重复使用 # 用def定义新函数 def add(x, y): print(f\u0026#34;x is {x} and y is {y}\u0026#34;) return x + y # 用 return 语句返回 # 定义新函数也可以指定类型,Python并不会对类型进行验证，还是需要手动验证 def add(x: int, y: int) -\u0026gt; int: return x + y # 用 return 语句返回 # 也可以加一个默认参数，这样调用的时候可以节省打字 # 但是注意，默认参数只能放在最后面 def add(x, y, z=2): print(f\u0026#34;x is {x} and y is {y}\u0026#34;) return x + y + z # 调用函数 add(5, 6) # =\u0026gt; 打印 \u0026#34;x is 5 and y is 6\u0026#34; 并且返回 11 # 也可以用关键字参数来调用函数 add(y=6, x=5) # 关键字参数可以用任何顺序 # 使用返回多个数值（返回值为元组类型，也可以是其他类型） def swap(x, y): return y, x # 用不带括号的元组的格式来返回多个数值 # (注意: 括号不需要加，但是也可以加) x, y = swap(x, y) # =\u0026gt; x = 2, y = 1 # 也有匿名函数,匿名函数是没有函数名的函数，一般用于简短的小函数 (lambda x: x \u0026gt; 2)(3) # =\u0026gt; True (lambda x, y: x ** 2 + y ** 2)(2, 1) # =\u0026gt; 5 # 内置的高阶函数 list(map(add_10, [1, 2, 3])) # =\u0026gt; [11, 12, 13] list(map(max, [1, 2, 3], [4, 2, 1])) # =\u0026gt; [4, 2, 3] list(filter(lambda x: x \u0026gt; 5, [3, 4, 5, 6, 7])) # =\u0026gt; [6, 7] # 用列表推导式可以简化映射和过滤。列表推导式的返回值是另一个列表。 [add_10(i) for i in [1, 2, 3]] # =\u0026gt; [11, 12, 13] [x for x in [3, 4, 5, 6, 7] if x \u0026gt; 5] # =\u0026gt; [6, 7] # 你也可以用这种方式实现对集合和字典的构建 {x for x in \u0026#39;abcddeef\u0026#39; if x not in \u0026#39;abc\u0026#39;} # =\u0026gt; {\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;} {x: x ** 2 for x in range(5)} # =\u0026gt; {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}路径相关# Python的路径操作基本在 os 模块下 import os # 判断文件是否存在，其实文件夹也可以的 os.path.exists(path) # 拼接路径 os.path.join(\u0026#39;D\u0026#39;, \u0026#39;MY\u0026#39;, \u0026#39;FILE\u0026#39;) # =\u0026gt;D:\\\\MY\\\\FILE # 返回绝对路径，一般是把相对路径转化为绝对路径 os.path.abspath(path) # 返回文件的最后修改时间 os.path.getmtime(path) # 返回文件的创建时间 os.path.getctime(path) # 返回文件大小 os.path.getsize(path) # 是文件 os.path.isfile(path) # 是目录 os.path.isdir(path) # 拆分文件路径 os.path.split(path) # =\u0026gt;(\u0026#39;D:\\\\沈鵬\\\\Code\\\\Projects\\\\HA03追溯\\\\trunk\u0026#39;, \u0026#39;run.py\u0026#39;) # 获取文件上层目录名字 os.path.basename(path) # 查看目录下所有文件和文件 os.listdir(path) # 查看目录下所有文件，不包含目录 next(os.walk(path), (None, None, []))[2] # 获取子目录清单 next(os.walk(path))[1]文件操作# with open(xlsx, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: res = f.read() 字符含意注意事项 r只读读取文本（默认）文件必须存在，否则报错 rb只读打开二进制文件，不需要编码，一般是非文本文件，比如图片文件必须存在，否则报错 rb+读写打开二进制文件，不需要编码，一般是非文本文件，比如图片文件必须存在，否则报错 w只写模式打开文件如已存在文件则清空重写，不存在则新建 wb只写打开二进制文件，不需要编码，一般是非文本文件，比如图片如已存在文件则清空重写，不存在则新建 w+打开文件清空文件，具有读写权限注意事项 wb+打开二进制文件，具有读写权限注意事项 a已追加默认打开文件，只有写入权限，写在文件最后面原来的内容不会清空 a+打开二进制文件，具有读写权限注意事项 ab打开二进制文件，具有读写权限注意事项 ab+打开二进制文件，具有读写权限注意事项 with open(xlsx, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: lines = f.read() # 返回全部文本 lines_list = f.readlines() # 按照每行返回列表 line = f.readline() # 只返回一行数据 # 也可以循环读取文件 for line1 in f: print(line1) str1 = \u0026#39;32123\u0026#39; with open(xlsx, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(str1) # 把字符串写入文本中 注意 文件读写编码问题是个坑，一定要摸清楚所要读写的文件的编码，可以用 notepad++ 打开看下是什么编码 除了上面读取写入，还有文件删除等操作 import os os.remove(file_path)系统信息# import os # 获取登录名 user_name = os.getlogin() # 获取环境变量 pc_env = os.environ # 环境变量是个字典，可以拉取一些信息 pc_name = os.environ[\u0026#39;COMPUTERNAME\u0026#39;] # 可以把指定路径加入到系统环境变量里面 my_path = \u0026#39;D:\\\\Python310\\\\DLLs\u0026#39; os.environ[\u0026#39;PATH\u0026#39;] += os.pathsep + my_path信息加密/解密# # base64加密 import base64 str = \u0026#39;123456\u0026#39; # 把字符进行base64加密 jiamistr = base64.b64encode(str.encode()).decode() # 把已加密的字符进行解密 str = base64.b64decode(jiamistr).decode() # base64只是简单的加密，不算真正的加密 import hashlib # 其中支持几种加密方法 # \u0026#39;md5\u0026#39;, \u0026#39;sha256\u0026#39;, \u0026#39;sha512\u0026#39;这几种常用的就可以了 hashlib.sha256(\u0026#34;Nobody inspects the spammish repetition\u0026#34;.encode()).hexdigest() # \u0026#39;031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406\u0026#39;处理JSON文件# 先来一个json文件范例，在json中，请使用\u0026quot;双引号，不能使用单引号\n{ \u0026#34;numbers\u0026#34;: 0, \u0026#34;strings\u0026#34;: \u0026#34;Hellø, wørld. All unicode is allowed, along with \\\u0026#34;escaping\\\u0026#34;.\u0026#34;, \u0026#34;has bools?\u0026#34;: true, \u0026#34;nothingness\u0026#34;: null, \u0026#34;big number\u0026#34;: 1.2e+100, \u0026#34;objects\u0026#34;: { \u0026#34;comment\u0026#34;: \u0026#34;Most of your structure will come from objects.\u0026#34;, \u0026#34;array\u0026#34;: [ 0, 1, 2, 3, \u0026#34;Arrays can have anything in them.\u0026#34;, 5 ], \u0026#34;another object\u0026#34;: { \u0026#34;comment\u0026#34;: \u0026#34;These things can be nested, very useful.\u0026#34; } }, \u0026#34;silliness\u0026#34;: [ { \u0026#34;sources of potassium\u0026#34;: [ \u0026#34;bananas\u0026#34; ] }, [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, \u0026#34;neo\u0026#34; ], [ 0, 0, 0, 1 ] ] ], \u0026#34;that was short\u0026#34;: \u0026#34;And, you\u0026#39;re done. You now know everything JSON has to offer.\u0026#34; } Python的json操作需要导入库json,主要就是2种方法，4个函数，其中带s的是指数据流转换 import json # 把json字符串转为json对象 json.loads(reponse) # 把json对象转化为json字符串 json.dumps(reponse) # 从文件把json字符串转为json对象 json.load(reponse) # 从文件把json对象转化为json字符串 json.dump(reponse)控制流# 逻辑判断主要点就是以下几点：\n判断的值数据类型要对，可以看下上面的布尔值数据类型\r要做判空，数据是否为空\r用=判断注意，是双等于号 ==\r优先判断最常出现的项目\r判断层别不宜超出3层，如果超出3层，那就是代码有问题\rx = 0 if x \u0026lt; 0: print(\u0026#39;Negative changed to zero\u0026#39;) elif x == 0: print(\u0026#39;Zero\u0026#39;) elif x == 1: print(\u0026#39;Single\u0026#39;) else: pass # 这个是Python中的最无用的代码，意思就是这里不需要写代码，先占个位，防止没代码报错的 # \u0026#34;if\u0026#34; 可以用作表达式，它的作用等同于 C 语言的三元运算符 \u0026#34;?:\u0026#34; \u0026#34;yay!\u0026#34; if 0 \u0026gt; 1 else \u0026#34;nay!\u0026#34; # =\u0026gt; \u0026#34;nay!\u0026#34; Python中类似于其他语言的switch在Python3.10里面才有，所以为了兼容性考虑，暂时就不用这玩意了。另外pass 这个意思是先占个坑的意思，没有任何功能报错处理# 如果不想自己写的代码莫米奇妙的死了，就必须要要做一定的报错处理，这个可以给任何错误兜底，最起码软件不是还在跑嘛？\n# 用 try/except 块处理异常状况 try: print(\u0026#39;我是正常的代码,一般的代码都会写在这里\u0026#39;) except (TypeError, NameError): print(\u0026#39;我是发生TypeError, NameError报错时候的代码\u0026#39;) # 可以同时处理不同类的错误 except Exception as e: print(\u0026#39;我是报错时候的代码，我也不知道是什么错误\u0026#39;, e) # 任何除之前已经注明的报错都会触发这个代码 else: # else语句是可选的，但必须在所有的except之后 print(\u0026#34;All good!\u0026#34;) # 只有当try运行完没有错误的时候这句才会运行 finally: # 在任何情况下都会执行 print(\u0026#34;我不管有木有报错都会运行的\u0026#34;) 上面是个完整些的报错处理代码，但是实际用的比较多的可能是下面这样的 try: print(\u0026#39;我是正常的代码,一般的代码都会写在这里\u0026#39;) except Exception as e: print(\u0026#39;我是报错时候的代码，我也不知道是什么错误\u0026#39;, e) # 任何除之前已经注明的报错都会触发这个代码 关于程序处理错误的问题，有两种思想LBYL/EAFP，以下是一些说明 LBYL:“先查看后跳跃”的英文缩写。这种代码编写风格会在进行调用或查找之前显式地检查前提条件，其特点是大量使用 if 语句。 # 以下是伪代码,仅表达思想 if x是个人: if x是个男人: if x年龄大于18岁: if x有抽样习惯: print(\u0026#39;来，x大佬，抽根烟\u0026#39;) EAFP:“求原谅比求许可更容易”的英文缩写。这种 Python 常用代码编写风格会假定所需的键或属性存在，并在假定错误时捕获异常。这种简洁快速风格的特点就是大量运用 try 和 except 语句。 # 以下是伪代码,仅表达思想 try: print(\u0026#39;来，x大佬，抽根烟\u0026#39;) except Exception as e: print(\u0026#39;大佬不抽烟，原因：\u0026#39;, e) # 报错输出：大佬不抽烟，原因：x是条狗"},{"id":14,"href":"/Game/%E9%BC%A0%E6%A0%87%E6%BC%82%E7%A7%BB/","title":"处理鼠标漂移","section":"Game","content":"http://bbs.anjian.com/showtopic-566788-1.aspx https://blog.sina.com.cn/s/blog_9522b30f010119su.html\nhttps://tieba.baidu.com/p/3989538710?share=9105\u0026fr=sharewise\u0026see_lz=0\u0026share_from=post\u0026sfc=copy\u0026client_type=2\u0026client_version=12.89.1.0\u0026st=1760188693\u0026is_video=false\u0026unique=824A8C4E0644456F60814F8819DB0547\n鼠标漂移的解决方案汇总# 一、图色层面# 🧩 方法1：目标图定位 + 鼠标图校正（图色自校准法）# 原理：\n先用 FindPic 找到目标图坐标 (tx, ty)。 直接移动鼠标到目标位置。由于存在偏移，通常点不中目标。 再次搜索鼠标箭头图片 (mx, my)，计算偏移量： dx = tx - mx\rdy = ty - my然后执行 MoveR(dx, dy) 进行相对校正。\n说明：\n只要找图准确，基本一到两次修正即可精准定位。 （修正逐渐移动？或者瞬间移动，不知道哪个效果好） 梦幻西游的图色漂移问题，就是通过这种方式解决的。\n二、内存层面# 🧩 方法1：读内存坐标差值修正（内存坐标比对法）# 原理：\n从游戏内存中读取当前鼠标坐标 (gx, gy)；\n同时获取系统鼠标坐标 (sx, sy)；\n计算差值：\ndx = gx - sx\rdy = gy - sy 执行 MoveR(dx, dy) 修正位置；\n重复检测与移动，直到偏差小于阈值（一般为 1 像素以内）。\n说明：\n这种方法属于“读内存修正法”，适用于可直接读取游戏鼠标坐标的情况。\n其本质是 用游戏坐标与系统坐标做动态闭环调整。\n🧩 方法2：锁定鼠标基址（内存基址追踪法）# 原理：\n使用 CE 搜索鼠标坐标基址： 初始搜索未知数； 向左移动鼠标 → 搜索“变小的值”； 向右移动鼠标 → 搜索“变大的值”； 多次筛选直到锁定两个地址（X、Y）。 右键查看访问指令，找到 [base + offset] 结构； 将该基址固定，循环读取即可获得游戏鼠标的真实位置。 说明：\n梦幻西游的鼠标基址可以直接寻到，不需要下断点。\n找到基址后，可长期稳定读取坐标，并配合图色判断修正漂移。\n简单游上的“果壳梦幻辅助”就是基于这种原理。\n三、逻辑层面（CALL级操作）# 🧩 方法：逻辑调用替代鼠标操作（逻辑CALL法）# 原理：\n不再移动鼠标，而是直接调用游戏内部的逻辑函数（CALL）。\n常见例子：\nNPC对话：遍历到 NPC 基址后，调用 DialogCall(NpcID)； 背包操作：直接调用物品管理 CALL； 寻路：调用 MoveTo(x, y) 函数。 说明：\n这种方式完全绕过鼠标，直接操作游戏逻辑。\n适合高端后台脚本或工作室级辅助，性能稳定且无漂移。\n✅ 总结对比# 类型 方法 核心手段 难度 稳定性 说明 图色法 图色+鼠标图校正 二次找图修正 ★ ★★★ 实现简单、兼容性好 内存法 读坐标差值 动态比对收敛 ★★ ★★★★ 精度高、可后台 内存法 锁定基址 固定地址读取 ★★★ ★★★★★ 稳定、适合长期运行 CALL法 调用游戏函数 内部逻辑执行 ★★★★★ ★★★★★ 无漂移、最高级实现 "},{"id":15,"href":"/Game/%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/","title":"大漠插件","section":"Game","content":"如何调用大漠# Python调用大漠插件注意事项# PyCharm 必须 以管理员身份运行（或者你用 python.exe 直接运行也要管理员权限）。 大漠插件本身是 32 位的 COM 组件，所以只能在 32 位 Python 下调用。 解决64调用： C/S架构 s运行在32位,c运行在64，c发送调用到s\n注册方式# 传统方式（注册调用） 以前要调用大漠插件（dm.dll），需要先用 regsvr32 dm.dll来进行注册。这样做的实质是把COM 组件的信息写入 Windows 注册表，让系统知道 dm.dll 是一个 COM 对象，可以用 CreateObject(\u0026quot;dm.dmsoft\u0026quot;) 或者 new ActiveXObject(\u0026quot;dm.dmsoft\u0026quot;) 来创建。\n缺点：必须有管理员权限才能注册。污染注册表，易被游戏检测\n免注册调用\n从 大漠插件 3.1235 版本开始，可以用 DmReg.dll来绕过注册表，直接加载对应的dm.dll，也就是说你不需要再用regsvr32，只要在程序启动时调用 DmReg.dll 的接口就行。\nDmReg.dll暴露了 两个导出函数：\nSetDllPathA(const char* path, int mode) 参数 1：ASCII 字符串（插件所在路径，比如 \u0026quot;C:\\\\dm\u0026quot;）。 参数 2：线程模型（0=STA，1=MTA）。 SetDllPathW(const wchar_t* path, int mode) 参数 1：Unicode 字符串（同上）。 参数 2：线程模型（0=STA，1=MTA）。 调用这个函数后，dmreg.dll 会把路径下的 dm.dll 注册到内存中（只对当前进程生效），不依赖系统注册表。\nimport ctypes import os from win32com.client import Dispatch def 注册大漠(注册码=\u0026#39;\u0026#39;, 附加码=\u0026#39;\u0026#39;): print(\u0026#39;正在初始化\u0026#39;) # 通过调用DmReg.dll注册大漠 这样不会把dm.dll写到系统中，从而实现免注册 patch = ctypes.windll.LoadLibrary(os.path.dirname(__file__) + \u0026#39;./DmReg.dll\u0026#39;) patch.SetDllPathW(os.path.dirname(__file__) + \u0026#39;./dm.dll\u0026#39;, 0) dm_主对象 = Dispatch(\u0026#39;dm.dmsoft\u0026#39;) # 创建对象 ver = dm_主对象.ver() print(\u0026#39;免注册调用初始化成功 版本号为:\u0026#39;, ver) # 注册大漠VIP if ver != \u0026#39;\u0026#39;: reg = dm_主对象.reg(注册码, 附加码) if reg == 1: print(\u0026#34;大漠vip注册成功\u0026#34;) return dm_主对象 else: print(f\u0026#34;大漠注册失败,错误代码: {reg}\u0026#34;)大漠函数# SetPath# 设置全局路径,设置了此路径后,所有接口调用中,相关的文件都相对于此路径. 比如图片,字库等.\nBindWindow# BindWindow是大漠插件的核心函数，建立上下文,用于将鼠标、键盘、图色等操作绑定到指定窗口，实现前台或后台自动化。\nBindWindow共有5个参数，其中第5个可选。\nresult = dm.BindWindow(hwnd, display, mouse, keypad, mode) 参数 类型 必填 说明 hwnd 整数 (Integer) 必填 窗口句柄（Window Handle）。通常通过 dm.FindWindow 或 dm.FindWindowEx 获取。代表你要绑定的目标窗口。 display 字符串 (String) 必填 显示模式，决定如何获取窗口图像（用于图色、截图）。\n常见值：\n- \u0026quot;gdi\u0026quot;：GDI 模式，兼容性好，仅支持前台。\n- \u0026quot;dx\u0026quot; / \u0026quot;dx2\u0026quot;：DirectX 模式，支持后台截图和图色。\n- \u0026quot;opengl\u0026quot;：OpenGL 模式，用于 OpenGL 应用。\n- \u0026quot;normal\u0026quot;：普通模式。 mouse 字符串 (String) 必填 鼠标模式，决定鼠标操作的方式。\n常见值：\n- \u0026quot;windows\u0026quot;：前台鼠标（真实移动）。\n- \u0026quot;dx\u0026quot; / \u0026quot;dx2\u0026quot;：后台鼠标（发送消息）。\n- \u0026quot;windows2\u0026quot;：前台鼠标，支持某些特殊窗口。\n- \u0026quot;dx.mouse.position\u0026quot;：DX 高精度鼠标定位。 keypad 字符串 (String) 必填 键盘模式，决定键盘输入的方式。\n常见值：\n- \u0026quot;windows\u0026quot;：前台按键（真实按键）。\n- \u0026quot;dx\u0026quot; / \u0026quot;dx2\u0026quot;：后台按键（发送消息）。\n- \u0026quot;dx.keypad\u0026quot;：DX 优化键盘输入。\n- \u0026quot;normal\u0026quot;：普通键盘模式。 mode 整数 (Integer) 可选 附加模式，用于控制绑定行为。\n常用值：\n- 0：默认模式。\n- 1：强制绑定，即使窗口不可见也尝试绑定。\n- 2：绑定时不激活窗口（推荐用于后台脚本）。\n- 3：组合模式（如 1+2）。\n默认值为 0。 参数使用示例 普通前台绑定（适用于记事本、浏览器等） hwnd = dm.FindWindow(\u0026#34;Notepad\u0026#34;, \u0026#34;无标题 - 记事本\u0026#34;)\rdm.BindWindow(hwnd, \u0026#34;gdi\u0026#34;, \u0026#34;windows\u0026#34;, \u0026#34;windows\u0026#34;, 0) DX 游戏后台绑定（推荐） hwnd = dm.FindWindow(\u0026#34;GameWindow\u0026#34;, \u0026#34;My Game\u0026#34;)\rdm.BindWindow(hwnd, \u0026#34;dx\u0026#34;, \u0026#34;dx\u0026#34;, \u0026#34;dx\u0026#34;, 2) #mode=2: 不激活窗口 OpenGL应用绑定 hwnd = dm.FindWindow(\u0026#34;GLApp\u0026#34;, \u0026#34;OpenGL Viewer\u0026#34;)\rdm.BindWindow(hwnd, \u0026#34;opengl\u0026#34;, \u0026#34;opengl\u0026#34;, \u0026#34;opengl\u0026#34;, 0)关键要点\n五个参数必须匹配：display、mouse、keypad 建议使用相同技术（如都用 \u0026ldquo;dx2\u0026rdquo;），避免兼容性问题。 mode=2 很重要：用于后台脚本，防止窗口被意外激活。 绑定后需验证：检查返回值： 1：绑定成功 0：失败（可能模式不支持或窗口无效） if dm.BindWindow(hwnd, \u0026#34;dx2\u0026#34;, \u0026#34;dx2\u0026#34;, \u0026#34;dx2\u0026#34;, 2) == 1:\rprint(\u0026#34;绑定成功，可进行后台操作\u0026#34;)\relse:\rprint(\u0026#34;绑定失败，请检查模式或窗口\u0026#34;)总结BindWindow 的 5 个参数分别控制：\n绑定哪个窗口（hwnd） 如何显示/截图（display） 如何模拟鼠标（mouse） 如何模拟键盘（keypad） 附加行为控制（mode） 正确配置这5个参数，是实现稳定、高效自动化（尤其是后台操作）的基础。 CapturePic# CapturePic的基本用法\ndm.CapturePic(x1, y1, x2, y2, \u0026#34;output.bmp\u0026#34;) •参数：x1, y1, x2, y2 是屏幕绝对坐标。 •原理：直接从屏幕缓冲区读取指定矩形区域的像素。 •不依赖句柄：即使不调用 BindWindow，也能执行 。 所以严格来说，CapturePic不是“根据窗口句柄”截图，而是“根据屏幕坐标”截图。 2. 为什么感觉“根据句柄截图”？因为最佳实践流程中，我们通过句柄获取窗口位置，再用位置去截图： # 1. 通过窗口类名/标题找到句柄 hwnd = dm.FindWindow(\u0026#34;Notepad\u0026#34;, \u0026#34;无标题 - 记事本\u0026#34;) # 2. 获取窗口在屏幕上的位置 left, top, right, bottom = dm.GetWindowRect(hwnd) # 例如：(100, 100, 900, 700) # 3. 截取整个窗口区域 dm.CapturePic(left, top, right, bottom, \u0026#34;window.bmp\u0026#34;) # 4. 或只截客户区（游戏画面区域） client_left, client_top, client_right, client_bottom = dm.GetClientSize(hwnd) dm.CapturePic(left + client_left, top + client_top, left + client_right, top + client_bottom, \u0026#34;client.bmp\u0026#34;) 在这个流程中：•句柄 (hwnd) 用于获取窗口位置。•位置 转化为屏幕坐标。•CapturePic 使用这些坐标截图。所以，句柄是“间接工具”，真正截图的是坐标。 对比：绑定窗口后截图（更推荐）# 绑定窗口（内部保存了句柄和上下文） dm.BindWindow(hwnd, \u0026#34;gdi\u0026#34;, \u0026#34;windows\u0026#34;, \u0026#34;0\u0026#34;) # 获取窗口矩形 left, top, right, bottom = dm.GetWindowRect(hwnd) # 基于句柄获取的位置截图 dm.CapturePic(left, top, right, bottom, \u0026#34;game.bmp\u0026#34;) BindWindow 后，大漠插件可以更高效地管理窗口上下文，确保截图与图色、鼠标操作坐标系统一致。GetColorNum# 获取指定区域的颜色数量,颜色格式\u0026quot;RRGGBB-DRDGDB\u0026quot;,注意,和按键的颜色格式相反\n大漠找图找字原理# 大漠找字原理：\n提取目标区域的像素特征 与字库中的特征模板匹配 返回匹配结果 找图原理：\n提取整个图片的像素矩阵 与目标图片矩阵逐像素对比 → 从底层来看，找字和找图本质上都是图像特征匹配问题，因此它们可以互通：\n字当作图来找：把字符截图当小图片，用找图方法识别； 图当作字来识别：把固定图案加入字库，用找字方法识别。 在实际应用中，更常用的方式是把字当作图来处理，尤其是面对动态背景、发光描边或颜色变化的文字。 1.大漠找图# 本质：把目标图当作整图或局部图去匹配\n优化：\n可以是像素对比，也可以是特征点匹配 可以处理旋转、缩放、色差 特点：识别任意图案，灵活但相对慢\n什么透明图# 透明图就是把图片里不重要的像素变成“透明”，大漠找图时只匹配你要的部分，背景全部忽略。\n当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明图处理.\n为什么要用透明图？\n背景会变 颜色会变 UI 会闪 字会发光、描边 透明图能把这些统统过滤掉。 字也能做透明图\n文字本质就是“小图片”：\n字形固定 背景常变 颜色偏差大 描边/发光干扰多 用透明图找字 = 按形状匹配，不看颜色。\n所以完全不需要字库，也不怕偏色。\n透明图适用场景\n技能 CD 数字 血量数字、跳字 按钮文字 背包、强化、购买等 UI 字 任何背景复杂、颜色不稳定的字或图标 2.大漠文字识别# 如果是纯色的文字，背景也不变， 那么直接用找字就行，而面对复杂的文字，那么就改用找图的方式了。大致处理逻辑如下\n背景变 → 透明图 字体色变 → 找图 字形变 → 弃用透明图 字体特性 背景特性 优选方案 关键理由 纯色稳定 稳定 字库-\u0026gt;找字 速度最快，实现简单 纯色稳定 动态 透明图-\u0026gt;找图 (字库可选) 消除背景干扰 渐变/发光 稳定 普通找图 颜色变化使字库失效 渐变/发光 动态 透明图-\u0026gt;找图 双重抗干扰 字形动态变化 任意 字库/OCR/颜色识别 透明图依赖固定形状 关键洞察\n统一处理逻辑：数字、符号、汉字在大漠中均为“图像对象” 透明图本质：通过透明色屏蔽背景干扰，保留字体轮廓 OCR局限性：大漠OCR基于字库，对动态变色/变形文字识别率低 实战要点\n常规场景：透明图 + 找图组合可解决 80% 识别问题 动态数字（伤害值/坐标）：需使用高级 OCR 或深度学习方案 进阶方案：YOLO 目标检测 + OCR 应对复杂动态文字 "},{"id":16,"href":"/Python/Python%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81/schedule/","title":"定时任务-schedule","section":"Python应用代码","content":"一个简单的使用# from datetime import datetime, timedelta, time import schedule import time def job(): print(\u0026#34;I\u0026#39;m working...\u0026#34;) def greet(name): print(\u0026#39;Hello\u0026#39;, name) ## 随机时间执行 schedule.every(5).to(10).seconds.do(job) ## 带参数执行 schedule.every(2).seconds.do(greet, name=\u0026#39;Alice\u0026#39;) schedule.every(4).seconds.do(greet, name=\u0026#39;Bob\u0026#39;) ## 每 3 second/minute/hour/day/week 执行一次 schedule.every(3).seconds.do(job) schedule.every(3).minutes.do(job) schedule.every(3).hours.do(job) schedule.every(3).days.do(job) schedule.every(3).weeks.do(job) # 每小时执行，直到指定时间停止 schedule.every().hour.until(\u0026#34;2030-01-01 18:33\u0026#34;).do(job) # 每小时执行，直到8小时后停止 schedule.every(2).hours.until(timedelta(hours=8)).do(job) # 每分钟指定秒执行一次 schedule.every().minute.at(\u0026#34;:23\u0026#34;).do(job) # 每小时指定分执行一次 schedule.every().hour.at(\u0026#34;:42\u0026#34;).do(job) # 每小时指定分/秒执行一次 schedule.every(5).hours.at(\u0026#34;20:30\u0026#34;).do(job) # 每天指定时间执行一次 schedule.every().day.at(\u0026#34;10:30\u0026#34;).do(job) schedule.every().day.at(\u0026#34;10:30:42\u0026#34;).do(job) schedule.every().day.at(\u0026#34;12:42\u0026#34;, \u0026#34;Europe/Amsterdam\u0026#34;).do(job) # 每周指定天执行一次 schedule.every().monday.do(job) schedule.every().wednesday.at(\u0026#34;13:15\u0026#34;).do(job) schedule.every().minute.at(\u0026#34;:17\u0026#34;).do(job) # 立刻把全部任务跑一遍 schedule.run_all() # 取消任务 schedule.cancel_job(job) # 获取全部任务 all_jobs = schedule.get_jobs() # 取消全部任务 schedule.clear() while True: schedule.run_pending() time.sleep(1)使用装饰器# from schedule import every, repeat, run_pending import time @repeat(every(10).minutes) def job(): print(\u0026#34;I am a scheduled job\u0026#34;) while True: run_pending() time.sleep(1)多进程定时任务# import threading import time import schedule def job(): print(\u0026#34;I\u0026#39;m running on thread %s\u0026#34; % threading.current_thread()) def run_threaded(job_func): job_thread = threading.Thread(target=job_func) job_thread.start() schedule.every(10).seconds.do(run_threaded, job) schedule.every(10).seconds.do(run_threaded, job) schedule.every(10).seconds.do(run_threaded, job) schedule.every(10).seconds.do(run_threaded, job) schedule.every(10).seconds.do(run_threaded, job) while 1: schedule.run_pending() time.sleep(1)"},{"id":17,"href":"/Game/%E5%B9%BD%E7%81%B5%E9%94%AE%E9%BC%A0/","title":"幽灵键鼠","section":"Game","content":"ghostbox.pyd #将该文件放入ddls下面D:\\software\\Python312\\DLLs\nimport ghostbox as gb import time # 打开设备 #按索引打开设备，返回 1 = 成功。index 即设备编号/ID（0 开始） # if gb.opendevice(0) != 1: # raise Exception(\u0026#34;幽灵键鼠设备打开失败\u0026#34;) #按 VID/PID 打开设备 if gb.opendevicebyid(20872,6145) == 1: print(\u0026#34;设备已连接，型号:\u0026#34;, gb.getmodel()) else: print(\u0026#34;设备打开失败，请检查 ID 或设备连接\u0026#34;) # 移动鼠标到指定位置 x, y = 200, 200 gb.movemouseto(x, y) print(f\u0026#34;鼠标移动到: ({x},{y})\u0026#34;) # 稍等几秒，观察效果 time.sleep(2) # 结束 if hasattr(gb, \u0026#34;closedevice\u0026#34;): gb.closedevice()"},{"id":18,"href":"/Game/%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9A%94%E7%A6%BB%E6%96%B9%E6%A1%88/","title":"脚本隔离方案","section":"Game","content":"虚拟机游戏脚本隔离方案# 背景：大漠能抓虚拟机画面，但无法跨系统直接发送键鼠，需中间层解决输入问题。\n方案 1：VNC 协议# 1-1 VMware 自带 VNC（简单零成本） VMware 开启 VNC 服务端 宿主机用 VNC 客户端连接 大漠绑定 VNC 客户端窗口 实现：取图 + 后台键鼠输入 成熟稳定，最易落地。\n1-2 自研 VNC 插件（高自由度，类似unify）\nVNC 层：直接连接 VM RFB 流 → 收画面 + 发键鼠 脚本层：封装图色/OCR/点击/按键接口，像大漠一样调用\n方案 2：虚拟机 + 双头盒子（硬件）# 大漠绑定 VM 窗口取图 双头盒子以物理 HID 模拟键鼠 零封号风险但成本高；适合大量机器。\n方案 3：大漠识别 + 自研通信协议（软件实现）# 宿主机：大漠负责识别画面 通过自定义协议发送键鼠指令到虚拟机 虚拟机需安装一个 Agent 用来接收指令并调用 SendInput 软件成本最低、扩展性强，但需在 VM 内运行 Agent。\n"},{"id":19,"href":"/Python/Python%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","title":"配置文件","section":"Python应用代码","content":"1\n"},{"id":20,"href":"/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/02.%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/","title":"02.数据宽度","section":"逆向初级","content":"什么是数据宽度# 计算机中存储的数据最终都是二进制存储的，计算机只认识1和0，但是不是一下子全部存进去的，而是分成很多的容器，每个容器都有最大容量，比如有的可以装4个二进制数，有的可以装8个二进制数。所以在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度）\n如果要存储的数超过了容器的数据宽度计算机怎么处理呢？直接将高位多出来的位丢弃！\n比如一个容器的数据宽度为4位，那么如果我现在存一个数16，化为二进制为10000，由于只能存4位，那么进位的多出来的位会被丢弃，最终读到的是0000，即0\n存储过程\n容器只有 4 位，意味着它本质就是一个 4 位寄存器/存储单元。 当你把 16（二进制 10000）写进去时，计算机会 只保留低 4 位： 10000 （5 位原始数据） ↓ 截断高位 0000 （只剩 4 位） 结果：读出来是 0 再看几个例子\n存 8（二进制 1000） → 1000（还能放得下） → 结果 = 8 存 15（二进制 1111） → 1111 → 结果 = 15 存 16（二进制 10000） → 截断 → 0000 → 结果 = 0 存 17（二进制 10001） → 截断 → 0001 → 结果 = 1 存 18（二进制 10010） → 截断 → 0010 → 结果 = 2 无符号数、有符号数# 以前我们只是记住：如果一个存储单元只有 4 位，\n无符号数：4 位全部用来表示数值，可表示 0000 到 1111，总共有 16 种可能。 有符号数：最高位作为符号位，0000 到 0111（最高位 0）表示正数，1000 到 1111（最高位 1）表示负数。 但实际上，计算机并不“认识”正负号。原码、反码、补码只是人类为了表示有符号数和方便运算而制定的规则，硬件只处理 0 和 1，并不会理解这些数的正负意义。\n4位宽度(理论示例)# 注意：1 位是理论上的最小存储单位，但在现代 CPU 和汇编实践中，最小的可操作单位通常是 8 位（1 字节），所以计算机中没有4位容器，我们只是为了引入方便理解。\n假设计算机只能存 4 位二进制数\n一共可以表示2^4=16 种数 对应十六进制： 二进制：0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 16进制： 0 1 2 3 4 5 6 7 8 9 A=10 B=11 C=12 D=13 E=14 F=151️⃣ 无符号数（Unsigned）\n定义：全部4位都用来表示数值，不区分正负 范围：0~15 规则：超过15再加1会绕到0（如16→0，17→1） 理解：计算机只认识0和1，它不“知道”正负。正负只是我们人为定义的解释方式。 2️⃣ 有符号数（Signed，补码表示）\n问题：4 位二进制数，同时要表示正数和负数\n解决：用 最高位 作为符号位（0正，1负），剩下3位表示数值\n范围：\n正数：000-0111 → 0到7 负数：1000-1111 → -8到-1 为什么 F 是 -1？\n4位补码规则：负数存储为 补码\n负数的补码 = 正数原码取反 + 1 以 1111 为例：\n最高位是1 → 是负数\n取反 + 1： 补码：1111 取反：0000 +1 ：0001\n得到原码 = 0001 → 十进制 1\n加上符号 → -1\n类似地：\n1110 → 取反 0001 → +1 → 0010 → -2 1101 → 取反 0010 → +1 → 0011 → -3 1000 → 取反 0111 → +1 → 1000（其实是4位的原码表示-8）\n补码的主要作用 是为了让负数可以在计算机中表示，并且加减运算可以统一。\n所以说它是 存储负数的一种方法，但更准确是 存储整数（正负数）的一种编码方式\n8位宽度# 假设现在4位不够表示我要存的数了，我换一个大一点的容器，存储数据的范围为0x00到0xFF，即数据宽度为8位，那么此时容器如何表示\n1. 无符号数表示\n对于 8位无符号数，范围从 0x00 到 0xFF，也就是从 0 到 255，共有 256 个可能的数值。这是因为每个位置上可以是 0 或 1，所以有 2^8 = 256 种不同的组合。\n最小值：0x00，即 0。 最大值：0xFF，即 255。 2. 有符号数表示\n对于 8位有符号数，我们需要使用 补码表示法。为了表示正负数，通常约定 最高位（即 符号位）为 0 时表示正数，符号位为 1 时表示负数。根据补码的规则，范围被分为两半：\n正数范围：0x00 到 0x7F，即从 0 到 127，这部分数据用补码表示时，符号位为 0，其余 7 位表示正数。\n0x00 = 00000000，表示正数 0。\n0x7F = 01111111，表示正数 127（符号位为 0）。\n负数范围：0x80 到 0xFF，即从 -128 到 -1，符号位为 1，剩余部分表示负数。负数的补码是通过对正数取反加 1 来得到的。\n0x80 = 10000000，表示负数 -128（符号位为 1）。\n0xFF = 11111111，表示负数 -1。即11111111 → 取反 00000000 → +1 → 00000000 → -1\n16位宽度# 16位数据宽度容器存储无符号数范围是从0到FFFF 存储有符号数从0到7FFF表示正数，从8000到FFFF表示负数 32位宽度# 目前计算机中最常见的也是这个数据宽度的容器\n32位数据宽度容器存储无符号数范围是从0到FFFFFFFF 存储有符号数从0到7FFFFFFF表示正数，从80000000到FFFFFFFF表示负数 补码# 为什么需要补码# 现代计算机的 CPU 通常没有独立的“减法器”电路，它通过“补码 + 加法器”来实现减法。 换句话说：计算机“假装”能做减法，其实是用加法“模拟”出来的。\n补码的核心目的： 让减法变成加法，从而只用一个加法器就能处理所有整数运算。\n补码的基本概念# 补码是一种二进制编码方式，用于在计算机中表示有符号整数（正数、负数、零）,这使得计算机能通过加法器来同时执行加法和减法运算。\n补码是存储整数的编码方式 正数的补码：和原码是一样的，保持不变。 负数的补码：是通过对其原码取反然后加1。 为什么补码统一了加法和减法？ 补码的最大优势之一就是它让计算机的硬件（加法器）可以 统一处理加法和减法。具体来说： 加法：对于正数，补码的加法就像普通的加法一样；对于负数，计算机会使用补码来进行加法，从而正确地计算出负数的加法结果。 减法：减法可以通过加法来转换。比如 A - B 可以转换为 A + (-B)，也就是说，计算机通过补码将减法问题转化为加法问题。 补码规则与原码转换# 核心规则：\n正数：原码 = 补码（无需转换） 负数：需要转换 0：原码和补码都是 00000000（补码只有一个 0） 负数：原码 → 补码# 示例：-5 的原码 → 补码\n步骤 二进制 说明 原码 10000101 符号位 1，数值 5=0000101 取反 11111010 符号位不变，数值位取反 加 1 11111011 11111010 + 1 = 11111011 所以 -5 的补码是：11111011\n负数：补码 → 原码# 负数的补码再求一次补码，就变回原码！\n示例：补码 11111011 → 原码\n取反：10000100 加 1：10000101 = 5 加负号：-5 原码：10000101 总结：转换口诀# 转换方向 口诀 原码 → 补码 “取反加一” 补码 → 原码 “再求一次补码” 正数/0 原码 = 补码，无需转换 补码加减法案例（8位）# 加法# 5 + 3 = 8\n00000101 (5)\r00000011 (3) 00001000 = 85 + (-3) = 2\n- `-3` 补码：`11111101`\r00000101 (5)\r11111101 (-3)\r00000010 = 2(-3) + (-2) = -5\n- `-2` 补码：`11111110`\r11111101 (-3)\r11111110 (-2) 11111011 → 取反加1 → 5 → -5减法（转加法）# 7 - 3 = 4\n00000111 (7)\r11111101 (-3) 00000100 = 45 - (-3) = 8\n00000101 (5)\r00000011 (3) 00001000 = 8(-3) - 2 = -5\n11111101 (-3)\r11111110 (-2) ------------\r11111011 → -5特殊# 127 + 1 = -128（溢出）\n01111111 (127)\r00000001 (1) --------------\r10000000 → -1283 + (-3) = 0\n00000011\r11111101\r00000000 = 0 所有运算 = 补码 + 加法器\n补码计算结果解读流程图# 开始\r↓\r看结果的最高位\r↓\r┌───────────────┐\r↓ ↓\r是 0？ 是 1？\r↓ ↓\r正数或 0 负数\r↓ ↓\r直接转十进制 取反 → 加1 → 得正数 → 加负号\r↓ ↓\r完成 完成数据单位# 存储单位\n名称 大小 位-BIT █（1位） 字节-Byte █|█|█|█|█|█|█|█（8位） 字-Word █|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█（16位） 双字-Doubleword █|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█（32位） 存储范围\n名称 大小 二进制位数 十六进制范围 十进制范围 位（Bit） 1 位 1 0 – 1 0 – 1 字节（Byte） 8 位 = 1 字节 8 0x00 – 0xFF 0 – 255 字（Word） 16 位 = 2 字节 16 0x0000 – 0xFFFF 0 – 65,535 双字（Double Word, DWORD） 32 位 = 4 字节 32 0x00000000 – 0xFFFFFFFF 0 – 4,294,967,295 当我们存储数据的时候，需要知道自己存储的数据的数据宽度是什么，假设你要存储一个1，要存入字节中，那么以二进制的表示即为：0000 0001，转为十六进制即为0x01 **字节（Byte）**的存储范围使用十六进制表示则为：0 - 0xFF **字（Word）**的存储范围：0 - 0xFFFF **双字（Doubleword）**的存储范围：0 - 0xFFFFFFFF\n"},{"id":21,"href":"/Python/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/Conda/","title":"Conda使用教程","section":"其它知识","content":"一、Conda的作用# python版本和第三方库众多,并且不同版本之间存在兼容性问题,Conda可以帮助我们管理python版本和依赖,避免依赖冲突 1.安装、管理、删除,更新python包 2.版本切换,不同的项目需要不同的python. 3.依赖隔离,比如项目A需要XXX 3.2版本,项目B需要XXX 4.5版本\n二、Anaconda和Miniconda区别# 特性 Anaconda Miniconda 发行公司 Anaconda, Inc. Anaconda, Inc. 安装方式 图形界面 + 命令行 命令行为主 默认包 集成 1500+ 科学计算常用包（NumPy、Pandas、Matplotlib、SciPy 等） 仅 Conda 本体 + Python 基础依赖 安装包大小 3~5 GB ~100 MB 环境灵活性 即装即用，适合初学者和数据科学用户 精简灵活，节省空间，可按需安装包 更新管理 包和环境更新方便，但占用空间大 包和环境可完全自定义，依赖需手动安装 使用场景 数据分析、机器学习、科研教学快速入门 节省空间、精简环境、服务器或脚本开发 三、Miniconda 下载地址# 官方（Anaconda 官网）\nhttps://www.anaconda.com/docs/getting-started/miniconda/main 国内镜像（清华大学 Tuna 镜像）\nhttps://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/ 四、配置源# 1️⃣ 查看当前镜像源\n在 cmd 或 Anaconda Prompt 中输入：\nconda config --show channels #这里可以确认你是否已经使用清华源。 channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - defaults2️⃣ 添加清华镜像源\n执行以下命令：\nconda config --add channels https://mirrors.cloud.tencent.com/anaconda/pkgs/free/\rconda config --add channels https://mirrors.cloud.tencent.com/anaconda/pkgs/main/\rconda config --add channels https://mirrors.cloud.tencent.com/anaconda/cloud/conda-forge/\rconda config --add channels https://mirrors.cloud.tencent.com/anaconda/cloud/pytorch/\rconda config --add channels https://mirrors.cloud.tencent.com/anaconda/pkgs/pro/\rconda config --set show_channel_urls yes --set show_channel_urls yes 会在安装包时显示具体源，方便确认。 ⚠️ 添加镜像源后，最好清除索引缓存：\nconda clean -i然后可以创建新环境测试：\nconda create -n myenv numpy3️⃣ 删除指定镜像源\n如果想移除某个镜像：\nconda config --remove channels \u0026lt;镜像地址\u0026gt;例如：\nconda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/4️⃣ 恢复默认镜像源 (重置，只保留默认源)\nconda config --remove-key channels执行后，conda 会使用官方默认源。\n五、修改 Conda 默认环境路径# 1.开始菜单\u0026ndash;\u0026gt;打开 Miniconda Prompt\nconda config --show envs_dirs #注意：Miniconda 的安装目录和环境目录（envs）不能一样。 mkdir D:\\conda_envs conda config --add envs_dirs D:\\conda_envs六、Conda 常用命令速查表# ## 环境管理（最常用） 创建环境\tconda create -n xxx python=3.x 激活环境\tconda activate xxx 安装包\tconda install 包名 删除环境\tconda env remove -n xxx --all 克隆环境（迁移）\tconda create -n new --clone old 清理缓存\tconda clean -a 查看所有环境\tconda env list ## 包管理（最常用） 安装包 conda install 包名 指定 channel： conda install -c conda-forge 包名 升级包 conda update 包名 搜索包 conda search 包名 升级 conda 本体： conda update conda 卸载包 conda remove 包名 查看当前环境安装了哪些包 conda list ## 配置相关 查看配置 conda config --show 查看配置文件来源 conda config --show-sources 添加环境目录 conda config --add envs_dirs D:\\conda_envs 设置默认频道 conda config --add channels conda-forge 清理缓存（非常常用） conda clean -a ## 导出环境（备份/迁移） 导出 yml conda env export \u0026gt; env.yaml 用 yml 创建环境 conda env create -f env.yaml"},{"id":22,"href":"/Python/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/1.Pandas%E5%9F%BA%E7%A1%80/","title":"Pandas基础","section":"Python数据处理","content":"一、文件的读取和导入# 数据读取# import pandas as pd print(pd.__version__) #查看版本 # 读取 csv df_csv = pd.read_csv(r\u0026#34;data/my_csv.csv\u0026#34;) # 推荐使用相对路径 # 读取 txt df_txt = pd.read_table(r\u0026#34;data/my_table.txt\u0026#34;) # 读取 excel df_excel = pd.read_excel(r\u0026#34;data/my_excel.xlsx\u0026#34;)常用参数：\nheader=None 第一行不作为列名 index_col 指定某列作为索引 usecols 指定读取的列 parse_dates 指定需要转为时间的列 nrows 指定读取的行数 指定分隔符 sep\nsep=\u0026rsquo;,\u0026rsquo; → 逗号分隔 sep=\u0026rsquo;\\t\u0026rsquo; → 制表符分隔（read_table 默认就是 \\t） sep=\u0026rsquo;\\s+\u0026rsquo; → 多个空格分隔 sep=\u0026rsquo;;\u0026rsquo; → 分号分隔 read_csv() 默认 sep=','，读取 csv 文件无需显式写 sep=','。 read_table() 默认 sep='\\t'，所以读取制表符 txt 文件可以直接用，不用改 sep。 read_excel 不需要 sep，因为 Excel 文件本身有单元格结构，不是纯文本分隔的。\n数据写入# 常用：index=False 避免保存索引\ndf_csv.to_csv(r\u0026#34;data/my_csv_saved.csv\u0026#34;, index=False) df_excel.to_excel(r\u0026#34;data/my_excel_saved.xlsx\u0026#34;, index=False) df_txt.to_csv(r\u0026#34;data/my_table_saved.txt\u0026#34;, sep=\u0026#39;\\t\u0026#39;, index=False)如果想要把表格转换为 markdown 和 latex 语言，可以使用 to_markdown 和 to_latex 函数，此处需要安装 tabulate 包。\ndf_csv.to_markdown() df_csv.to_latex()二、基本数据结构# 1. Series# s = pd.Series([100, \u0026#39;a\u0026#39;, {\u0026#39;dic1\u0026#39;: 5}, 1], index=pd.Index([\u0026#39;id1\u0026#39;, 20, \u0026#39;third\u0026#39;, \u0026#39;id2\u0026#39;], name=\u0026#39;my_idx\u0026#39;), dtype=\u0026#39;object\u0026#39;, name=\u0026#39;my_name\u0026#39;)常用属性\ns.values 返回 Series 的 数据值（NumPy 数组形式） 例子输出：array([100, 'a', {'dic1':5}, 1], dtype=object) s.index 返回 Series 的 索引（Index 对象） 例子输出：Index(['id1', 20, 'third', 'id2'], dtype='object', name='my_idx') 可以用来访问或操作索引 s.dtype 返回 Series 数据类型 例子输出：object 因为这里混合了数字、字符串和字典，所以 dtype 是 object s.name 返回 Series 的 名称 例子输出：'my_name' 方便在 DataFrame 中作为列名使用 s.shape 返回 Series 的 形状 例子输出：(4,) → 一维，有 4 个元素 s[\u0026lsquo;id1\u0026rsquo;] 根据索引取单个值 输出：100 2. DataFrame# data = [[1, \u0026#39;a\u0026#39;, 1.2], [2, \u0026#39;b\u0026#39;, 2.2], [3, \u0026#39;c\u0026#39;, 3.2]]\rdf = pd.DataFrame(data, index=[\u0026#39;row_0\u0026#39;,\u0026#39;row_1\u0026#39;,\u0026#39;row_2\u0026#39;],\rcolumns=[\u0026#39;col_0\u0026#39;,\u0026#39;col_1\u0026#39;,\u0026#39;col_2\u0026#39;])\r或使用字典构造：\rdf = pd.DataFrame({\u0026#39;col_0\u0026#39;:[1,2,3],\r\u0026#39;col_1\u0026#39;:list(\u0026#39;abc\u0026#39;),\r\u0026#39;col_2\u0026#39;:[1.2,2.2,3.2]},\rindex=[\u0026#39;row_0\u0026#39;,\u0026#39;row_1\u0026#39;,\u0026#39;row_2\u0026#39;])常用属性# df[[\u0026lsquo;col_0\u0026rsquo;,\u0026lsquo;col_1\u0026rsquo;]] 获取多列，返回新的 DataFrame\nprint(df[[\u0026#39;col_0\u0026#39;,\u0026#39;col_1\u0026#39;]])\r# 输出示例：\r# col_0 col_1\r# row_0 1 a\r# row_1 2 b\r# row_2 3 cdf.values 返回 DataFrame 的数据值（NumPy 数组形式，不包含列名和索引）\nprint(df.values)\r# 输出示例：\r# [[1 \u0026#39;a\u0026#39; 1.2]\r# [2 \u0026#39;b\u0026#39; 2.2]\r# [3 \u0026#39;c\u0026#39; 3.2]]df.index 返回 DataFrame 的行索引（Index 对象）\nprint(df.index)\r# 输出示例：\r# Index([\u0026#39;row_0\u0026#39;,\u0026#39;row_1\u0026#39;,\u0026#39;row_2\u0026#39;], dtype=\u0026#39;object\u0026#39;)df.dtypes 返回每列的数据类型（Series）\nprint(df.dtypes)\r# 输出示例：\r# col_0 int64\r# col_1 object\r# col_2 float64\r# dtype: objectdf.shape 返回 DataFrame 形状 (行数, 列数)\nprint(df.shape)\r# 输出示例：\r# (3, 3)df.T DataFrame 转置，行列互换\nprint(df.T)\r# 输出示例：\rrow_0 row_1 row_2\rcol_0 1 2 3\rcol_1 a b c\rcol_2 1.2 2.2 3.2三、常用基本函数# 创建 DataFrame：学生成绩数据\ndata = { \u0026#39;name\u0026#39;: [\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;, \u0026#39;赵六\u0026#39;, \u0026#39;陈七\u0026#39;, \u0026#39;张三\u0026#39;, \u0026#39;孙八\u0026#39;, \u0026#39;周九\u0026#39;], \u0026#39;class\u0026#39;: [\u0026#39;A班\u0026#39;, \u0026#39;B班\u0026#39;, \u0026#39;A班\u0026#39;, \u0026#39;B班\u0026#39;, \u0026#39;A班\u0026#39;, \u0026#39;A班\u0026#39;, \u0026#39;B班\u0026#39;, \u0026#39;A班\u0026#39;], \u0026#39;gender\u0026#39;: [\u0026#39;男\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;, \u0026#39;男\u0026#39;], \u0026#39;math\u0026#39;: [85, 92, 78, 96, 88, 85, 73, 90], \u0026#39;english\u0026#39;: [80, 85, 90, 75, 82, 80, 88, 86], \u0026#39;science\u0026#39;: [np.nan, 88, 85, 92, 78, 95, 80, 84], \u0026#39;city\u0026#39;: [\u0026#39;北京\u0026#39;, \u0026#39;上海\u0026#39;, \u0026#39;广州\u0026#39;, \u0026#39;深圳\u0026#39;, \u0026#39;北京\u0026#39;, \u0026#39;北京\u0026#39;, \u0026#39;杭州\u0026#39;, \u0026#39;深圳\u0026#39;] } df = pd.DataFrame(data)1.汇总函数（快速查看数据）# head(n) - 查看前 n 行 print(df.head(3)) tail(n) - 查看后 n 行 print(df.tail(2)) info() - 查看数据结构（列名、非空值、类型） df.info() describe() - 数值列的统计摘要 print(df.describe())2、特征统计函数（对数值列操作）# 选择数值列\rnumeric_cols = [\u0026#39;math\u0026#39;, \u0026#39;english\u0026#39;, \u0026#39;science\u0026#39;]\rsum: 求和\rprint(df[numeric_cols].sum())\rmean: 平均值\rprint(df[numeric_cols].mean())\rmedian: 中位数\rprint(df[numeric_cols].median())\rvar: 方差\rprint(df[numeric_cols].var())\rstd: 标准差\rprint(df[numeric_cols].std())\rmax/min: 最大最小值\rprint(df[numeric_cols].max())\rprint(df[numeric_cols].min())\rquantile: 分位数\rprint(\u0026#34;quantile(0.25):\\n\u0026#34;, df[numeric_cols].quantile(0.25))\rcount: 非空值数量（注意：science 少一个）\rprint(\u0026#34;count:\\n\u0026#34;, df[numeric_cols].count())\ridxmax: 最大值的索引位置\rprint(\u0026#34;idxmax (math 最高分是谁?):\\n\u0026#34;, df[\u0026#39;math\u0026#39;].idxmax())3、唯一值函数（处理分类 / 文本列）# unique: 返回唯一值（去重）\rprint(df[\u0026#39;gender\u0026#39;].unique())\rnunique: 唯一值个数\rprint(df[\u0026#39;class\u0026#39;].nunique())\rvalue_counts: 各值出现次数\rprint(df[\u0026#39;gender\u0026#39;].value_counts())\rduplicated: 返回每行是否是重复行\rprint(df.duplicated(subset=[\u0026#39;name\u0026#39;]))\rdrop_duplicates: 删除重复行\rdf_no_dup = df.drop_duplicates(subset=[\u0026#39;name\u0026#39;], keep=\u0026#39;first\u0026#39;)\rprint(df_no_dup[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;]])\rsubset = [\u0026#39;name\u0026#39;]表示按姓名去重，keep = \u0026#39;first\u0026#39;保留第一次出现的4、替换函数（replace）# 方法1：单值替换\ndf[\u0026#39;gender\u0026#39;] = df[\u0026#39;gender\u0026#39;].replace(\u0026#39;男\u0026#39;, \u0026#39;Male\u0026#39;)\rprint(\u0026#34;性别替换为英文:\\n\u0026#34;, df[[\u0026#39;name\u0026#39;, \u0026#39;gender\u0026#39;]])方法2：字典替换\ndf[\u0026#39;class\u0026#39;] = df[\u0026#39;class\u0026#39;].replace({\u0026#39;A班\u0026#39;: \u0026#39;Class A\u0026#39;, \u0026#39;B班\u0026#39;: \u0026#39;Class B\u0026#39;})\rprint(\u0026#34;班级替换:\\n\u0026#34;, df[[\u0026#39;name\u0026#39;, \u0026#39;class\u0026#39;]].head(3))方法3：用 np.nan 替换异常值\ndf[\u0026#39;math\u0026#39;] = df[\u0026#39;math\u0026#39;].replace(96, np.nan)\rprint(\u0026#34;数学96替换为NaN:\\n\u0026#34;, df[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;]].head(4))5、排序函数（Sorting）# sort_values()：按值排序 df_sorted = df.sort_values(by=\u0026#39;math\u0026#39;, ascending=False) print(df_sorted[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;]]) # 输出：赵六96 → 周九90 → 李四92 → ... print(\u0026#34;\\n2. 按多个列排序：先按班级，再按数学成绩降序：\u0026#34;) df_sorted2 = df.sort_values(by=[\u0026#39;class\u0026#39;, \u0026#39;math\u0026#39;], ascending=[True, False]) print(df_sorted2[[\u0026#39;name\u0026#39;, \u0026#39;class\u0026#39;, \u0026#39;math\u0026#39;]]) # 先排A班，数学高的在前；再排B班 print(\u0026#34;\\n3. 按姓名字符串排序（升序）：\u0026#34;) df_sorted_name = df.sort_values(by=\u0026#39;name\u0026#39;, ascending=True) print(df_sorted_name[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;]]) 中文按拼音排序：陈七 → 李四 → 孙八 → 王五 → 张三 → 赵六 → 周九2.sort_index()：按索引排序 # 打乱索引示例 df_shuffled = df.sample(frac=1) # 随机打乱行 print(\u0026#34;\\n打乱后：\u0026#34;) print(df_shuffled[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;]]) print(\u0026#34;\\n按索引排序恢复：\u0026#34;) df_restored = df_shuffled.sort_index() print(df_restored[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;]]) 适用于索引有序但被打乱的情况6、apply方法（数据转换利器）# apply可以对行、列、元素应用自定义函数。 1).对某一列使用apply\n示例：判断数学是否优秀\rdef is_good_math(score):\rreturn \u0026#39;优秀\u0026#39; if score \u0026gt;= 90 else \u0026#39;良好\u0026#39;\rdf[\u0026#39;math_level\u0026#39;] = df[\u0026#39;math\u0026#39;].apply(is_good_math)\rprint(df[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;, \u0026#39;math_level\u0026#39;]])\r示例：字符串处理（城市加“市”）\rdf[\u0026#39;city_full\u0026#39;] = df[\u0026#39;city\u0026#39;].apply(lambda x: x + \u0026#34;市\u0026#34;)\rprint(df[[\u0026#39;city\u0026#39;, \u0026#39;city_full\u0026#39;]])2).对多列使用\napply（axis = 1表示按行）\r示例1：计算总分（跳过NaN）\rdef calculate_total(row):\rreturn row[\u0026#39;math\u0026#39;] + row[\u0026#39;english\u0026#39;] + (row[\u0026#39;science\u0026#39;] if pd.notna(row[\u0026#39;science\u0026#39;]) else 0)\rdf[\u0026#39;total\u0026#39;] = df.apply(calculate_total, axis=1)\rprint(\u0026#34;\\n6. 每人总分：\u0026#34;)\rprint(df[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;, \u0026#39;english\u0026#39;, \u0026#39;science\u0026#39;, \u0026#39;total\u0026#39;]])示例2：计算总分后，生成评语\ndef get_comment(row):\rif row[\u0026#39;total\u0026#39;] \u0026gt; 250:\rreturn \u0026#34;优秀\u0026#34;\relif row[\u0026#39;total\u0026#39;] \u0026gt; 230:\rreturn \u0026#34;良好\u0026#34;\relse:\rreturn \u0026#34;加油\u0026#34;\rdf[\u0026#39;comment\u0026#39;] = df.apply(get_comment, axis=1)\rprint(\u0026#34;\\n7. 添加评语：\u0026#34;)\rprint(df[[\u0026#39;name\u0026#39;, \u0026#39;total\u0026#39;, \u0026#39;comment\u0026#39;]])3).对整个Series或DataFrame使用apply\n对多列同时 apply（比如标准化）\rprint(\u0026#34;\\n8. 数学成绩标准化（减均值除标准差）：\u0026#34;)\rmean = df[\u0026#39;math\u0026#39;].mean()\rstd = df[\u0026#39;math\u0026#39;].std()\rdf[\u0026#39;math_std\u0026#39;] = df[\u0026#39;math\u0026#39;].apply(lambda x: (x - mean) / std)\rprint(df[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;, \u0026#39;math_std\u0026#39;]].round(2))四、窗口函数（Window Functions）# Pandas 提供了 3 种窗口类型，常用于时间序列或顺序数据。我们先构造一个时间序列数据来演示：\n#创建时间序列数据：某产品每日销量 dates = pd.date_range(\u0026#39;2025-01-01\u0026#39;, periods=10) sales = [100, 120, 110, 130, 140, 135, 150, 160, 155, 170] df_ts = pd.DataFrame({\u0026#39;date\u0026#39;: dates, \u0026#39;sales\u0026#39;: sales}) df_ts.set_index(\u0026#39;date\u0026#39;, inplace=True) print(\u0026#34;时间序列数据:\u0026#34;) print(df_ts)滑动窗口# rolling()（最常用）计算固定窗口大小的统计值，如“过去3天的平均销量”。\n# 3日移动平均 df_ts[\u0026#39;ma_3\u0026#39;] = df_ts[\u0026#39;sales\u0026#39;].rolling(window=3).mean() print(\u0026#34;\\n1. 3日移动平均:\u0026#34;) print(df_ts[[\u0026#39;sales\u0026#39;, \u0026#39;ma_3\u0026#39;]]) 输出： sales ma_3 2025-01-01 100 NaN 2025-01-02 120 NaN 2025-01-03 110 110.000000 2025-01-04 130 120.000000 ... 前两行是 NaN，因为不够3个数据扩张窗口# expanding()\n#从开始到当前的所有数据进行计算，如“累计平均”。 #累计平均销量 df_ts[\u0026#39;expanding_mean\u0026#39;] = df_ts[\u0026#39;sales\u0026#39;].expanding().mean() print(\u0026#34;\\n2. 累计平均:\u0026#34;) print(df_ts[[\u0026#39;sales\u0026#39;, \u0026#39;expanding_mean\u0026#39;]]) #越往后，窗口越大，结果越稳定指数加权窗口：# ewm()（Exponentially Weighted）越近的数据权重越高，适合趋势预测。\n#指数加权移动平均（EWMA）\rdf_ts[\u0026#39;ewm_mean\u0026#39;] = df_ts[\u0026#39;sales\u0026#39;].ewm(alpha=0.3).mean()\rprint(\u0026#34;\\n3. 指数加权平均 (alpha=0.3):\u0026#34;)\rprint(df_ts[[\u0026#39;sales\u0026#39;, \u0026#39;ewm_mean\u0026#39;]])\ralpha 越大，越重视近期数据​\n"},{"id":23,"href":"/Python/Pyside/%E7%BE%8E%E5%8C%96%E7%95%8C%E9%9D%A2css/","title":"PySide美化界面","section":"Pyside-GUI开发","content":"美化界面：QSS# 类似 CSS，用于美化控件：\nbutton = QPushButton(\u0026#34;漂亮按钮\u0026#34;) button.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QPushButton { background-color: #4CAF50; color: white; border: none; padding: 10px; font-size: 16px; } QPushButton:hover { background-color: #45a049; } \u0026#34;\u0026#34;\u0026#34;)"},{"id":24,"href":"/Python/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A3%85%E9%A5%B0%E5%99%A8/","title":"Python函数","section":"Python基础知识","content":"global语句# name = {\u0026#34;name\u0026#34;: \u0026#34;zhangsan\u0026#34;} #修改全局 def func(): global name name = {\u0026#34;name\u0026#34;: \u0026#34;lisi\u0026#34;} # 相当于重新赋值，需要 global def foo(): name[\u0026#34;name\u0026#34;] = \u0026#34;lisi\u0026#34; # 当只改内容，不换对象时， 不需要 global也可以修改全局 如果只是改字典/列表的“内容”（如 d[\u0026ldquo;key\u0026rdquo;] = value） → 不需要 global，函数可以直接修改全局的字典 如果要重新赋值整个变量（如 name = {}） → 必须加 global name，否则 Python 会创建局部变量\n装饰器# 装饰器介绍# 本质 装饰器本质就是一个函数，返回一个新的函数。 它的核心目的是：不改原函数代码，就能增加新功能 代码对比 比喻：毛坯房vs精装房（装饰器==房子装修队）\n装饰器前（原函数）\ndef house(): print(\u0026#34;一个空的毛坯房，只有墙和门\u0026#34;)手动改造（麻烦）\ndef house(): print(\u0026#34;一个空的毛坯房，只有墙和门\u0026#34;) print(\u0026#34;装修队进场：铺地板、刷墙\u0026#34;) print(\u0026#34;家具进场：沙发、电视、冰箱\u0026#34;) #既破坏了原始函数，又不优雅。装饰器写法\ndef decorator_team(func): def decorated_house(): func() print(\u0026#34;装修队进场：铺地板、刷墙\u0026#34;) print(\u0026#34;家具进场：沙发、电视、冰箱\u0026#34;) return decorated_house # 返回精装房 #语法糖形式写法 @decorator_team def house(): print(\u0026#34;一个空的毛坯房，只有墙和门\u0026#34;) house() #下面等价于语法糖写法： def house(): print(\u0026#34;一个空的毛坯房，只有墙和门\u0026#34;) house = decorator_team(house) #开始装修！ #装修队decorator_team给毛坯房house装修！ #被装修的：house(原函数), #执行装修的：decorator_team(装饰器) #装修结果：decorated_house(新函数) house() # 谁在执行？ #你拿到是house已经是精装房了！因为 house现在指向的是decorated_house带参数的装饰器# 装修风格可以不同，比如豪华版、简约版。 这时装饰器需要 接受参数：\ndef decorator_team(style): #外层函数（接受参数）（豪华 / 简约 …） def wrapper(func): #中层（接受被装饰的函数） def decorated_house(): #内层（包装函数，执行逻辑） func() print(f\u0026#34;装修队进场：{style} 风格装修\u0026#34;) print(\u0026#34;家具进场：沙发、电视、冰箱\u0026#34;) return decorated_house return wrapper @decorator_team(\u0026#34;豪华\u0026#34;) def house(): print(\u0026#34;一个空的毛坯房，只有墙和门\u0026#34;) house()多层装饰器# 你可以叠加多个装修队：\ndef add_floor(func): def wrapper(): print(\u0026#34;加一层楼！\u0026#34;) func() return wrapper def add_garden(func): def wrapper(): func() print(\u0026#34;再加个花园！\u0026#34;) return wrapper @add_garden @add_floor def house(): print(\u0026#34;一个空的毛坯房，只有墙和门\u0026#34;) house() 输出\n加一层楼！ 一个空的毛坯房，只有墙和门 再加个花园！\n注册类装饰器# import PySimpleGUI as sg \u0026#34;\u0026#34;\u0026#34; 服务注册中心，类似微服务console/Nacos概念 \u0026#34;\u0026#34;\u0026#34; tasks = {} # 登记本：家务任务 -\u0026gt; 执行函数 def assign(task_name): \u0026#34;\u0026#34;\u0026#34;注册装饰器：登记谁负责做哪件家务\u0026#34;\u0026#34;\u0026#34; def decorator(func): tasks[task_name] = func print(f\u0026#34;[登记] 家务 \u0026#39;{task_name}\u0026#39; -\u0026gt; {func.__name__} 负责\u0026#34;) return func return decorator \u0026#34;\u0026#34;\u0026#34; 服务提供者 \u0026#34;\u0026#34;\u0026#34; # ----------------------------- # 定义家务（函数定义时自动登记） # ----------------------------- @assign(\u0026#34;洗碗\u0026#34;) def zhangsan(): sg.popup(\u0026#34;Zhangsan 在洗碗~\u0026#34;) @assign(\u0026#34;扫地\u0026#34;) def lisi(): sg.popup(\u0026#34;Lisi 在扫地~\u0026#34;) @assign(\u0026#34;倒垃圾\u0026#34;) def wangwu(): sg.popup(\u0026#34;Wangwu 在倒垃圾~\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 服务消费者 \u0026#34;\u0026#34;\u0026#34; # ----------------------------- # GUI 部分 # ----------------------------- layout = [ [sg.Text(\u0026#34;请选择要执行的家务:\u0026#34;)], [sg.Button(task) for task in tasks.keys()], [sg.Button(\u0026#34;退出\u0026#34;)] ] window = sg.Window(\u0026#34;家务执行器\u0026#34;, layout) while True: event, values = window.read() if event in (sg.WINDOW_CLOSED, \u0026#34;退出\u0026#34;): break if event in tasks: # 服务发现 tasks[event]() # 服务消费 window.close()类里使用装饰器# 装饰器只在这个类用，使用@staticmethod 定义在类内装饰器多个类要用定义在类外面（最清晰）\nclass MyCom: # 装修公司 @staticmethod def decorator_team(func): # func 是毛坯房（带 self 的方法） def decorated_house(*args, **kwargs): # 关键！接收所有参数 print(\u0026#34; 装修队进场：铺地板、刷墙\u0026#34;) result = func(*args, **kwargs) # 把 self 等原样传给原函数 print(\u0026#34; 家具进场：沙发、电视、冰箱\u0026#34;) return result return decorated_house @decorator_team def bare_house(self): print(\u0026#34; 一个空的毛坯房，只有墙和门\u0026#34;) # 测试 obj = MyCom() obj.bare_house()不加 @staticmethod，Python 会误以为这个装饰器是一个「普通方法」，而方法的第一个参数必须是 self。 但装饰器根本不需要 self！这就导致逻辑错乱。\n"},{"id":25,"href":"/Game/Yolo/YOLO%E6%A0%87%E6%B3%A8%E5%92%8C%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE/","title":"YOLO标注和训练数据","section":"Yolo","content":"数据准备# ├─data │ └─shubiao │ ├─images # 放所有待标注图片 │ └─labels # 标注生成的 YOLO txt 文件 #创建数据目录 ⚠️ 注意：路径不能包含中文或空格，否则 LabelImg 无法保存。 图片无需处理，直接进入标注阶段即可。 视频类型数据\n需要将视频抽帧为图片，再进行标注。 import cv2 import os video = cv2.VideoCapture(\u0026#34;./wendao.mkv\u0026#34;) num = 0 save_step = 30 # 每隔 30 帧保存一张 save_dir = \u0026#34;./data/shubiao/images/\u0026#34; os.makedirs(save_dir, exist_ok=True) while True: ret, frame = video.read() if not ret: break num += 1 if num % save_step == 0: cv2.imwrite(f\u0026#34;{save_dir}/{num}.bmp\u0026#34;, frame) video.release()标注工具# 标注工具LabelImg LabelImg 是一款常用的图像标注工具，可输出以下格式： Pascal VOC（.xml） YOLO（.txt）CreateML（.json） 在线标注工具 https://www.makesense.ai/ 中文版：http://makesense.bimant.com/ 常用公开数据集 https://public.roboflow.com/object-detection 安装LabelImg# 方式一：Python 环境\npip install labelimg -i https://pypi.tuna.tsinghua.edu.cn/simple\rlabelimg方式二：无 Python 环境\n下载 Windows/Linux 版本可执行文件，直接运行：\nGitHub Releases\nLabelImg 界面功能说明\n按钮 功能 Open 打开单张图片 Open Dir 打开整个图片文件夹 Change Save Dir 设置标注文件保存路径 Next Image 下一张图片 Prev Image 上一张图片 Verify Image 校验图片 Save 保存标注 Create RectBox 绘制矩形标注框 Duplicate RectBox 复制已有标注框 Delete RectBox 删除当前标注框 Zoom In 放大 Zoom Out 缩小 Fit Window 自适应窗口 Fit Width 宽度适配 LabelImg 快捷键列表\n快捷键 功能 快捷键 功能 Ctrl + Q 退出软件 Ctrl + + 放大 Ctrl + U Open Dir Ctrl + = 原始大小 Ctrl + R Change Save Dir Ctrl + F 图像适应窗口 Ctrl + S 保存图像 Ctrl + E 编辑标签 Ctrl + L 线框颜色 W 画框 Ctrl + J 移动编辑标注框 Delete 删除框 Ctrl + D 复制框 Ctrl + Shift + F 图像适应宽度 Ctrl + H 隐藏所有的框 D Next Image Ctrl + A 显示所有的框 A Prev Image Space 标记当前图片已标记 Ctrl + Shift + O 打开的文件夹只显示 .xml 文件 LabelImg 数据标注流程# 打开 LabelImg 并设置保存路径# 点击 Open Dir → 选择 dataset/images 点击 Change Save Dir → 选择 dataset/labels 在右侧选择标注格式： YOLO（推荐） PascalVOC（XML） 开始标注图片# 按 W 或点击 Create RectBox 进入画框模式 鼠标拖动框选目标 松开后弹出类别选择窗口 → 配置类别 点击 Next Image 切换下一张 保存标注# 如果未开启自动保存，每张图片标注完成后需要点击 Save 生成的 txt 文件出现在：./data/shubiao//labels/xxx.txt 开启自动保存（强烈推荐） 路径：Menu → View → Auto Save Mode 开启后：\n每画一个框 每修改一个框 每切换一张图都会自动保存标注文件，无需再点击 Save。 标注结束后验证目录# 最终数据应如下：\n./data/shubiao/ ├── images/ │ ├── 001.jpg │ ├── 002.jpg │ └── ... └── labels/ ├── 001.txt ├── 002.txt └── classes.txt 确保： - 图片与标注文件一一对应 - 文件名一致 - txt 内容符合 YOLO 格式训练数据# 标注结束后划分 train/val# Python 自动划分脚本 下面示例按 80% 训练 / 20% 验证 划分：\n脚本放在dataset同级目录\nimport os import shutil import random # 原始路径 images_dir = \u0026#34;./data/shubiao/images\u0026#34; labels_dir = \u0026#34;./data/shubiao/labels\u0026#34; # 目标路径 train_images = \u0026#34;./data/shubiao/train/images\u0026#34; train_labels = \u0026#34;./data/shubiao/train/labels\u0026#34; val_images = \u0026#34;./data/shubiao/val/images\u0026#34; val_labels = \u0026#34;./data/shubiao/val/labels\u0026#34; # 创建目录 for path in [train_images, train_labels, val_images, val_labels]: os.makedirs(path, exist_ok=True) # 获取所有图片 images = [f for f in os.listdir(images_dir) if f.endswith(\u0026#34;.bmp\u0026#34;) or f.endswith(\u0026#34;.bmp\u0026#34;)] images.sort() # 保持顺序，可选 # 打乱顺序 random.shuffle(images) # 划分比例 train_ratio = 0.8 train_count = int(len(images) * train_ratio) train_files = images[:train_count] val_files = images[train_count:] # 复制训练集 for f in train_files: shutil.copy(os.path.join(images_dir, f), train_images) txt_file = f.replace(\u0026#34;.jpg\u0026#34;, \u0026#34;.txt\u0026#34;).replace(\u0026#34;.bmp\u0026#34;, \u0026#34;.txt\u0026#34;) shutil.copy(os.path.join(labels_dir, txt_file), train_labels) # 复制验证集 for f in val_files: shutil.copy(os.path.join(images_dir, f), val_images) txt_file = f.replace(\u0026#34;.jpg\u0026#34;, \u0026#34;.txt\u0026#34;).replace(\u0026#34;.bmp\u0026#34;, \u0026#34;.txt\u0026#34;) shutil.copy(os.path.join(labels_dir, txt_file), val_labels) print(f\u0026#34;训练集: {len(train_files)} 张图片\u0026#34;) print(f\u0026#34;验证集: {len(val_files)} 张图片\u0026#34;)生成 dataset.yaml# # dataset.yaml path: ./dataset train: train/images val: val/images # 类别数 nc: 1 # 类别名称 names: [\u0026#39;gamer\u0026#39;]最终目录结构# ./data/shubiao/ ├── images/ # 原始所有图片 ├── labels/ # 原始所有标注 ├── train/ │ ├── images/ │ └── labels/ └── val/ ├── images/ └── labels/ shubiao.yaml # YOLO 训练配置文件 放到data目录下训练# from ultralytics import YOLOv10 if __name__ == \u0026#34;__main__\u0026#34;: model_yaml_path = \u0026#34;ultralytics\\\\cfg\\\\models\\\\v10\\\\yolov10n.yaml\u0026#34; model = YOLOv10(model_yaml_path).load(\u0026#34;yolov10n.pt\u0026#34;) data_path = \u0026#39;.\\\\data\\\\shubiao.yaml\u0026#39; results = model.train( data=data_path, imgsz=640, epochs=50, batch=1, workers=0, device=\u0026#39;0\u0026#39; )参数： task=detect ：目标检测 mode=train ：训练模式 model=yolov8s.pt ：使用预训练的 yolov8 small data ：数据集 yaml 文件 epochs ：训练轮数 batch ：batch 大小\n训练输出说明\n/runs/detect ├── weights/ │ ├── best.pt # 最佳权重 │ └── last.pt # 最后轮权重 ├── results.png # 精度曲线 └── events.out.tfevents.xxx\n推理# from ultralytics import YOLOv10 model = YOLOv10(\u0026#39;best.pt\u0026#39;) model.predict(source=r\u0026#39;D:\\PyProject\\yolov10-main\\data\\shubiao\\val\\images\u0026#39;,save=True)导出onnx# from ultralytics import YOLOv10 # 加载需要导出的模型 model = YOLOv10(\u0026#39;best.pt\u0026#39;) # 导出ONNX模型 model.export( format=\u0026#39;onnx\u0026#39;, # 指定导出格式为ONNX imgsz=640, # 输入图像尺寸 (训练默认640x640) opset=17, # ONNX算子集版本 (推荐12-18) simplify=True, # 启用模型简化 (强烈推荐) dynamic=True, # 允许动态输入尺寸 (可选) batch=1, # 批次大小 (默认1) device=\u0026#39;cpu\u0026#39;, # 使用CPU导出 (避免CUDA兼容性问题) half=False, # 禁用FP16 (避免某些设备兼容性问题) workspace=4, # TensorRT工作空间大小 (GB), ONNX导出可忽略 )常见问题：\n调整数据集目录后再次训练 需要线删除~/AppData/Roaming/Ultralytics文件夹下的settings.yaml\n"},{"id":26,"href":"/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/03.%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/","title":"03.逻辑运算","section":"逆向初级","content":"逻辑运算的引入# 如果现在只是将数据存到计算机的容器中，是没有任何意义的，我们还需要告诉计算机这些数据有什么用，让计算机对这些数做运算。所以我们知道计算机到底是如何做运算的，所以我们引入逻辑运算\n逻辑运算# 由于计算机受硬件的限制影响，CPU再复杂可以理解为一条条的线路组成的，而电信号只有两种形式0和1，所以一般计算机的逻辑运算的对象都是二进制数\n逻辑运算分为：\n逻辑运算 汇编符号 C语言符号 口诀 与 AND \u0026amp; 有0则0，全1才1 或 OR ` ` 异或 XOR ^ 相同为0，相异为1 非 NOT ! 或 ~ 0变1，1变0 CPU是如何计算2+3# 初始数据（二进制表示） x = 2，二进制表示：0010 y = 3，二进制表示：0011\n0010\txor 0011\r------------\r0001 R:0001\r0010\rand 0011\r------------\r0010 \u0026lt;\u0026lt;1 得 0100 #\u0026lt;\u0026lt;1表示左移一位\r此时计算机会判断0100是否全为0,如果全为0表示运算结束,将R中此时的值作为结果输出,如果不为0则将R中的值赋给x。0100赋给y再做一次同样运算\r0001\rxor 0100\r-------------\r0101 R:0101\r0001\rand 0100\r-------------\r0000 \u0026lt;\u0026lt;1 得 0000\r判断0000全为0,则运算结束,将R中的值0101作为运算的结果,化成十进制即为5总结\n这个过程模拟了 加法运算，通过 XOR 来计算和，使用 AND 来计算进位，然后通过 左移 来处理进位，最终得到结果 5。\n计算3-2# x = 3 → 二进制：0000 0011 y = 2 → 二进制：0000 0010\n-2 的补码：\n原码：0000 0010 反码：1111 1101 补码：1111 1110 补码0000 0010-\u0026gt;1111 1101-\u0026gt;1111 1110\r##############第一次运算\r0000 0011\r1111 1110 xor\r----------\r1111 1101 R:1111 1101\r0000 0011\r1111 1110 and\r----------\r0000 0100 \u0026lt;\u0026lt;进位1 得0000 0100\r更新变量： x = 1111 1101\ry = 0000 0100\r##############第二次运算\r1111 1101\r0000 0100 xor\r----------\r1111 1001 R:1111 1001\r1111 1101\r0000 0100 and\r----------\r0000 0100 \u0026lt;\u0026lt;进位1 得0000 1000\r更新变量： x = 1111 1001\ry = 0000 1000\r###############第三次运算\r1111 1001\r0000 1000 xor\r-------------\r1111 0001 R:1111 0001\r1111 1001\r0000 1000 and\r--------------\r0000 1000 进位0001 0000\r更新变量： x = 1111 0001\ry = 0001 0000\r############第四次运算\r1111 0001\r0001 0000 xor\r-------------\r1110 0001 R:1110 0001\r1111 0001\r0001 0000 and\r-------------\r0001 0000 进位0010 0000\r更新变量： x = 1110 0001\ry = 0010 0000\r############第五次运算\r1110 0001\r0010 0000 xor\r-------------\r1100 0001 R:1100 0001\r1110 0001\r0010 0000 and\r-------------\r0010 0001 进位0100 0001\r更新变量： x = 1100 0001\ry = 0100 0001\r############第六次运算\r1100 0001\r0100 0001 xor\r-------------\r1000 0001 R:1000 0001\r1100 0001\r0100 0001 and\r-------------\r0100 0001 进位1000 0001\r更新变量： x = 1000 0001\ry = 1000 0001\r#########第七次运算\r1000 0001\r1000 0001 xor\r-------------\r0000 0000 R:1000 0001\r1000 0001\r1000 0001 and\r-------------\r0000 0000 进位00000 0000计算2-3# x=2 y=3 0000 0010\r1111 1101 xor\r-------------\r1111 1111\r0000 0010\r1111 1101 and\r-------------\r0000 0000\r1111 1111\r取反 → 加1 → 得正数 → 加负号\r0000 0000 0000 0001\r-1如何获取某个值的第N位是0还是1# 比如现在某个寄存器中存了一个值，值化成二进制时，有些特殊的值每一位都有它的特殊含义，所以我们想要知道这个值的第N位是0还是1。如果我们把寄存器中的值取出来，一个一个数着看，就会很麻烦，但是如果做下面的运算，就会容易很多\n#现在想要查看某寄存器中的值的第4位是0还是1,我们就可以将寄存器中的值与0x08做与运算，如果得到结果中有一个1,则这个值的第四位就是1，如果结果全是0，则值的第四位就是0\n10001111\rand\t00001000\r​\t00001000用异或做加密解密# 如果进行简单的加密，可以使用亦或运算，因为选择一个双方都知道密钥，用此密钥与数据做亦或加密加密过后，别人如果没有密钥则不好解开这个密文，而对于接受方，使用相同的密钥再做一次亦或即可得到原来的明文值\n要加密的数据:2015\t00100000\t00010101\r^\t01010100\t^\t01010100\r------------ ------------\r密钥:54\t01110100\t01000001\r加密后的结果：\t74\t41\r01110100\t01000001\r^\t01010100\t^ 01010100\r------------- ------------\r00100000\t00010101\r解密后的结果：\t20\t15"},{"id":27,"href":"/Python/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/MinGit%E4%BD%BF%E7%94%A8/","title":"MinGit使用","section":"其它知识","content":"Git介绍# Git是一个源代码管理工具，可以恢复退回任意一个版本，git具备以下特征：\n分布式，远端仓库和自己的本地仓库是一样的，哪个挂了都不影响，除非都挂了\r轻量简单，每次修改只记录修改内容，不会记录文件本身，不用担心文件量太多\r无网络情况可本地提交，本地管理，有网络再提交给远程仓库\r可视化查看修改记录，知道版本之间改了啥\r支持仓库项目管理，bug追踪，项目跟进\rIDE支持情况好\r安装git# 使用MinGit即可，下载 MinGit 解压到本地，如：D:\\Program Files (x86)\\MinGit 然后把这个路径加入到系统环境变量，D:\\Program Files (x86)\\MinGit\\mingw64\\bin\n定义用户名和邮箱\n#用户名和gitblit平台名字一致 git config --global user.name \u0026#34;wangc\u0026#34; git config --global user.email wangc@example.com获取仓库\ngit clone http://xxx.git #提交代码 git add --all git commit -m \u0026#34;init:初始化项目文件\u0026#34; git push 记住密码 git config --global credential.helper store"},{"id":28,"href":"/Python/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/2.Pandas%E7%B4%A2%E5%BC%95/","title":"Pandas索引","section":"Python数据处理","content":"一、索引器（Indexers）# Pandas 提供了多种方式来访问数据：\nloc ：基于标签（label）索引 iloc ：基于整数位置（position）索引 at ：快速标签访问单个标量 iat ：快速位置访问单个标量 示例\nimport pandas as pd df = pd.DataFrame({ \u0026#34;A\u0026#34;: [1, 2, 3], \u0026#34;B\u0026#34;: [4, 5, 6] }, index=[\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;]) print(df.loc[\u0026#34;x\u0026#34;, \u0026#34;A\u0026#34;]) # 标签索引 → 1 print(df.iloc[0, 0]) # 位置索引 → 1 print(df.at[\u0026#34;y\u0026#34;, \u0026#34;B\u0026#34;]) # 快速标签取值 → 5 print(df.iat[2, 1]) # 快速位置取值 → 6二、单级索引（普通 Index）# df.index ：索引对象\ndf.columns ：列索引\ndf.reset_index() ：恢复为普通列\ndf.set_index(\u0026quot;col\u0026quot;) ：设置某列为索引\ndf = pd.DataFrame({ \u0026#34;id\u0026#34;: [101, 102, 103], \u0026#34;name\u0026#34;: [\u0026#34;Tom\u0026#34;, \u0026#34;Jerry\u0026#34;, \u0026#34;Anna\u0026#34;] }) df2 = df.set_index(\u0026#34;id\u0026#34;) print(df2) print(df2.index) # Index([101, 102, 103], dtype=\u0026#34;int64\u0026#34;)三、多级索引（MultiIndex）# 多级索引（层次化索引）用于表示分层的数据结构，可以应用于 行 或 列。\n1. 创建多级索引# arrays = [\r[\u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;],\r[1, 2, 1, 2]\r]\rindex = pd.MultiIndex.from_arrays(arrays, names=(\u0026#34;level1\u0026#34;, \u0026#34;level2\u0026#34;))\rdf = pd.DataFrame({\u0026#34;value\u0026#34;: [10, 20, 30, 40]}, index=index)\rprint(df)输出\nlevel1 level2 value\ra 1 10\r2 20\rb 1 30\r2 402. 多级索引取值# print(df.loc[\u0026#34;a\u0026#34;]) # 取 level1 = \u0026#34;a\u0026#34;\rprint(df.loc[(\u0026#34;b\u0026#34;, 1)]) # 取 level1=\u0026#34;b\u0026#34; 且 level2=1\rprint(df.loc[(\u0026#34;a\u0026#34;, slice(None))]) # 取 level1=\u0026#34;a\u0026#34; 所有值四、多级索引常用操作# 查看层级名称\nprint(df.index.names) # [\u0026#39;level1\u0026#39;, \u0026#39;level2\u0026#39;] 交换层级顺序\nprint(df.swaplevel()) 按索引排序\nprint(df.sort_index(level=0)) # 按第0层排序 恢复普通列\nprint(df.reset_index()) 📌 总结：\nloc / iloc / at / iat → 数据访问方式 单级索引适合一维标签，set_index / reset_index 转换灵活 多级索引能表示层级关系，常见于透视表、分组结果 常用操作有 swaplevel、sort_index、reset_index "},{"id":29,"href":"/Python/Pyside/%E4%BF%A1%E5%8F%B7%E6%A7%BD%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"PySide信号槽与多线程","section":"Pyside-GUI开发","content":"一、 信号\u0026amp;槽（Signals \u0026amp; Slots）# 1.信号（Signal）和槽（Slot）概念\n信号（Signal）\n表示“发生了什么事”（如：按钮被点击、文本发生变化）\n槽（Slot）\n表示“当事件发生时要执行的动作”（如：打印日志、更新界面）\n可以理解为：\n信号 = 广播消息\n槽 = 监听并响应消息的函数\n2.PyQt/PySide 与 PySimpleGUI 事件处理机制对比\n控件事件触发方式 框架 如何标识控件 如何响应事件 是否需要主循环 PySimpleGUI 通过 key=\u0026quot;xxx\u0026quot; 字符串标识（如 sg.Button(\u0026quot;OK\u0026quot;, key=\u0026quot;-OK-\u0026quot;)） 在 while True 循环中判断 event == \u0026quot;-OK-\u0026quot; ✅ 必须显式编写 while 事件读取循环 PyQt / PySide 控件本身就是对象（如 self.btn = QPushButton(\u0026quot;OK\u0026quot;)） 直接连接对象的内置信号：self.btn.clicked.connect(self.handler) ❌ 不需要；由 QApplication.exec_() 启动 Qt 内置事件循环 3.PyQt/PySide 标准控件自带信号示例 QtWidgets依赖QtGui \u0026ndash;\u0026gt; QtGui依赖QtCore \u0026ndash;\u0026gt; 因此使用 QtWidgets 时，自动获得了 QtGui 和 QtCore 的能力（如信号槽） 所以QtWidgets下面的控件内置了信号槽能力\n控件类型 常用内置信号 触发时机 QPushButton clicked() 用户点击按钮 QLineEdit textChanged(str)\nreturnPressed() 文本内容变化\n用户按下回车 QComboBox currentIndexChanged(int)\ncurrentTextChanged(str) 选中项索引改变\n选中项文本改变 QCheckBox toggled(bool)\nstateChanged(int) 勾选状态切换\n状态值变化（0/1/2） QRadioButton toggled(bool) 选中或取消选中 QSlider valueChanged(int) 滑块值变化 QTimer timeout() 定时器超时 QThread started()\nfinished() 线程启动\n线程执行结束 4.关键结论\n所有标准控件都自带信号\n只有在以下情况才需要自定义信号： 自己写控件类 子线程需要向 UI 传递业务数据 槽必须是 可调用对象 函数 / 方法 / lambda 槽对象必须被持有引用\n否则可能被 GC 回收，导致信号失效 ✔ 一个信号可以连接多个槽\n✔ 一个槽也可以监听多个信号\n5.基础示例（单线程）\nfrom PySide2.QtWidgets import QApplication, QWidget, QPushButton, QVBoxLayout import sys class MainWindow(QWidget): def __init__(self): super().__init__() # 窗口设置 self.setWindowTitle(\u0026#34;信号与槽示例\u0026#34;) # 创建控件 self.button = QPushButton(\u0026#34;点我\u0026#34;) # 布局 layout = QVBoxLayout(self) layout.addWidget(self.button) # 信号绑定 self.button.clicked.connect(self.on_button_clicked) # 槽函数（类方法） def on_button_clicked(self): print(\u0026#34;按钮被点击了！\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: app = QApplication(sys.argv) window = MainWindow() window.show() sys.exit(app.exec_())二、自定义信号槽与多线程# PySide2 / PyQt 中的多线程与信号机制# 1.在 PySide2 / PyQt 的 GUI 编程中， 多线程几乎总是要配合自定义信号（Signal）使用， 才能 安全、可靠 地实现子线程与主线程（UI）的通信。这是因为 Qt 有两条“铁律”。\n所有 UI 操作必须在主线程执行\n否则属于未定义行为，可能直接崩溃。 不同线程之间不能直接操作对方的对象\n包括调用方法、访问属性，都是非线程安全的。 2、多线程的真实目的\n在 子线程 执行耗时任务\n（如：下载、计算、读文件等） 在 任务完成后通知 UI 更新\n（显示结果、更新进度条、启用按钮等） 这就不可避免地产生了 跨线程通信需求。\n3.Qt 官方唯一安全的跨线程通信方式\n信号 / 槽（Signal / Slot）机制\n信号可以在 子线程发出 槽函数在 主线程执行 通过 信号参数传递数据 自动使用 队列连接（Queued Connection） 线程安全 4.为什么必须自定义信号？\nQt 没有提供通用的内置信号\n用于传递你的业务数据，例如：\nint：进度值 str：结果文本 list：计算数据 只要子线程需要向 UI 传递数据，\n就必须自定义信号。\n5.总结\nQt 多线程的正确模式：\n子线程做耗时工作 → 发信号 → 主线程更新 UI\nfrom PySide2.QtCore import QThread, Signal from PySide2.QtWidgets import ( QApplication, QLabel, QWidget, QVBoxLayout, QPushButton ) import time \u0026#34;\u0026#34;\u0026#34; 模拟快递员会将包裹放到快递驿站，然后由机器人送到家 机器人：Signal定义信号 + emit 发射信号（信号本身是广播式的，谁连了谁就能收到） 家(主界面)：connect(订阅信号)+绑定响应动作(槽) + 更新显示器(界面) ################################## Qt 信号槽心法”： 信号是广播，槽是听众 子线程只“说”，不“改 UI” 主线程负责“听”和“显示” \u0026#34;\u0026#34;\u0026#34; # 快递机器人 class DeliveryBot(QThread): # -----------------------------------第一步：自定义信号和工作线程------------------------------------ # 【0】机器人出厂自带“按门铃”的能力（定义信号） update_signal = Signal(str) # 门铃只能传递一句话，比如“1号包裹到了” # 【5】机器人开始送货（工作线程） def run(self): for pkg in range(1, 6): time.sleep(1) # 走路上楼需要时间（模拟耗时任务） message = f\u0026#34; 第{pkg}个包裹已送到门口！\u0026#34; self.update_signal.emit(message) # 【6】按你家门铃！（发射信号） # 家（主界面） class MyGui(QWidget): def __init__(self): super().__init__() # 显示器：显示快递状态 和 一个“叫机器人送到家”按钮 self.notebook = QLabel(\u0026#34;快件已到驿站，等待派送...\u0026#34;) self.call_button = QPushButton(\u0026#34;呼叫送货机器人\u0026#34;) layout = QVBoxLayout() layout.addWidget(self.notebook) layout.addWidget(self.call_button) self.setLayout(layout) #-----------------------------------第二步：信号绑定到槽------------------------------------ # 【1】预约一个快递机器人：该机器人内置了信号 self.worker = DeliveryBot() # 【2】【worker信号发送者】+【update_signal信号名称】+[connect订阅该信号]+[绑定响应动作(槽)] self.worker.update_signal.connect(self.hear_doorbell) # 【3】设置按钮：点一下机器人出发， # 【call_button信号发送者】+【clicked信号名称】+【connect订阅该信号】+【绑定响应动作(槽)】 # clicked 是 QPushButton 内置信号，你同样用 connect 订阅它。 self.call_button.clicked.connect(self.send_bot) #-----------------------------------第三步：让线程开始工作，并发送信号------------------------------------ # 【4】你按下按钮（在主线程中） def send_bot(self): self.notebook.setText(\u0026#34; 机器人已出发...\u0026#34;) self.call_button.setEnabled(False) self.worker.start() # 机器人开始后台送货！ #-----------------------------------第四步：处理接收到的信号------------------------------------ # 【7】你听到门铃响（槽函数）→ 更新显示器（在主线程！） def hear_doorbell(self, message): self.notebook.setText(message) # 启动整个系统 if __name__ == \u0026#34;__main__\u0026#34;: app = QApplication([]) home = MyGui() home.show() app.exec_()"},{"id":30,"href":"/Other/%E5%A6%82%E4%BD%95%E7%BB%84%E8%A3%85%E4%B8%80%E5%8F%B0%E4%B8%BB%E6%9C%BA/","title":"志强平台装机流程","section":"Other","content":"1️⃣ 先定 CPU# E3 平台# E3 v1 / v2：LGA1155 → H61 / B75 / Z77（需 BIOS 支持） E3 v3 / v4：LGA1150 → 部分 B85 / Z87 / Z97 支持（看主板） E3 v5 / v6：仅支持 C232 / C236 工作站主板 Intel 为区分平台、保护 i7，不再放行消费级主板\nE5 平台（不可混用）# E5 v1 / v2：LGA2011 → X79 E5 v3 / v4：LGA2011-3 → X99 2️⃣ 内存类型# E5 v3：官方仅支持 DDR4\n（国产魔改板可上 DDR3，属非官方方案） E5 v4：仅支持 DDR4（DDR3 极不稳定，不推荐） E3 v3：仅 DDR3 E3 v5/v6：仅 DDR4 👉 建议先查 DDR3 / DDR4 价格 再决定平台\n3️⃣ 鸡血支持# E5 v3：可降微码鸡血（全核睿频） E5 v4：架构与微码限制，无法稳定鸡血 4️⃣ 选择主板要点# 插槽：LGA2011 / LGA2011-3 必须匹配 CPU 芯片组：优先 C612 / C610 B85 / H81 / HM55 多为魔改芯片 内存类型：DDR3 / DDR4 必须与主板版本一致 供电相数：4+2 \u0026lt; 6+2 \u0026lt; 8+2，越多越稳 5️⃣ 原厂服务器主板 vs 国产 X79 / X99# 原厂服务器主板问题：\nBIOS 锁死，仅认特定 CPU / 内存 强制 ECC REG 无视频 / 音频输出 机箱、电源不通用 国产 X79 / X99 优势：\n支持普通 DDR3 / DDR4 BIOS 开放，可鸡血 USB / M.2 / HDMI / 音频直出 更适合个人多开 / 渲染 / NAS 国产主板本质 = 自主 PCB + 拆机芯片 + 魔改 BIOS\n6️⃣ 最后选硬盘# 看是否支持 M.2 再决定 SATA / NVMe 硬盘属于外设，永远最后买，随时可升级 总结# 志强平台 = CPU（代数） + 主板（插槽） + 内存（类型）\n三者必须完全匹配；\n硬盘只是接口问题，不影响平台选择。\n"},{"id":31,"href":"/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/04.%E5%AF%84%E5%AD%98%E5%99%A8/","title":"04.寄存器","section":"逆向初级","content":"寄存器# 寄存器的基本概念# 计算机存储数据的地方，有三个地方：CPU \u0026gt; 内存 \u0026gt; 硬盘 其中，寄存器是指 CPU 内部用来存储数据的高速存储单元。 如果你使用的是一个 32 位的 CPU，那么它能提供的寄存器通常有：8 位、16 位、32 位的访问形式。\n通用寄存器# 在 CPU 里面，寄存器分很多类：\n通用寄存器（General Purpose Register, GPR） → 可以存数据、存地址、存中间运算结果，用途比较广。 专用寄存器 → 有固定功能，不能随便用，比如： EIP：指令指针寄存器，存放下一条要执行指令的地址 EFLAGS：标志寄存器，存放运算结果的标志位（零/进位/溢出等） 段寄存器：负责内存分段管理 因为通用寄存器不像 EIP、EFLAGS 那样被“锁死”在某个功能上，而是灵活多用，所以才叫 通用。\nx86 架构中的 32 位通用寄存器# 在 32 位 CPU 中，常见的通用寄存器有 8 个：\n寄存器 编号 存储数据范围 EAX 0 0 - 0xFFFFFFFF ECX 1 0 - 0xFFFFFFFF EDX 2 0 - 0xFFFFFFFF EBX 3 0 - 0xFFFFFFFF ESP 4 0 - 0xFFFFFFFF EBP 5 0 - 0xFFFFFFFF ESI 6 0 - 0xFFFFFFFF EDI 7 0 - 0xFFFFFFFF 每个寄存器都是独立的存储单元 每个寄存器固定大小：32 位 → 4 字节 它们可以同时存储不同的数据，互不干扰，EAX 装的数据不会“占用” EBX、ECX 的空间。 虽然名字上都算“通用寄存器”，但在实际编程时它们会有习惯性用途：虽然名字上都叫“通用寄存器”，但在实际编程时，它们往往有习惯性用途：\nEAX：累加器（运算结果常放在这） ECX：计数器（循环次数常放这） EDX：数据寄存器（扩展乘除法时存高位） EBX：基址寄存器（有时存地址） ESI / EDI：源地址 / 目的地址寄存器（字符串操作常用） ESP / EBP：与栈相关（函数调用时常用） 但这些用途不是强制的，编译器或程序员完全可以把它们当普通存储单元来使用。\n子寄存器# 1.子寄存器概念\n一个寄存器内部可以继续拆分成更小的“子寄存器”。\nEAX (32位) = 0x12345678\r├── 高16位 = 0x1234 ← 没有专门的寄存器名\r└── AX (低16位) = 0x5678\r├── AH (高8位) = 0x56\r└── AL (低8位) = 0x78 修改 AL → AX / EAX 的低 8 位会被改变 修改 AX → EAX 的低 16 位会被改变 修改 EAX → 整个 32 位寄存器会被改变 这些修改不会影响其他寄存器（如 EBX、ECX） 可以在OllyDbg上验证： MOV EAX,0xAAAAAAAA\tMOV AX,0xBBBB\tMOV AH,0xCC\tMOV AL,0xDD\t2.子寄存器存在的原因\n兼容历史 x86 架构从 **8 位 → 16 位 → 32 位 ** 逐步演进。 为了让早期程序在新 CPU 上仍能运行，Intel 保留了子寄存器的访问方式。 灵活性 有时候只需要处理 1 字节（8 位）或 2 字节（16 位）的数据，直接用子寄存器效率更高，不必操作整个32位寄存器。 32位寄存器 16位子寄存器 有无8位子寄存器 高8位 低8位 示例值（32/16/8位） 编号（二进制/十进制） EAX AX ✅ AH AL 0x12345678 / 0x5678 / 0x56/0x78 000 / 0 ECX CX ✅ CH CL 0x12345678 / 0x5678 / 0x56/0x78 001 / 1 EDX DX ✅ DH DL 0x12345678 / 0x5678 / 0x56/0x78 010 / 2 EBX BX ✅ BH BL 0x12345678 / 0x5678 / 0x56/0x78 011 / 3 ESP SP ❌ — — 0x12345678 / 0x5678 / — 100 / 4 EBP BP ❌ — — 0x12345678 / 0x5678 / — 101 / 5 ESI SI ❌ — — 0x12345678 / 0x5678 / — 110 / 6 EDI DI ❌ — — 0x12345678 / 0x5678 / — 111 / 7 认识OllyDbg# 按F3打开一个EXE程序# 修改寄存器中值# 如何自己写汇编指令，双击程序正在执行的地址那一行的指令，可以新添加指令或者修改指令，最后按Assemble添加或修改成功。添加或修改后，这条指令会作为程序即将执行的指令，当按F8时，程序会执行你新添加的指令，添加多条，会依次向下覆盖，程序执行处在第一条你新添加的指令地址处\n注意因为寄存器是32位的，所以如果地址数值大于了32位，即会从低位取32位，多余的位将被丢弃MOV EAX,123456789 #会变成23456789\nMOV EAX,12345678 #MOV是汇编指令，EAX是寄存器，后面的数叫立即数，此指令的作用就是将立即数存在EAX中\rADD EAX,1 #将1与EAX中已经存储的数做加法运算，结果再存储在EAX中\rMOV ECX,2\rADD EAX,ECX #将EAX与ECX中的值相加，将结果再放入EAX中\rSUB EAX,3 #用EAX中的值-3，再将结果放入EAX中\n汇编指令# 指令作用与操作数表# 指令 作用 目标操作数 源操作数 宽度要求 MOV 复制数据不改变源 寄存器/内存 寄存器/内存/立即数 必须一致（短补零，长截断） ADD 相加并存回目标 寄存器/内存 寄存器/内存/立即数 源可与目标宽度不一致（立即数可不同） SUB 相减并存回目标 寄存器/内存 寄存器/内存/立即数 源可与目标宽度不一致（立即数可不同） AND 与 → 存回目标 寄存器/内存 寄存器/内存/立即数 源可与目标宽度不一致（立即数可不同） OR 或 → 存回目标 寄存器/内存 寄存器/内存/立即数 源可与目标宽度不一致（立即数可不同） XOR 异或 → 存回目标 寄存器/内存 寄存器/内存/立即数 源可与目标宽度不一致（立即数可不同） NOT 非 → 存回操作数 寄存器/内存 — 单操作数 常用语法示例# MOV（数据传送）# # 语法：MOV r32, imm32\r# EAX = 0x12345678\rMOV EAX, 0x12345678\r# 结果 EAX = 0x12345678\r# 语法：MOV r32, r32/m32\r# EBX = EAX\rMOV EBX, EAX\r# 结果 EBX = 0x12345678\r# 语法：MOV r32, r32/m32\r# ECX = [0x00400000]（假设内存值=0x10）\rMOV ECX, [0x00400000]\r# 结果 ECX = 0x10\r# 语法：MOV r32/m32, r32\r# [0x00400000] = EAX\rMOV [0x00400000], EAX\r# 结果 [0x00400000] = 0x12345678ADD（加法）# # 语法：ADD r32, imm32 # EAX = EAX + 0x3（假设初始EAX=0x5） MOV EAX, 0x5 ADD EAX, 0x3 # 结果 EAX = 0x8 # 语法：ADD r32, r32/m32 # EAX = EAX + EBX（假设EAX=0x10, EBX=0x4） MOV EAX, 0x10 MOV EBX, 0x4 ADD EAX, EBX # 结果 EAX = 0x14 # 语法：ADD r32, r32/m32 # EAX = EAX + [0x00400000]（假设内存值=0x7） MOV EAX, 0 ADD EAX, [0x00400000] # 结果 EAX = 0x7SUB（减法）# # 语法：SUB r32, imm32 # EAX = EAX - 0x3（假设初始EAX=0x10） MOV EAX, 0x10 SUB EAX, 0x3 # 结果 EAX = 0xD # 语法：SUB r32, r32/m32 # EAX = EAX - EBX（假设EAX=0x20, EBX=0x5） MOV EAX, 0x20 MOV EBX, 0x5 SUB EAX, EBX # 结果 EAX = 0x1B # 语法：SUB r32, r32/m32 # EAX = EAX - [0x00400000]（假设内存值=0x4） MOV EAX, 0x10 SUB EAX, [0x00400000] # 结果 EAX = 0xCAND（按位与）# # 语法：AND r32, imm32 # EAX = EAX \u0026amp; 0x0F（假设初始EAX=0xFF） MOV EAX, 0xFF AND EAX, 0x0F # 结果 EAX = 0x0F # 语法：AND r32, r32/m32 # EAX = EAX \u0026amp; EBX（假设EAX=0xF0, EBX=0x0F） MOV EAX, 0xF0 MOV EBX, 0x0F AND EAX, EBX # 结果 EAX = 0x00 # 语法：AND r32, r32/m32 # EAX = EAX \u0026amp; [0x00400000]（假设内存值=0x0F） MOV EAX, 0xFF AND EAX, [0x00400000] # 结果 EAX = 0x0FOR（按位或）# # 语法：OR r32, imm32 # EAX = EAX | 0xF（假设初始EAX=0x0） MOV EAX, 0x0 OR EAX, 0xF # 结果 EAX = 0xF # 语法：OR r32, r32/m32 # EAX = EAX | EBX（假设EAX=0x10, EBX=0x01） MOV EAX, 0x10 MOV EBX, 0x01 OR EAX, EBX # 结果 EAX = 0x11 # 语法：OR r32, r32/m32 # EAX = EAX | [0x00400000]（假设内存值=0x05） MOV EAX, 0 OR EAX, [0x00400000] # 结果 EAX = 0x5XOR（按位异或）# # 语法：XOR r32, imm32 # EAX = EAX ^ 0xFF（假设初始EAX=0x55） MOV EAX, 0x55 XOR EAX, 0xFF # 结果 EAX = 0xAA # 语法：XOR r32, r32/m32 # EAX = EAX ^ EBX（假设EAX=0xAA, EBX=0x0F） MOV EAX, 0xAA MOV EBX, 0x0F XOR EAX, EBX # 结果 EAX = 0xA5 # 语法：XOR r32, r32/m32 # EAX = EAX ^ [0x00400000]（假设内存值=0x05） MOV EAX, 0 XOR EAX, [0x00400000] # 结果 EAX = 0x5NOT（按位取反）# # 语法：NOT r32/m32 # EAX = ~EAX（假设初始EAX=0x0F） MOV EAX, 0x0F NOT EAX # 结果 EAX = 0xFFFFFFF0 # 语法：NOT r8/m8 # AL = ~AL（假设初始AL=0x0F） MOV AL, 0x0F NOT AL # 结果 AL = 0xF0 # 语法：NOT r32/m32 # [0x00400000] = ~[0x00400000]（假设内存值=0x0F） NOT [0x00400000] # 结果 [0x00400000] = 0xF0 r 通用寄存器；m 代表内存；imm 代表立即数；r8 代表8位通用寄存器；m8 代表8位内存；imm8 代表8位立即数\n源、目标不能同时为内存\n寄存器 ← 寄存器 寄存器 ← 内存 寄存器 ← 立即数 内存 ← 寄存器 汇编指令总结# 1️⃣ MOV（数据传送）\n作用：把一个值从寄存器、内存或立即数，传送到另一个寄存器或内存。 底层实现： 不经过加法器或逻辑运算 只是 把数据直接写入目标寄存器/内存 硬件上通常是 总线传输 + 寄存器写入，可能会有时序控制 简单来说，MOV 就是 数据搬运，不做数学计算。 2️⃣ ADD/SUB\n作用：执行数学运算 底层实现： 统一用 加法器 + 补码（SUB 通过补码转换） 每一位用逻辑门（XOR、AND、OR、NOT）处理 本质上是 数学计算 + 位运算。 3️⃣ 总结对比\n指令 本质 底层 MOV 数据搬运 总线传输 + 寄存器/内存写入 ADD 加法 加法器 + 逻辑门（XOR/AND/OR） SUB 减法 加法器 + 补码 + 逻辑门 AND/OR/XOR/NOT 按位运算 逻辑门（XOR/AND/OR/NOT） "},{"id":32,"href":"/Python/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/3.Pandas%E5%88%86%E7%BB%84/","title":"Pandas分组","section":"Python数据处理","content":"分组模式及其对象# 分组的一般模式# 概念： Pandas 分组通常遵循三个步骤：\n分割（split）：根据某些条件把数据分组。 应用（apply）：对每个分组进行计算。 合并（combine）：将分组结果合并成一个新的数据结构。 df.groupby(分组依据)[数据来源].使用操作() import pandas as pd # 创建示例数据 data = { \u0026#39;城市\u0026#39;: [\u0026#39;北京\u0026#39;, \u0026#39;上海\u0026#39;, \u0026#39;北京\u0026#39;, \u0026#39;广州\u0026#39;, \u0026#39;上海\u0026#39;, \u0026#39;广州\u0026#39;], \u0026#39;年份\u0026#39;: [2020, 2020, 2021, 2020, 2021, 2021], \u0026#39;销售额\u0026#39;: [100, 200, 150, 300, 250, 350] } df = pd.DataFrame(data) print(df) # 分组模式：按城市分组，计算销售额总和 grouped = df.groupby(\u0026#39;城市\u0026#39;)[\u0026#39;销售额\u0026#39;].sum() print(grouped)分组依据的本质# 概念： 分组依据可以是：\n某一列（或多列） Series、数组、字典 函数（如 lambda x: x.year） # 按年份分组 grouped_year = df.groupby(df[\u0026#39;年份\u0026#39;])[\u0026#39;销售额\u0026#39;].sum() print(grouped_year) # 按自定义函数分组（销售额\u0026gt;200为一组，小于等于200为另一组） grouped_custom = df.groupby(lambda x: \u0026#39;大额\u0026#39; if df.loc[x, \u0026#39;销售额\u0026#39;] \u0026gt; 200 else \u0026#39;小额\u0026#39;)[\u0026#39;销售额\u0026#39;].sum() print(grouped_custom)GroupBy对象# 概念： groupby 返回一个 GroupBy 对象，它本身不会立即计算，而是惰性计算。 可以用 groups 查看分组索引。\n测试代码：\ngrouped_obj = df.groupby(\u0026#39;城市\u0026#39;) print(type(grouped_obj)) print(grouped_obj.groups)分组的三大操作# 概念：\n聚合（Aggregation）：对每组计算汇总值。 变换（Transformation）：对每组计算一个与原数据同维度的值。 过滤（Filtering）：根据某组条件保留或删除分组。 # 聚合 print(grouped_obj[\u0026#39;销售额\u0026#39;].sum()) # 变换 print(grouped_obj[\u0026#39;销售额\u0026#39;].transform(\u0026#39;mean\u0026#39;)) # 过滤 print(grouped_obj.filter(lambda x: x[\u0026#39;销售额\u0026#39;].sum() \u0026gt; 400))聚合函数# 内置聚合函数# 概念： 常用函数： sum(), mean(), max(), min(), count()\nprint(grouped_obj[\u0026#39;销售额\u0026#39;].mean()) print(grouped_obj[\u0026#39;销售额\u0026#39;].max()) print(grouped_obj[\u0026#39;销售额\u0026#39;].count())agg方法# 概念： agg 可以同时使用多个聚合函数，也可以自定义函数。\n# 多个聚合函数 print(grouped_obj[\u0026#39;销售额\u0026#39;].agg([\u0026#39;sum\u0026#39;, \u0026#39;mean\u0026#39;, \u0026#39;max\u0026#39;])) # 自定义函数 print(grouped_obj[\u0026#39;销售额\u0026#39;].agg(lambda x: x.max() - x.min()))变换和过滤# 变换函数与 transform 方法# 概念： transform 保持原数据形状，对每个组执行函数。 适合用于归一化、填充缺失值等。\n# 标准化（每组减去均值再除以标准差） df[\u0026#39;销售额标准化\u0026#39;] = grouped_obj[\u0026#39;销售额\u0026#39;].transform(lambda x: (x - x.mean()) / x.std()) print(df)组索引与过滤# 概念： filter 保留满足条件的组 条件函数返回 True/False\n# 过滤总销售额大于400的组 filtered_df = grouped_obj.filter(lambda x: x[\u0026#39;销售额\u0026#39;].sum() \u0026gt; 400) print(filtered_df)跨列分组# apply的引入# 概念： apply 可以对每组进行任意操作，返回结果可以是不同形状。 比 agg 更灵活。\n# 每组增加一列，显示销售额是否高于组均值 def flag_high_sales(group): group[\u0026#39;高于均值\u0026#39;] = group[\u0026#39;销售额\u0026#39;] \u0026gt; group[\u0026#39;销售额\u0026#39;].mean() return group df_applied = grouped_obj.apply(flag_high_sales) print(df_applied)apply的使用# 概念： 可以对每组返回单值、多值、甚至 DataFrame 支持复杂计算\n# 每组取销售额最大的记录 max_sales = grouped_obj.apply(lambda x: x[x[\u0026#39;销售额\u0026#39;] == x[\u0026#39;销售额\u0026#39;].max()]) print(max_sales)"},{"id":33,"href":"/Game/%E9%80%86%E5%90%91%E5%88%9D%E7%BA%A7/05.%E5%86%85%E5%AD%98/","title":"05.内存","section":"逆向初级","content":"CPU 的“位”# 32 位指的是什么？# CPU 的位数 = 寄存器宽度 + ALU 运算位宽 + 地址总线宽度 寄存器宽度 = 32 位 → 每个寄存器能存 4 字节数据 ALU = 32 位 → 一次运算处理 32 位数据 地址总线 = 32 位 → 可寻址空间 = 2³² 字节 = 4GB ✅ 关键点：“32 位”不是随便说的，而是 CPU 各个核心部件设计的一致结果。\n寄存器宽度 → 决定数据存储/运算能力 地址总线宽度 → 决定最大内存寻址范围 ALU 宽度 → 决定一次能处理多少位的数据 CPU 操作寄存器与内存的区别# CPU 访问寄存器的方式# 位置：CPU 内部的小型高速存储 寄存器存的是什么：数据本身（整数、浮点数、指针等） 访问方式：直接访问 例：MOV EAX, 5 → EAX 直接存储数值 5（32 位） 特点：容量小、速度最快 CPU 访问内存的方式# 位置：CPU 外部的大容量存储\n内存存的是什么：数据（通过地址编号访问）\n访问方式：CPU 自身不能“存储”内存地址编号，它只是通过地址总线发出地址信号到内存，从而读写对应位置的数据。\n例：MOV EAX, [0x1000] → CPU 按地址 0x1000 取数据到 EAX CPU 内存寻址规则\n地址总线宽度：32 位 → 可表示 2³² 个不同的地址编号\n最小寻址单位：1 个地址编号对应 1 字节（8 位）\n最大寻址范围：2³² × 1B = 4GB\n关键点：\nCPU 访问的是 地址编号，而不是数据本身 数据必须通过地址读取到寄存器或 ALU 才能操作 对比总结# 存储位置 存储内容 访问方式 特点 寄存器 数据本身 直接读写 极快，数量少 内存 数据（地址定位） 先通过地址寻址再取/存 容量大，速度慢 类比记忆# 寄存器 = 手里的小盒子 直接装数据，随取随用 内存 = 仓库 需要地址（门牌号）才能去取东西 寄存器可以先装一个地址，再让 CPU 按地址访问仓库 核心结论# 寄存器宽度 = CPU 位数，决定一次能存多少数据（32 位 = 4 字节）。 地址总线宽度 = CPU 位数，决定最大可寻址内存（32 位 = 4GB）。 寄存器存的是数据，内存是通过地址访问的数据。 CPU 运行时往往是：寄存器里存放一个地址 → 再去内存取数据。 内存# 每个应用程序都会有自己的独立 4GB 内存空间。\n注意：这里的“内存”指的是程序可用的虚拟内存空间，而不是物理内存条。\n内存与寄存器的区别# 寄存器\nCPU 内部的小型高速存储 数量有限、造价高 可以给每个寄存器取名字（例如 EAX、EBX） 内存\n外部大容量存储 太大无法命名，因此使用 编号 编号称为 内存地址 CPU 访问内存的数据单位# 内存地址宽度：32 位 → 地址编号由 32 个二进制位表示\n一般使用 16 进制表示，例如：0x00000000 最小寻址单位：1 个地址对应 1 字节（8 位）\n程序可访问内存范围：0x00000000 ~ 0xFFFFFFFF\n可存储的位数计算：\n总块数 = 0xFFFFFFFF + 1（加 1 是因为编号从 0 开始） 每块 1 字节 = 8 位 总位数 = (0xFFFFFFFF + 1) × 8 换算为容量： 34359738368 Bit ÷ 8 = 4294967296 Byte 4294967296 Byte ÷ 1024 = 4194304 KB 4194304 KB ÷ 1024 = 4096 MB 4096 MB ÷ 1024 = 4 GB ✅ 因此，每个程序都有独立的 4GB 虚拟内存空间。\n寄存器与内存的区别# 基本特点# 寄存器\n位于 CPU 内部，高速执行 数量有限、造价高 可以命名（如 EAX、BX、AH 等） 内存\n外部大容量存储，速度相对较慢 成本低，可以做得很大 数量庞大，无法逐个命名，只能用编号（地址）代替 共同点\n都是存储数据的容器 都是定宽的（都有最大存储范围） 计量单位# 计算机常用\nBYTE（字节） = 8 bit WORD（字） = 16 bit DWORD（双字） = 32 bit 生活中常用\n1 KB = 1024 Byte 1 MB = 1024 KB 1 GB = 1024 MB 32 位 / 64 位计算机的含义# 误区：不是说 32 位 CPU 寄存器或内存最大宽度是 32 bit 正确理解： CPU 的位数主要指 最大寻址范围 CPU 中可能存在大于 32 位的寄存器，但寻址时地址不能超过 32 位 CPU 通过地址编号找到内存或寄存器中的数据 内存编号与地址# 寄存器命名：数量少，可以取名字 内存编号：数量庞大，无法命名，用编号表示 → 这就是 内存地址 编号生成原理\n32 位地址线 = 32 根线路，每根线 0 或 1 32 根线的组合可表示 2³² 个编号 每个编号对应 1 字节（8 位） 通过编号 CPU 可以找到对应的内存单元 32 位地址表示# 用 16 进制 表示：8 位十六进制数，如 0x00000000 ~ 0xFFFFFFFF 每个地址编号对应 1 字节（8 位） 可寻址内存计算\n地址总数：0xFFFFFFFF - 0x00000000 + 1 = 0x100000000 转换为十进制：2^32 = 4,294,967,296 个字节 = 约 4 GB 换算过程\n4,294,967,296 Byte ÷ 1024 = 4,194,304 KB 4,194,304 KB ÷ 1024 = 4,096 MB 4,096 MB ÷ 1024 = 4 GB"},{"id":34,"href":"/Python/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/4.Pandas%E5%8F%98%E5%BD%A2/","title":"Pandas变形","section":"Python数据处理","content":"长宽表的变形# pivot将长表转为宽表（单个聚合函数）# 功能：将一列作为新列名，一列作为新行索引，填充值来自另一列。\n限制：索引和列的组合必须唯一（不能有重复）。\n语法：df.pivot(index='行索引', columns='列名', values='值')\n案例：学生成绩表（长 → 宽）\nimport pandas as pd # 原始长表 df_long = pd.DataFrame({ \u0026#39;学生\u0026#39;: [\u0026#39;小明\u0026#39;, \u0026#39;小明\u0026#39;, \u0026#39;小红\u0026#39;, \u0026#39;小红\u0026#39;], \u0026#39;科目\u0026#39;: [\u0026#39;数学\u0026#39;, \u0026#39;语文\u0026#39;, \u0026#39;数学\u0026#39;, \u0026#39;语文\u0026#39;], \u0026#39;成绩\u0026#39;: [85, 90, 78, 92] }) print(\u0026#34;原始长表：\u0026#34;) print(df_long) # 转为宽表 df_wide = df_long.pivot(index=\u0026#39;学生\u0026#39;, columns=\u0026#39;科目\u0026#39;, values=\u0026#39;成绩\u0026#39;) print(\u0026#34;\\npivot 转宽表：\u0026#34;) print(df_wide) #输出 原始长表： 学生 科目 成绩 0 小明 数学 85 1 小明 语文 90 2 小红 数学 78 3 小红 语文 92 pivot 转宽表： 科目 数学 语文 学生 小明 85 90 小红 78 92pivot_table支持聚合的宽表转换（pivot 的增强版）# 功能：支持聚合（如 mean, sum），可处理重复索引。\n语法:df.pivot_table(index='行',columns='列', values='值', aggfunc='mean') 案例：带重复数据的成绩表\n# 含重复数据（小明考了两次数学） df_repeat = pd.DataFrame({ \u0026#39;学生\u0026#39;: [\u0026#39;小明\u0026#39;, \u0026#39;小明\u0026#39;, \u0026#39;小明\u0026#39;, \u0026#39;小红\u0026#39;], \u0026#39;科目\u0026#39;: [\u0026#39;数学\u0026#39;, \u0026#39;数学\u0026#39;, \u0026#39;语文\u0026#39;, \u0026#39;数学\u0026#39;], \u0026#39;成绩\u0026#39;: [85, 88, 90, 78] }) # 使用 pivot_table 计算平均分 df_pivot_table = df_repeat.pivot_table( index=\u0026#39;学生\u0026#39;, columns=\u0026#39;科目\u0026#39;, values=\u0026#39;成绩\u0026#39;, aggfunc=\u0026#39;mean\u0026#39; ) print(\u0026#34;pivot_table（平均分）：\u0026#34;) print(df_pivot_table) #输出 科目 数学 语文 学生 小明 86.5 90 小红 78.0 NaNmelt将宽表转为长表# 功能：将多列合并为两列（变量名 + 值），是 pivot 的逆操作。\n语法:df.melt(id_vars='不变列', value_vars='要合并的列', var_name='变量名', value_name='值')\n案例：宽表转长表\n# 宽表 df_wide = pd.DataFrame({ \u0026#39;学生\u0026#39;: [\u0026#39;小明\u0026#39;, \u0026#39;小红\u0026#39;], \u0026#39;数学\u0026#39;: [85, 78], \u0026#39;语文\u0026#39;: [90, 92] }) # 转为长表 df_melt = df_wide.melt( id_vars=\u0026#39;学生\u0026#39;, value_vars=[\u0026#39;数学\u0026#39;, \u0026#39;语文\u0026#39;], var_name=\u0026#39;科目\u0026#39;, value_name=\u0026#39;成绩\u0026#39; ) print(\u0026#34;melt 转长表：\u0026#34;) print(df_melt) 输出： 学生 科目 成绩 0 小明 数学 85 1 小红 数学 78 2 小明 语文 90 3 小红 语文 92wide_to_long处理复杂列名的宽转长# 功能：适用于列名有规律（如 score_math, score_chinese）的宽表。\n案例：带前缀的宽表\ndf_complex = pd.DataFrame({ \u0026#39;学生\u0026#39;: [\u0026#39;小明\u0026#39;, \u0026#39;小红\u0026#39;], \u0026#39;score_math\u0026#39;: [85, 78], \u0026#39;score_chinese\u0026#39;: [90, 92], \u0026#39;time_math\u0026#39;: [\u0026#39;2023\u0026#39;, \u0026#39;2023\u0026#39;], \u0026#39;time_chinese\u0026#39;: [\u0026#39;2023\u0026#39;, \u0026#39;2023\u0026#39;] }) # 转换 df_long = pd.wide_to_long( df_complex, stubnames=[\u0026#39;score\u0026#39;, \u0026#39;time\u0026#39;], i=\u0026#39;学生\u0026#39;, j=\u0026#39;科目\u0026#39;, sep=\u0026#39;_\u0026#39;, suffix=\u0026#39;\\w+\u0026#39; ) print(\u0026#34;wide_to_long 结果：\u0026#34;) print(df_long) 输出： score time 学生 科目 小明 math 85 2023 小红 math 78 2023 小明 chinese 90 2023 小红 chinese 92 2023索引的变形# stack 与 unstack# stack()：列转为行索引（列 → 行） unstack()：行索引转为列（行 → 列）\n案例\ndf = pd.DataFrame( [[85, 90], [78, 92]], index=[\u0026#39;小明\u0026#39;, \u0026#39;小红\u0026#39;], columns=[\u0026#39;数学\u0026#39;, \u0026#39;语文\u0026#39;] ) print(\u0026#34;原表：\u0026#34;) print(df) # stack：列转为内层索引 stacked = df.stack() print(\u0026#34;\\nstack()：\u0026#34;) print(stacked) # unstack：内层索引转为列 unstacked = stacked.unstack() print(\u0026#34;\\nunstack()：\u0026#34;) print(unstacked) 输出： 原表： 数学 语文 小明 85 90 小红 78 92 stack()： 小明 数学 85 语文 90 小红 数学 78 语文 92 dtype: int64 unstack()： 数学 语文 小明 85 90 小红 78 92聚合与变形的关系# pivot_table 本质是 先聚合，再变形 groupby + unstack 可实现类似 pivot_table 的效果 案例：等价操作\ndf = pd.DataFrame({ \u0026#39;A\u0026#39;: [\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;b\u0026#39;], \u0026#39;B\u0026#39;: [\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;], \u0026#39;C\u0026#39;: [1, 2, 3, 4] }) # 方法1：pivot_table pt = df.pivot_table(index=\u0026#39;A\u0026#39;, columns=\u0026#39;B\u0026#39;, values=\u0026#39;C\u0026#39;, aggfunc=\u0026#39;sum\u0026#39;) # 方法2：groupby + unstack gb = df.groupby([\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;])[\u0026#39;C\u0026#39;].sum().unstack() print(\u0026#34;pivot_table:\u0026#34;) print(pt) print(\u0026#34;\\ngroupby + unstack:\u0026#34;) print(gb) 输出一致： B x y A a 1 2 b 3 4其他变形函数# crosstab交叉表（频次统计）# 功能：计算两个或多个变量的频数表。\n案例：性别与科目交叉表\ndf = pd.DataFrame({\r\u0026#39;性别\u0026#39;: [\u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;],\r\u0026#39;科目\u0026#39;: [\u0026#39;数学\u0026#39;, \u0026#39;数学\u0026#39;, \u0026#39;语文\u0026#39;, \u0026#39;语文\u0026#39;]\r})\rct = pd.crosstab(df[\u0026#39;性别\u0026#39;], df[\u0026#39;科目\u0026#39;])\rprint(\u0026#34;crosstab 交叉表：\u0026#34;)\rprint(ct)输出：\n科目 数学 语文\r性别\r女 1 1\r男 1 1explode将列表元素展开为多行# 功能：将一列中的列表/元组展开，每元素占一行。\n案例：学生兴趣班\ndf = pd.DataFrame({\r\u0026#39;学生\u0026#39;: [\u0026#39;小明\u0026#39;, \u0026#39;小红\u0026#39;],\r\u0026#39;兴趣\u0026#39;: [[\u0026#39;篮球\u0026#39;, \u0026#39;音乐\u0026#39;], [\u0026#39;绘画\u0026#39;]]\r})\rdf_exploded = df.explode(\u0026#39;兴趣\u0026#39;)\rprint(\u0026#34;explode 展开：\u0026#34;)\rprint(df_exploded)\r输出：\r学生 兴趣\r0 小明 篮球\r0 小明 音乐\r1 小红 绘画get_dummies独热编码（One-Hot Encoding）# 功能：将分类变量转为多列 0/1。\n案例：科目独热编码\ndf = pd.DataFrame({\u0026#39;科目\u0026#39;: [\u0026#39;数学\u0026#39;, \u0026#39;语文\u0026#39;, \u0026#39;数学\u0026#39;]})\rdummies = pd.get_dummies(df[\u0026#39;科目\u0026#39;], prefix=\u0026#39;科目\u0026#39;)\rprint(\u0026#34;get_dummies 独热编码：\u0026#34;)\rprint(dummies)\r输出：\r科目_数学 科目_语文\r0 1 0\r1 0 1\r2 1 0总结：何时使用哪种变形？# 场景 推荐函数 长表 → 宽表（无重复） pivot 长表 → 宽表（有重复，需聚合） pivot_table 宽表 → 长表 melt / wide_to_long 列 ↔ 行索引转换 stack / unstack 频次统计表 crosstab 列表展开为行 explode 分类变量编码 get_dummies "},{"id":35,"href":"/Python/Python%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81/Fastapi-WEB%E5%BC%80%E5%8F%91/","title":"fastapi","section":"Python应用代码","content":"1\n"},{"id":36,"href":"/Python/Python%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/","title":"数据库开发","section":"Python应用代码","content":"1\n"},{"id":37,"href":"/Python/Python%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81/%E4%B8%80%E4%BA%9B%E8%A7%84%E8%8C%83/","title":"一些规范","section":"Python应用代码","content":"一些规范 Commit提交规范\n提交commit需要遵循一定的规范，这样赘述问题的问题可以很好定位问题\rint:初始化项目\rfeat:增加新的功能\rfix:修改功能，修复bug\rfmt:修改格式之类的，无关功能\rdoc:修改文档和修改注释，无关功能\rtest:测试代码，无关功能\rfile:移动文件，移除文件，无关功能\r如果有多个修改，比如即fix了，又有doc，按照排序在前的标注\n提交Commit的建议做法:\n原子化提交,即每一次提交的都是单一的功能, 不要一下子提交太多功能的修改\r多Commit,少Push,每天必须要把当天的代码Push完\r切换到发布tag的时候不要Commit\r版本号管理\n版本号统一使用 v20250720.02类似格式,使用小写v和数字组成\r软件部署\n软件测试前需自测通过\r测试前需通知到当站人员\r需备好编辑器软件,压缩软件,FTP连接软件\r智能化程式统一部署在PyApp目录,不要安装在其他目录,优先D盘,不要安装在CD软盘之类,没有D盘就E盘,尽量不要C盘\rGUI程式使用集成包方式部署,内嵌入Python解释器\r命令行软件一定要加入开机自启,优先使用系统级开机自启,不行再使用用户级开机自启\r部署新软件,老版本软件备份,安装日期备注\r临时修改的软件必须回传到FTP目录,并回传到git\r编程规范\n缩进统一使用4个空格,不要使用默认的tab,但可以设定1 tab = 4 空格\r软件必须支持心跳/自动更新使用utils\r约定大于配置,库的导入有官方规范就按照官方的,没有按照团队的\r入口文件要足够简单,直接就是导入模块,执行模块,入口函数名必须是 main\r使用with 打开文件,不要手动关闭文件,且必须指定文件编码,with获取值之后要及时退出,不要一直占用文件\r循环内不要写和循环本身无关的东西,能放在循环外的必须放在循环外\r所有代码必须经过类型检查,不接受报红代码,无法通过类型检查的代码不允许提交,除非第三方库本身问题除外\r函数参数必须增加类型注解,用于类型检查\r函数必须增加注释,解释作用及参数意义,注意,不要写无意义及有歧义的内容\r使用f-string方式来拼接字符串(除非你知道你不会遇到XP系统,否则使用format格式化字符串)\r不要相信用户的输入,必须做一定的防呆,比如去除首尾的空行,换行等\r自己创建的路径不要使用中文,不要自己给自己找麻烦\r启动函数应该在 if name == “main”: 内\r源代码应该带文件头,即表明版本的和编码的备注\r函数名应该按照[蛇形小写形式]比如:get_file_name(),除了类和常量,不要使用大写,文件和目录也不要使用大写\r尽量不要使用全局变量,除非十分必要\r软件必须增加日志上传功能 "},{"id":38,"href":"/Python/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/functools/","title":"functools","section":"Python基础知识","content":"functools.partial 是 Python 标准库中一个非常实用的高阶函数工具，它的作用可以用一句话概括： “固定一个函数的部分参数，返回一个新函数。”\n举个生活化的例子：奶茶店点单你常去一家奶茶店，每次都说： “我要一杯 少糖、加布丁、中杯 的珍珠奶茶。” 但店员记住了你的偏好，于是给你一张 “定制卡”： 只要说“用我的定制卡点一杯”，他就自动按 少糖+加布丁+中杯 做。 这张“定制卡”，就是 partial！\nfrom functools import partial def make_tea(sugar, toppings, size, tea_type=\u0026#34;珍珠奶茶\u0026#34;): print(f\u0026#34;制作一杯 {size} {tea_type}，糖度：{sugar}，加料：{toppings}\u0026#34;) # 创建你的“定制卡”：固定部分参数 #partial 把原函数 make_tea 的前三个参数“冻结”了， 返回一个新函数 my_tea，调用时只需传剩下的参数（或不传）。 my_tea = partial(make_tea, sugar=\u0026#34;少糖\u0026#34;, toppings=\u0026#34;布丁\u0026#34;, size=\u0026#34;中杯\u0026#34;) # 使用定制卡 my_tea() # 输出：制作一杯 中杯 珍珠奶茶，糖度：少糖，加料：布丁 # 甚至还能临时改茶底！ my_tea(tea_type=\u0026#34;椰果奶茶\u0026#34;) # 输出：制作一杯 中杯 椰果奶茶，糖度：少糖，加料：布丁"},{"id":39,"href":"/Linux/git/Git%E5%9F%BA%E7%A1%80/","title":"Git使用教程","section":"Linux","content":"安装git# [root@localhost ~]# git --version git version 1.8.3.1 #centos默认自带的版本是1.8，生产环境一般2.7以上 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker wget https://github.com/git/git/archive/v2.20.0.zip unzip v2.20.0.zip cd git-2.20.0/ make prefix=/usr/local/git all make prefix=/usr/local/git install cp /usr/local/git/bin/* /usr/bin/ git --versiongit文件状态# 按照文件的存放位置分：\n在你自建的Git本地仓库中，有三个区域：\nGit仓库：是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。\n工作目录：是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。\n暂存区域：是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也称作`‘索引’\u0026rsquo;，不过一般说法还是叫暂存区域。\n按照文件的状态分： 工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪\n未跟踪的文件：改动不受到Git的版本控制，即为Unstracked状态,还没有被git管理 已跟踪的文件：即被纳入版本控制的文件，又分为未修改（unmodified）、已修改（modified）、已暂存（staged）、已提交到版本库（committed）四种状态 git基本使用# git init，初始化，表示即将对当前文件夹进行版本控制。 git status，查看Git当前状态，如：那些文件被修改过、那些文件还未提交到版本库等。 git add 文件名，将指定文件添加到版本库的暂存状态。 git commit -m \u0026#34;xxx\u0026#34; 把暂存区的所有文件提交到仓库区，暂存区空空荡荡。 git push -u origin master 把仓库区的文件提交到远程仓库里。 git remote add origin https://github.com/name/name_cangku.git 把本地仓库与远程仓库连接起来。 git log，查看提交记录，即：历史版本记录本地仓库# 全局配置\n添加用户名邮箱，git在提交时候会记录当前版本由那个用户提交\ngit config --global user.name \u0026#34;wangc\u0026#34;\rgit config --global user.email wangc@example.com创建本地仓库\nmkdir test cd test/ git init #初始化test目录，初始化后，会在当前目录自动创建 .git 文件夹，该文件是Git中最重要的文件夹，因为Git相关文件以及版本都将保存在该文件夹中，通过Git命令可以将所有版本保存在 .git 文件中 echo \u0026#34;print(\u0026#34;hello\u0026#34;)\u0026#34; \u0026gt;hello.py git status git add . #添加当前目录下所有文件到暂存区 git commit -m \u0026#39;第一次提交\u0026#39; git log远程仓库# 全局配置\n#添加用户名邮箱，git在提交时候会记录当前版本由那个用户提交 git config --global user.name \u0026#34;Administrator\u0026#34; git config --global user.email \u0026#34;admin@example.com\u0026#34;使用场景1：克隆远程仓库# git clone git@192.168.100.163:root/python-demo.git cd python-demo touch README.md git add README.md git commit -m \u0026#34;add README\u0026#34; git push -u origin master使用场景2：推送现有文件夹# #假设本地已经有个test仓库了，但想把test里的代码，保存到远程python-demo仓库之上 mkdir test cd test/ git init touch hello.py git remote add origin git@192.168.100.163:root/python-demo.git #本地的仓库与Gitlab上的远程仓库做关联 git add . git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin master 使用场景3：项目迁移 git clone git@192.168.100.163:root/python-old.git #原服务器代码地址 cd python-old git remote rename origin old-origin #首先将原来的origin重命名一下 git remote add origin git@192.168.100.163:root/python-new.git #新服务器代码需要存放的地址 git push -u origin --all #上传到新服务器 git push -u origin --tags #上传tag版本回滚# [root@localhost test]# vim app.py [root@localhost test]# git add . [root@localhost test]# git commit -m \u0026#39;第二次提交\u0026#39; [root@localhost test]# git log commit 7e3180eb85d99fb0d6166f909d5228899fc339bf (HEAD -\u0026gt; master) Author: wangchuang \u0026lt;you@example.com\u0026gt; Date: Sun Jan 19 15:50:48 2020 +0800 第二次提交 commit 9e1b2841ef1ada74d66a4c19b81da394b260c873 Author: wangchuang \u0026lt;you@example.com\u0026gt; Date: Sun Jan 19 15:21:00 2020 +0800 第一次提交 [root@localhost test]# git reset --hard 9e1b2841ef1ada74d66a4c19b81da394b260c873 da394b260c873 HEAD 现在位于 9e1b284 第一次提交回滚倒是完成了，但如果某一天想要再回到回滚前的版本怎么办呢？\n[root@localhost test]# git reflog 9e1b284 (HEAD -\u0026gt; master) HEAD@{0}: reset: moving to 9e1b2841ef1ada74d66a4c19b81da394b260c873 7e3180e HEAD@{1}: commit: 第二次提交 9e1b284 (HEAD -\u0026gt; master) HEAD@{2}: commit (initial): 第一次提交 [root@localhost test]# git reset --hard 7e3180e HEAD 现在位于 7e3180e 第二次提交分支管理# git branch 分支名称 创建分支 git checkout 分支名称 切换分支 git branch -m 分支名称 创建并切换到指定分支 git branch 查看所有分支 git branch -d 分支名称 删除分支 git merge 分支名称 将指定分支合并到当前分支 git branch –merged #查看哪些分支被合并了 git branch –no-merged #查看哪些分支没有合并 branch称为分支，默认仅有一个名为master的分支。一般开发新功能流程为：开发新功能时会在分支dev上进行，开发完毕后再合并到master分支 [root@localhost test]# git branch dev # 创建新分支，即：拷贝一份当前所在分支代码到新分支 [root@localhost test]# git checkout dev # 切换到dev分支 [root@localhost test]# vim new.py [root@localhost test]# git status 位于分支 dev 未跟踪的文件: （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 以包含要提交的内容） new.py 提交为空，但是存在尚未跟踪的文件（使用 \u0026#34;git add\u0026#34; 建立跟踪） [root@localhost test]# git add . [root@localhost test]# git commit -m \u0026#39;新功能开发完毕\u0026#39; [dev be42e4d] 新功能开发完毕 1 file changed, 1 insertion(+) create mode 100644 new.py [root@localhost test]# git checkout master 切换到分支 \u0026#39;master\u0026#39; [root@localhost test]# git merge dev # 将dev分支内容合并到master分支 更新 7e3180e..be42e4d Fast-forward new.py | 1 + 1 file changed, 1 insertion(+) create mode 100644 new.py 按照着以上的流程进行开发，如果遇到上文开发到一般需要临时修复Bug的情况，可以按照下图的流程进行： [root@localhost test]# git branch * master [root@localhost test]# git branch dev # 创建dev分支用于开发新功能 [root@localhost test]# git checkout dev # 切换到dev分支 [root@localhost test]# vim new.py # 开发新功能到一半，需要紧急修复Bug [root@localhost test]# git add . [root@localhost test]# git commit -m \u0026#39;新功能开发一半\u0026#39; [dev 162d717] 新功能开发一半 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 new.py [root@localhost test]# git checkout master #切换回master分支 [root@localhost test]# git branch bug #创建bug分支 [root@localhost test]# git checkout bug #切换到bug分支 [root@localhost test]# vim bug.py #修改bug [root@localhost test]# git add . [root@localhost test]# git commit -m \u0026#39;紧急修复bug\u0026#39; #提交bug [root@localhost test]# git checkout master #切换回master [root@localhost test]# git merge bug #合并bug分子 [root@localhost test]# git checkout dev　＃继续开发 切换到分支 \u0026#39;dev\u0026#39;"},{"id":40,"href":"/Linux/install-docker/","title":"安装 Docker 教程","section":"Linux","content":"目录# 简介 安装步骤 验证安装 总结 简介# 本文将介绍如何在 Linux 系统上安装 Docker，适合初学者快速上手。\n安装步骤# 步骤1 步骤2\n总结# 完成安装 123456\n"},{"id":41,"href":"/Linux/install-mysql/","title":"安装 mysql 教程","section":"Linux","content":"s\n"}]