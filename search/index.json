[{"content":"nssm注册系统服务 对于Windows平台来说，很多软件或系统的后台服务是基于windows服务的方式运行的，它的优势是稳定可靠，有进程保护，但对于一些普通exe程序（控制台程序或带界面的windows程序）或bat文件是否也可以封装成windows服务进行运行呢？其实windows本身就有SC.exe，它为Windows系统自带工具，可对Windows系统服务进行创建，查询，启动，停止，删除等操作。但是SC.exe 只支持操作服务控制管理器(SCM)接口规范的系统服务，比如一般的网络服务进程如nginx 等无法作为服务直接启动了，因此本文介绍一个可以封装普通exe程序或bat文件的windows服务工具：NSSM。\nNSSM是一个服务封装程序，它可以将普通exe程序或bat文件封装成服务，使之像windows服务一样运行。同类型的工具还有微软自己的srvany，不过nssm更加简单易用，并且功能强大。它的特点如下：\n支持普通exe程序（控制台程序或者带界面的Windows程序都可以）或bat文件 安装简单又方便 可以重定向输出（并且支持Rotation） 可以自动守护封装了的服务，程序挂掉了后可以自动重启 可以自定义环境变量 可以自定义启动参数 从以上可以得知，NSSM每个功能都很实用，可以大大简化开发流程，降低了开发难度，使用和调试起来也非常方便，特别不需要考虑开发一个服务实现服务守护功能，以确保稳定可靠。 NSSM常用命令 1 2 3 4 5 6 7 1.安装服务：nssm install 服务名称 2.删除服务：nssm remove 服务名称 3.删除服务确定：nssm remove 服务名称 confirm 4.修改服务（显示界面修改）：nssm edit 服务名称 5.启动服务：nssm start 服务名称 6.停止服务：nssm stop 服务名名称 7.停止服务：nssm stop 服务名称 NSSM使用步骤 下载NSSM 1.下载NSSM 2.根据windows平台，将32/64位nssm.exe文件解压至任意文件夹 3.cmd进入到nssm.exe所在目录，如你操作系统是32bit，请对应32位的nssm.exe文件，如你操作系统是64bit，请对应64位的nssm.exe 4.输入 nssm install {服务名称}，即注册Windows服务的名称。\n注册服务 设置说明，如下： 1.Application Path: 选择系统安装的exe或bat。 2.Startup directory: 选择exe或bat项目的根目录。 3.Arguments: 输入启动参数。 4.Service name: 服务名称 上述步骤操作完成，即可点击Install service来注册服务。 在系统服务中services.msc找到刚刚注册的服务，右键属性 - 恢复即可设置此服务挂掉重启等内容。 需要注意一点，安装完服务后，需要启动服务，否则没有生效。\n","date":"2025-10-28T00:00:00Z","permalink":"https://example.com/p/nssm%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/","title":"nssm进程管理工具"},{"content":"123\n","date":"2025-10-27T00:00:00Z","permalink":"https://example.com/p/2.-yolo%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B/","title":"2. YOLO模型预测"},{"content":"YOLO发展历史 1.起源与核心思想的开放性 (Open Source) 开创者：YOLO最初确实是由Joseph Redmon等人作为学术研究项目创建的，并发表了论文。 开源：他们秉承开源精神，将代码公开。这一举动瞬间吸引了全世界的研究者和开发者。这意味着，任何人都可以获取、使用、修改和分发这些代码。\n2.创始人的“退出”与社区的“接管” 这是一个非常关键的转折点。 伦理担忧：在YOLOv3之后，创始人Joseph Redmon因担心其技术被用于军事、监控等恶性用途，产生了严重的伦理担忧，并宣布停止继续参与YOLO相关的研究。 权力真空与机遇：核心创始人的离开，并没有让市场和研究对高效目标检测的需求消失。这直接催生了两个结果：\n官方分支的延续：YOLOv4由原YOLOv3社区的活跃维护者（Alexey Bochkovskiy等）接手开发，延续了“官方”血脉。 新玩家的涌入：巨大的需求和开源代码的可得性，使得其他有实力的团队可以基于YOLO的核心思想，开发自己的版本。 3.不同的团队，不同的目标和优势 各个团队基于自身的技术栈和商业目标，对YOLO进行了不同的优化：\n团队 / 维护者 背景与目标 主要YOLO版本 版本特点与优势 主要仓库地址 Ultralytics 一家专注于AI工具的软件公司 YOLOv5, v8, v10, v11 工程化极致：基于PyTorch，易用性无敌，文档完善，生态强大，非常适合工业界和初学者。 https://github.com/ultralytics/ultralytics (v8, v10, v11) https://github.com/ultralytics/yolov5 (v5) 美团 中国领先的生活服务电子商务平台 YOLOv6 工业应用驱动：针对自身业务中的硬件进行极致优化，追求在特定芯片上的最快速度。 https://github.com/meituan/YOLOv6 Academic Researchers 大学和研究机构的人员 YOLOv7, YOLOv9 学术创新：关注于发表顶会论文，提出新的网络结构、训练方法等前沿思想。 https://github.com/WongKinYiu/yolov7 (v7) https://github.com/WongKinYiu/yolov9 (v9) Deci.ai 一家专注于AI模型效率的公司 YOLO-NAS 工具驱动：使用神经架构搜索工具，自动搜索出在精度和速度上最优的模型结构。 https://github.com/Deci-AI/super-gradients 4.如何选择：\n新项目/初学者：强烈推荐从 Ultralytics YOLOv11 或 YOLOv8 开始。 追求极致精度：可关注 YOLOv9 或 YOLOv11。 追求工业级部署速度：可评估 YOLO-NAS 或 YOLOv6。 安装Yolo https://docs.ultralytics.com/zh/quickstart/ https://blog.csdn.net/Scoful/article/details/131209347\nPython环境 安装python，需要安装python3.10以上版本，python版本不是越新越好的，python更新是不顾旧版本的逻辑的，有可能新版的就把旧版的一些函数直接删了 注意：python要加入环境变量 PyTorch GPU 环境配置 在PyTorch中使用CUDA，根据你的具体环境和需求调整版本号，确保安装的PyTorch版本与你的CUDA版本兼容。以下是在PyTorch中使用CUDA的一般步骤：\n1.NVIDIA官网下载最新的显卡驱动\n2.检查CUDA支持： 首先确保你的GPU支持CUDA。可以在官方CUDA支持列表上查找你的GPU型号。或者直接命令行nvidia-smi\n3.安装CUDA Toolkit (可选)： 下载并安装与你的GPU型号匹配的CUDA Toolkit。你可以从NVIDIA官网下载。\n4.安装cuDNN（可选）： cuDNN是NVIDIA的深度神经网络库，可以加速深度学习任务。在CUDNN下载页面下载适用于你的CUDA版本的cuDNN，并按照安装说明进行安装。\n5.安装PyTorch： 选择合适的PyTorch版本并使用pip或conda进行安装。\n一般只需要做1/2/5步骤，PyTorch 官方提供的包里已经内置了匹配版本的 CUDA 和 cuDNN 库。 只有在你要编译源码、用其他框架（比如 TensorFlow）、或者特殊开发环境时，才需要单独安装。\n查看本机CUDA版本 1 2 3 4 5 nvidia-smi #查看驱动版本，最高支持13.0，可以向下兼容 +-----------------------------------------------------------------------------------------+ | NVIDIA-SMI 581.57 Driver Version: 581.57 CUDA Version: 13.0 | +-----------------------------------------+------------------------+----------------------+ 查看对应CUDA的对应pytorch版本安装 官网查看对应系统对应cuda版本对应pytorch版本的安装命令\n16XX的显卡，安装cu102的版本，否则可能训练出现问题 30XX、40XX显卡，要安装cu111以上的版本，否则无法运行 无显卡的直接安装cpu版本即可\n同一个 PyTorch 版本（比如 1.13.0)有两种安装方式 pip：一般pip安装会比conda安装较高效 conda：需要安装Anaconda 或 Miniconda\n用pip 安装 本文安装 torch 1.13.0+cuda11.7 ，命令如下\n1 2 3 4 5 6 7 # CUDA 11.7 pip install torch==1.13.0+cu117 torchvision==0.14.0+cu117 torchaudio==0.13.0 --extra-index-url https://download.pytorch.org/whl/cu117 #网速不好的，可以单独下载whl 然后本地安装 https://download.pytorch.org/whl/torch/ #找到对应的包 pip install D:\\迅雷下载\\torch-1.13.0+cu117-cp310-cp310-win_amd64.whl pip install D:\\迅雷下载\\torchvision-0.14.0+cu117-cp310-cp310-win_amd64.whl pip install D:\\迅雷下载\\torchaudio-0.13.0+cu117-cp310-cp310-win_amd64.whl 验证安装 1 2 3 4 5 6 7 8 9 10 C:\\Users\\wchuang\u0026gt;python Python 3.10.0 (tags/v3.10.0:b494f59, Oct 4 2021, 19:00:18) [MSC v.1929 64 bit (AMD64)] on win32 Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import torch \u0026gt;\u0026gt;\u0026gt; print(torch.__version__) 1.13.0+cu117 \u0026gt;\u0026gt;\u0026gt; print(torch.cuda.is_available()) True #如果输出为True，表示CUDA可用 \u0026gt;\u0026gt;\u0026gt; print(torch.version.cuda) 11.7 ultralytics(YOLOv8)安装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 1.三种安装方式 1）直接使用源码(不推荐，无法使用命令行工具) https://github.com/ultralytics/ultralytics 2）pip直接安装(官方推荐) pip install ultralytics 3）pip源码安装(个人推荐) 我是采用此方法 #用的是tags/v8.2.0.zip包 https://github.com/ultralytics/ultralytics \u0026amp;\u0026amp; unzip ultralytics-main.zip \u0026amp;\u0026amp; cd ultralytics-main pip install -e . #-e参数必须要有，否则后续修改代码无效 pip list #可以看到已经安装了ultralytics ，并且源码在D:\\PyProject\\ultralytics-8.2.0目录下 ultralytics 8.2.0 D:\\PyProject\\ultralytics-8.2.0 2.测试 D:\\PyProject\\ultralytics-8.2.0\u0026gt;yolo predict model=yolov8n.pt source=ultralytics/assets/bus.jpg Downloading https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n.pt to \u0026#39;yolov8n.pt\u0026#39;... 100%|█████████████████████████████████████████████████████████████████████████████| 6.23M/6.23M [04:13\u0026lt;00:00, 25.8kB/s] Ultralytics YOLOv8.2.0 🚀 Python-3.10.0 torch-1.13.0+cu117 CUDA:0 (NVIDIA GeForce MX250, 2048MiB) # 从这行输出可以看出一切工作正常： ✅ PyTorch 检测到 CUDA（说明显卡驱动 \u0026amp; cuDNN 配置正确） ✅ YOLOv8 模型成功加载并推理（yolov8n.pt） ✅ 速度和参数正常（MX250 属于轻量显卡，速度正常） YOLOv8n summary (fused): 168 layers, 3151904 parameters, 0 gradients, 8.7 GFLOPs image 1/1 D:\\PyProject\\ultralytics-8.2.0\\ultralytics\\assets\\bus.jpg: 640x480 4 persons, 1 bus, 1 stop sign, 24.3ms ✅ 检测到4个人 一辆bus 一个stop信号 Speed: 9.4ms preprocess, 24.3ms inference, 428.1ms postprocess per image at shape (1, 3, 640, 480) Results saved to runs\\detect\\predict ✅ 预测结果输出在 runs/detect/predict 文件夹 #打开检测结果 D:\\PyProject\\ultralytics-8.2.0\\runs\\detect\\predict\\bus.jpg ","date":"2025-10-26T00:00:00Z","permalink":"https://example.com/p/1.yolo%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","title":"1.YOLO环境安装"},{"content":"一、脚本实现基础 1. 基本操作流程 定位识别：对文字或图像进行识别，获取其屏幕坐标。 键鼠操作：执行鼠标点击动作或键盘指令 2. 定位识别 像素构成：图像由RGB三原色像素点构成，每个像素用[0,255]范围的(R,G,B)值表示。 模板匹配：逐像素比对目标图像与屏幕截图。 高级算法：YOLO等深度学习模型通过特征降维，在压缩图像尺寸后仍能保持识别能力。 3. 键鼠操作 软件模拟：利用pywin32库 win32api.SendMessage win32api.SendMessage 硬件模拟：更底层的实现方式，通过设备（如单片机）伪造鼠标硬件信号，直接与操作系统底层驱动交互，隐蔽性更强。 4. 商业化解决方案 大漠插件：封装底层图像识别和操作API，提供傻⽠式调⽤接⼝，采用服务器验证（账号+加密）防止盗用。 奥迦插件 二、键鼠代码示例 1. 鼠标操作 1 2 3 import win32api, win32con win32api.SendMessage(hwnd, win32con.WM_LBUTTONDOWN, 0, ((y) \u0026lt;\u0026lt; 16) | x) win32api.SendMessage(hwnd, win32con.WM_LBUTTONUP, 0, ((y) \u0026lt;\u0026lt; 16) | x) 核心概念\n句柄（hwnd）：每个窗口的唯一标识符（类似身份证号），用于精确定位操作目标。 相对坐标：点击坐标是相对于目标窗口左上角的偏移量。 2. 键盘操作 1 2 3 4 5 6 7 - **关键消息**： - `WM_KEYDOWN` / `WM_KEYUP`：按键按下/释放。 - `WM_CHAR`：字符输入（由 `TranslateMessage` 将 `WM_KEYDOWN` 转换而来）。 - **虚拟键码**：如 `VK_RETURN`(回车), `VK_SHIFT`(Shift), `VK_CONTROL`(Ctrl)。 - **参数说明**： - `wParam`：携带虚拟键码。 - `lParam`：携带重复次数、扫描码等附加信息。 ","date":"2025-10-26T00:00:00Z","permalink":"https://example.com/p/%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/","title":"脚本基础"},{"content":"http://bbs.anjian.com/showtopic-566788-1.aspx https://blog.sina.com.cn/s/blog_9522b30f010119su.html\nhttps://tieba.baidu.com/p/3989538710?share=9105\u0026fr=sharewise\u0026see_lz=0\u0026share_from=post\u0026sfc=copy\u0026client_type=2\u0026client_version=12.89.1.0\u0026st=1760188693\u0026is_video=false\u0026unique=824A8C4E0644456F60814F8819DB0547\n鼠标漂移的解决方案汇总 一、图色层面 🧩 方法1：目标图定位 + 鼠标图校正（图色自校准法） 原理：\n先用 FindPic 找到目标图坐标 (tx, ty)。 直接移动鼠标到目标位置。由于存在偏移，通常点不中目标。 再次搜索鼠标箭头图片 (mx, my)，计算偏移量： 1 2 dx = tx - mx dy = ty - my 然后执行 MoveR(dx, dy) 进行相对校正。\n说明：\n只要找图准确，基本一到两次修正即可精准定位。 （修正逐渐移动？或者瞬间移动，不知道哪个效果好） 梦幻西游的图色漂移问题，就是通过这种方式解决的。\n二、内存层面 🧩 方法1：读内存坐标差值修正（内存坐标比对法） 原理：\n从游戏内存中读取当前鼠标坐标 (gx, gy)；\n同时获取系统鼠标坐标 (sx, sy)；\n计算差值：\n1 2 dx = gx - sx dy = gy - sy 执行 MoveR(dx, dy) 修正位置；\n重复检测与移动，直到偏差小于阈值（一般为 1 像素以内）。\n说明：\n这种方法属于“读内存修正法”，适用于可直接读取游戏鼠标坐标的情况。\n其本质是 用游戏坐标与系统坐标做动态闭环调整。\n🧩 方法2：锁定鼠标基址（内存基址追踪法） 原理：\n使用 CE 搜索鼠标坐标基址： 初始搜索未知数； 向左移动鼠标 → 搜索“变小的值”； 向右移动鼠标 → 搜索“变大的值”； 多次筛选直到锁定两个地址（X、Y）。 右键查看访问指令，找到 [base + offset] 结构； 将该基址固定，循环读取即可获得游戏鼠标的真实位置。 说明：\n梦幻西游的鼠标基址可以直接寻到，不需要下断点。\n找到基址后，可长期稳定读取坐标，并配合图色判断修正漂移。\n简单游上的“果壳梦幻辅助”就是基于这种原理。\n三、逻辑层面（CALL级操作） 🧩 方法：逻辑调用替代鼠标操作（逻辑CALL法） 原理：\n不再移动鼠标，而是直接调用游戏内部的逻辑函数（CALL）。\n常见例子：\nNPC对话：遍历到 NPC 基址后，调用 DialogCall(NpcID)； 背包操作：直接调用物品管理 CALL； 寻路：调用 MoveTo(x, y) 函数。 说明：\n这种方式完全绕过鼠标，直接操作游戏逻辑。\n适合高端后台脚本或工作室级辅助，性能稳定且无漂移。\n✅ 总结对比 类型 方法 核心手段 难度 稳定性 说明 图色法 图色+鼠标图校正 二次找图修正 ★ ★★★ 实现简单、兼容性好 内存法 读坐标差值 动态比对收敛 ★★ ★★★★ 精度高、可后台 内存法 锁定基址 固定地址读取 ★★★ ★★★★★ 稳定、适合长期运行 CALL法 调用游戏函数 内部逻辑执行 ★★★★★ ★★★★★ 无漂移、最高级实现 ","date":"2025-10-13T00:00:00Z","permalink":"https://example.com/p/%E5%A4%84%E7%90%86%E9%BC%A0%E6%A0%87%E6%BC%82%E7%A7%BB/","title":"处理鼠标漂移"},{"content":"一个简单的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 from datetime import datetime, timedelta, time import schedule import time def job(): print(\u0026#34;I\u0026#39;m working...\u0026#34;) def greet(name): print(\u0026#39;Hello\u0026#39;, name) ## 随机时间执行 schedule.every(5).to(10).seconds.do(job) ## 带参数执行 schedule.every(2).seconds.do(greet, name=\u0026#39;Alice\u0026#39;) schedule.every(4).seconds.do(greet, name=\u0026#39;Bob\u0026#39;) ## 每 3 second/minute/hour/day/week 执行一次 schedule.every(3).seconds.do(job) schedule.every(3).minutes.do(job) schedule.every(3).hours.do(job) schedule.every(3).days.do(job) schedule.every(3).weeks.do(job) # 每小时执行，直到指定时间停止 schedule.every().hour.until(\u0026#34;2030-01-01 18:33\u0026#34;).do(job) # 每小时执行，直到8小时后停止 schedule.every(2).hours.until(timedelta(hours=8)).do(job) # 每分钟指定秒执行一次 schedule.every().minute.at(\u0026#34;:23\u0026#34;).do(job) # 每小时指定分执行一次 schedule.every().hour.at(\u0026#34;:42\u0026#34;).do(job) # 每小时指定分/秒执行一次 schedule.every(5).hours.at(\u0026#34;20:30\u0026#34;).do(job) # 每天指定时间执行一次 schedule.every().day.at(\u0026#34;10:30\u0026#34;).do(job) schedule.every().day.at(\u0026#34;10:30:42\u0026#34;).do(job) schedule.every().day.at(\u0026#34;12:42\u0026#34;, \u0026#34;Europe/Amsterdam\u0026#34;).do(job) # 每周指定天执行一次 schedule.every().monday.do(job) schedule.every().wednesday.at(\u0026#34;13:15\u0026#34;).do(job) schedule.every().minute.at(\u0026#34;:17\u0026#34;).do(job) # 立刻把全部任务跑一遍 schedule.run_all() # 取消任务 schedule.cancel_job(job) # 获取全部任务 all_jobs = schedule.get_jobs() # 取消全部任务 schedule.clear() while True: schedule.run_pending() time.sleep(1) 使用装饰器 1 2 3 4 5 6 7 8 9 10 from schedule import every, repeat, run_pending import time @repeat(every(10).minutes) def job(): print(\u0026#34;I am a scheduled job\u0026#34;) while True: run_pending() time.sleep(1) 多进程定时任务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import threading import time import schedule def job(): print(\u0026#34;I\u0026#39;m running on thread %s\u0026#34; % threading.current_thread()) def run_threaded(job_func): job_thread = threading.Thread(target=job_func) job_thread.start() schedule.every(10).seconds.do(run_threaded, job) schedule.every(10).seconds.do(run_threaded, job) schedule.every(10).seconds.do(run_threaded, job) schedule.every(10).seconds.do(run_threaded, job) schedule.every(10).seconds.do(run_threaded, job) while 1: schedule.run_pending() time.sleep(1) ","date":"2025-10-12T00:00:00Z","permalink":"https://example.com/p/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-schedule/","title":"定时任务-schedule"},{"content":"解决python重装后，如果和老路径不一致，pycharm找不到的问题 1.系统 PATH冲突 Windows 下可能还有旧的 Python 路径残留 2.在PyCharm 中清除旧解释器配置： 打开PyCharm，进入 File \u0026gt; Settings \u0026gt; Project: [你的项目名] \u0026gt; Python Interpreter。﻿ 点击解释器列表旁边的设置图标（通常是一个齿轮图标），选择 \u0026ldquo;Show All\u0026hellip;\u0026rdquo; 或 \u0026ldquo;Add Interpreter\u0026rdquo;。﻿ 3.有时需要找到并删除位于 C:\\Users\\你的用户名\\AppData\\Roaming\\JetBrains\\PyCharm版本号\\options 目录下的 jdk.table.xml 文件来彻底清除旧的JDK 配置\n","date":"2025-09-24T00:00:00Z","permalink":"https://example.com/p/pycharm%E6%9C%AA%E8%83%BD%E8%AF%86%E5%88%AB%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84python%E8%B7%AF%E5%BE%84/","title":"PyCharm未能识别更新后的Python路径"},{"content":"硬件分类与多控系统架构 键鼠控制系统 同步器\n同步器主要分为 软件同步器 和 硬件同步器：\n软件同步器：通过驱动/中间层拦截并广播输入（键鼠事件），效率高、成本低，但容易被检测。 硬件同步器：依靠电路模拟键鼠信号，再复制到多台电脑，效果更接近真实人工操作，隐蔽性强，但价格更贵。 幽灵键鼠盒子\n幽灵键鼠盒子是一种 硬件设备，通过电路直接模拟真实的键盘、鼠标输入信号，然后发送给电脑。\n特点：输入信号在系统层面看起来和真实人工操作一致，几乎无法通过常规反外挂手段检测。 区别 : 同步器 → 用于广播键鼠信号，分为软件同步器和硬件同步器。\n幽灵键鼠 → 专门做“硬件模拟输入”，更隐蔽，常用于自动化。\n画面采集系统 采集卡\n分屏器\n补充说明：有些情况下可以用 投屏软件 + 虚拟摄像头驱动 替代采集卡，但稳定性和兼容性不如采集卡。\n多控系统架构 采集卡 + 图色脚本 + 幽灵键鼠 / 硬件同步器 → 自动化控制（电脑“自己看、自己动”） 分屏器 + 同步器 → 人工群控（人“看画面、动手操作”） 它们是两种完全不同的设计思路，服务于不同目标。\n一、自动化系统（无人值守） 目标：脚本自动识别画面并发出操作指令\n核心组件 硬件/软件 功能说明 采集卡 将手机画面传输到主控电脑，供脚本读取（充当“摄像头”角色） 图色脚本 利用 OpenCV 等识别画面状态（如是否战斗中、按钮是否出现） 幽灵键鼠/硬件同步器 根据识别结果，模拟真实键鼠信号，下发到多台手机执行 特点 不需要 分屏器（无需人工监控） 流程：手机画面 → 采集卡 → 主控电脑（脚本识别） → 逻辑判断 → 指令下发 → 幽灵键鼠/硬件同步器 → 手机执行 适用场景：挂机打怪、长期 farming、复杂逻辑（如血量低于 30% 自动吃药） 二、人工群控系统（手动操作） 目标：人工操作一套键鼠，实时控制多台设备\n核心组件 硬件 功能说明 分屏器 将主控电脑画面复制到多台显示器，便于操作员同时监控多个手机 同步器 将操作员的键鼠动作实时复制，所有手机同步执行 特点 不需要 采集卡、图色脚本（判断与操作全靠人） 流程：操作员看分屏 → 键鼠操作 → 同步器复制 → 多手机执行 三、对比表 对比项 自动化系统 人工群控系统 是否需要“看”屏幕 采集卡 + 脚本识别 分屏器 + 人眼观察 控制方式 脚本逻辑自动发指令 人工键鼠操作 是否需要编程 是（Python/OpenCV 等） 否 成本 高（硬件 + 脚本开发） 低（仅硬件） 可维护性 复杂（需调试/维护脚本） 简单（即插即用） 隐蔽性 高（模拟真人行为，难检测） 软件同步器低，硬件中等 适用任务 长期运行、复杂逻辑 短期操作、简单任务 总结一句话 采集卡 + 图色脚本 + 幽灵键鼠 / 硬件同步器 → 电脑自己“看”和“动” 分屏器 + 同步器 → 人同时“看”和“动” ","date":"2025-09-23T00:00:00Z","permalink":"https://example.com/p/%E5%A4%9A%E6%8E%A7%E6%9E%B6%E6%9E%84/","title":"多控架构"},{"content":"watchdog 是 Python 中非常常用的一个文件系统监控库，可以实时监听文件/目录的变化（增删改、移动等），经常用在日志监控、自动化构建、配置热更新、爬虫等场景。\n安装 1 pip install watchdog 基本使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import time from watchdog.observers import Observer from watchdog.events import FileSystemEventHandler # 自定义事件处理器，继承 FileSystemEventHandler # 你可以重写里面的 on_created、on_deleted、on_modified、on_moved 等方法 class MyHandler(FileSystemEventHandler): def on_created(self, event): # 当有新文件/目录被创建时触发 print(f\u0026#34;新建: {event.src_path}\u0026#34;) def on_deleted(self, event): # 当有文件/目录被删除时触发 print(f\u0026#34;删除: {event.src_path}\u0026#34;) def on_modified(self, event): # 当有文件/目录内容被修改时触发 print(f\u0026#34;修改: {event.src_path}\u0026#34;) def on_moved(self, event): # 当有文件/目录被移动或重命名时触发 print(f\u0026#34;移动: 从 {event.src_path} 到 {event.dest_path}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: # 要监听的目录，这里用 \u0026#34;.\u0026#34; 表示当前目录 path = \u0026#34;.\u0026#34; # 创建一个事件处理器对象（即上面定义的 MyHandler） event_handler = MyHandler() # 创建一个“观察者对象”，用于监控文件系统事件 observer = Observer() # 把事件处理器和要监听的目录绑定起来 # recursive=True 表示递归监听子目录 observer.schedule(event_handler, path, recursive=True) # 启动观察者（会在后台线程里跑） observer.start() try: # 主线程保持运行，不然程序会退出 while True: time.sleep(1) # 每秒休眠一次，降低 CPU 占用 except KeyboardInterrupt: # 捕获 Ctrl+C，停止观察者 observer.stop() # 等待观察者线程退出，确保资源释放干净 observer.join() 在 watchdog 里主要有两个角色：\nHandler（处理器） 就是你写的 MyHandler 类，里面定义了 “文件发生变化时要做什么”。 例如：文件创建时发通知、文件修改时自动运行脚本等等。 Observer（观察者） 真正的“监控器”，底层调用系统的文件监控 API（比如 Windows 的 ReadDirectoryChangesW、Linux 的 inotify）。 它会不断监听指定目录，一旦发现变化，就把事件交给 Handler 处理。 ","date":"2025-09-22T00:00:00Z","permalink":"https://example.com/p/watchdog/","title":"WatchDog"},{"content":"分组模式及其对象 分组的一般模式 概念： Pandas 分组通常遵循三个步骤：\n分割（split）：根据某些条件把数据分组。 应用（apply）：对每个分组进行计算。 合并（combine）：将分组结果合并成一个新的数据结构。 df.groupby(分组依据)[数据来源].使用操作() 1 2 3 4 5 6 7 8 9 10 11 12 13 import pandas as pd # 创建示例数据 data = { \u0026#39;城市\u0026#39;: [\u0026#39;北京\u0026#39;, \u0026#39;上海\u0026#39;, \u0026#39;北京\u0026#39;, \u0026#39;广州\u0026#39;, \u0026#39;上海\u0026#39;, \u0026#39;广州\u0026#39;], \u0026#39;年份\u0026#39;: [2020, 2020, 2021, 2020, 2021, 2021], \u0026#39;销售额\u0026#39;: [100, 200, 150, 300, 250, 350] } df = pd.DataFrame(data) print(df) # 分组模式：按城市分组，计算销售额总和 grouped = df.groupby(\u0026#39;城市\u0026#39;)[\u0026#39;销售额\u0026#39;].sum() print(grouped) 分组依据的本质 概念： 分组依据可以是：\n某一列（或多列） Series、数组、字典 函数（如 lambda x: x.year） 1 2 3 4 5 6 7 # 按年份分组 grouped_year = df.groupby(df[\u0026#39;年份\u0026#39;])[\u0026#39;销售额\u0026#39;].sum() print(grouped_year) # 按自定义函数分组（销售额\u0026gt;200为一组，小于等于200为另一组） grouped_custom = df.groupby(lambda x: \u0026#39;大额\u0026#39; if df.loc[x, \u0026#39;销售额\u0026#39;] \u0026gt; 200 else \u0026#39;小额\u0026#39;)[\u0026#39;销售额\u0026#39;].sum() print(grouped_custom) GroupBy对象 概念： groupby 返回一个 GroupBy 对象，它本身不会立即计算，而是惰性计算。 可以用 groups 查看分组索引。\n测试代码：\n1 2 3 grouped_obj = df.groupby(\u0026#39;城市\u0026#39;) print(type(grouped_obj)) print(grouped_obj.groups) 分组的三大操作 概念：\n聚合（Aggregation）：对每组计算汇总值。 变换（Transformation）：对每组计算一个与原数据同维度的值。 过滤（Filtering）：根据某组条件保留或删除分组。 1 2 3 4 5 6 # 聚合 print(grouped_obj[\u0026#39;销售额\u0026#39;].sum()) # 变换 print(grouped_obj[\u0026#39;销售额\u0026#39;].transform(\u0026#39;mean\u0026#39;)) # 过滤 print(grouped_obj.filter(lambda x: x[\u0026#39;销售额\u0026#39;].sum() \u0026gt; 400)) 聚合函数 内置聚合函数 概念： 常用函数： sum(), mean(), max(), min(), count()\n1 2 3 print(grouped_obj[\u0026#39;销售额\u0026#39;].mean()) print(grouped_obj[\u0026#39;销售额\u0026#39;].max()) print(grouped_obj[\u0026#39;销售额\u0026#39;].count()) agg方法 概念： agg 可以同时使用多个聚合函数，也可以自定义函数。\n1 2 3 4 # 多个聚合函数 print(grouped_obj[\u0026#39;销售额\u0026#39;].agg([\u0026#39;sum\u0026#39;, \u0026#39;mean\u0026#39;, \u0026#39;max\u0026#39;])) # 自定义函数 print(grouped_obj[\u0026#39;销售额\u0026#39;].agg(lambda x: x.max() - x.min())) 变换和过滤 变换函数与 transform 方法 概念： transform 保持原数据形状，对每个组执行函数。 适合用于归一化、填充缺失值等。\n1 2 3 # 标准化（每组减去均值再除以标准差） df[\u0026#39;销售额标准化\u0026#39;] = grouped_obj[\u0026#39;销售额\u0026#39;].transform(lambda x: (x - x.mean()) / x.std()) print(df) 组索引与过滤 概念： filter 保留满足条件的组 条件函数返回 True/False\n1 2 3 # 过滤总销售额大于400的组 filtered_df = grouped_obj.filter(lambda x: x[\u0026#39;销售额\u0026#39;].sum() \u0026gt; 400) print(filtered_df) 跨列分组 apply的引入 概念： apply 可以对每组进行任意操作，返回结果可以是不同形状。 比 agg 更灵活。\n1 2 3 4 5 6 7 # 每组增加一列，显示销售额是否高于组均值 def flag_high_sales(group): group[\u0026#39;高于均值\u0026#39;] = group[\u0026#39;销售额\u0026#39;] \u0026gt; group[\u0026#39;销售额\u0026#39;].mean() return group df_applied = grouped_obj.apply(flag_high_sales) print(df_applied) apply的使用 概念： 可以对每组返回单值、多值、甚至 DataFrame 支持复杂计算\n1 2 3 # 每组取销售额最大的记录 max_sales = grouped_obj.apply(lambda x: x[x[\u0026#39;销售额\u0026#39;] == x[\u0026#39;销售额\u0026#39;].max()]) print(max_sales) ","date":"2025-09-21T00:00:00Z","permalink":"https://example.com/p/3.pandas%E5%88%86%E7%BB%84/","title":"3.Pandas分组"},{"content":"长宽表的变形 pivot将长表转为宽表（单个聚合函数） 功能：将一列作为新列名，一列作为新行索引，填充值来自另一列。\n限制：索引和列的组合必须唯一（不能有重复）。\n语法：df.pivot(index='行索引', columns='列名', values='值')\n案例：学生成绩表（长 → 宽）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import pandas as pd # 原始长表 df_long = pd.DataFrame({ \u0026#39;学生\u0026#39;: [\u0026#39;小明\u0026#39;, \u0026#39;小明\u0026#39;, \u0026#39;小红\u0026#39;, \u0026#39;小红\u0026#39;], \u0026#39;科目\u0026#39;: [\u0026#39;数学\u0026#39;, \u0026#39;语文\u0026#39;, \u0026#39;数学\u0026#39;, \u0026#39;语文\u0026#39;], \u0026#39;成绩\u0026#39;: [85, 90, 78, 92] }) print(\u0026#34;原始长表：\u0026#34;) print(df_long) # 转为宽表 df_wide = df_long.pivot(index=\u0026#39;学生\u0026#39;, columns=\u0026#39;科目\u0026#39;, values=\u0026#39;成绩\u0026#39;) print(\u0026#34;\\npivot 转宽表：\u0026#34;) print(df_wide) #输出 原始长表： 学生 科目 成绩 0 小明 数学 85 1 小明 语文 90 2 小红 数学 78 3 小红 语文 92 pivot 转宽表： 科目 数学 语文 学生 小明 85 90 小红 78 92 pivot_table支持聚合的宽表转换（pivot 的增强版） 功能：支持聚合（如 mean, sum），可处理重复索引。\n语法:df.pivot_table(index='行',columns='列', values='值', aggfunc='mean') 案例：带重复数据的成绩表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 含重复数据（小明考了两次数学） df_repeat = pd.DataFrame({ \u0026#39;学生\u0026#39;: [\u0026#39;小明\u0026#39;, \u0026#39;小明\u0026#39;, \u0026#39;小明\u0026#39;, \u0026#39;小红\u0026#39;], \u0026#39;科目\u0026#39;: [\u0026#39;数学\u0026#39;, \u0026#39;数学\u0026#39;, \u0026#39;语文\u0026#39;, \u0026#39;数学\u0026#39;], \u0026#39;成绩\u0026#39;: [85, 88, 90, 78] }) # 使用 pivot_table 计算平均分 df_pivot_table = df_repeat.pivot_table( index=\u0026#39;学生\u0026#39;, columns=\u0026#39;科目\u0026#39;, values=\u0026#39;成绩\u0026#39;, aggfunc=\u0026#39;mean\u0026#39; ) print(\u0026#34;pivot_table（平均分）：\u0026#34;) print(df_pivot_table) #输出 科目 数学 语文 学生 小明 86.5 90 小红 78.0 NaN melt将宽表转为长表 功能：将多列合并为两列（变量名 + 值），是 pivot 的逆操作。\n语法:df.melt(id_vars='不变列', value_vars='要合并的列', var_name='变量名', value_name='值')\n案例：宽表转长表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 宽表 df_wide = pd.DataFrame({ \u0026#39;学生\u0026#39;: [\u0026#39;小明\u0026#39;, \u0026#39;小红\u0026#39;], \u0026#39;数学\u0026#39;: [85, 78], \u0026#39;语文\u0026#39;: [90, 92] }) # 转为长表 df_melt = df_wide.melt( id_vars=\u0026#39;学生\u0026#39;, value_vars=[\u0026#39;数学\u0026#39;, \u0026#39;语文\u0026#39;], var_name=\u0026#39;科目\u0026#39;, value_name=\u0026#39;成绩\u0026#39; ) print(\u0026#34;melt 转长表：\u0026#34;) print(df_melt) 输出： 学生 科目 成绩 0 小明 数学 85 1 小红 数学 78 2 小明 语文 90 3 小红 语文 92 wide_to_long处理复杂列名的宽转长 功能：适用于列名有规律（如 score_math, score_chinese）的宽表。\n案例：带前缀的宽表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 df_complex = pd.DataFrame({ \u0026#39;学生\u0026#39;: [\u0026#39;小明\u0026#39;, \u0026#39;小红\u0026#39;], \u0026#39;score_math\u0026#39;: [85, 78], \u0026#39;score_chinese\u0026#39;: [90, 92], \u0026#39;time_math\u0026#39;: [\u0026#39;2023\u0026#39;, \u0026#39;2023\u0026#39;], \u0026#39;time_chinese\u0026#39;: [\u0026#39;2023\u0026#39;, \u0026#39;2023\u0026#39;] }) # 转换 df_long = pd.wide_to_long( df_complex, stubnames=[\u0026#39;score\u0026#39;, \u0026#39;time\u0026#39;], i=\u0026#39;学生\u0026#39;, j=\u0026#39;科目\u0026#39;, sep=\u0026#39;_\u0026#39;, suffix=\u0026#39;\\w+\u0026#39; ) print(\u0026#34;wide_to_long 结果：\u0026#34;) print(df_long) 输出： score time 学生 科目 小明 math 85 2023 小红 math 78 2023 小明 chinese 90 2023 小红 chinese 92 2023 索引的变形 stack 与 unstack stack()：列转为行索引（列 → 行） unstack()：行索引转为列（行 → 列）\n案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 df = pd.DataFrame( [[85, 90], [78, 92]], index=[\u0026#39;小明\u0026#39;, \u0026#39;小红\u0026#39;], columns=[\u0026#39;数学\u0026#39;, \u0026#39;语文\u0026#39;] ) print(\u0026#34;原表：\u0026#34;) print(df) # stack：列转为内层索引 stacked = df.stack() print(\u0026#34;\\nstack()：\u0026#34;) print(stacked) # unstack：内层索引转为列 unstacked = stacked.unstack() print(\u0026#34;\\nunstack()：\u0026#34;) print(unstacked) 输出： 原表： 数学 语文 小明 85 90 小红 78 92 stack()： 小明 数学 85 语文 90 小红 数学 78 语文 92 dtype: int64 unstack()： 数学 语文 小明 85 90 小红 78 92 聚合与变形的关系 pivot_table 本质是 先聚合，再变形 groupby + unstack 可实现类似 pivot_table 的效果 案例：等价操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 df = pd.DataFrame({ \u0026#39;A\u0026#39;: [\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;b\u0026#39;], \u0026#39;B\u0026#39;: [\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;], \u0026#39;C\u0026#39;: [1, 2, 3, 4] }) # 方法1：pivot_table pt = df.pivot_table(index=\u0026#39;A\u0026#39;, columns=\u0026#39;B\u0026#39;, values=\u0026#39;C\u0026#39;, aggfunc=\u0026#39;sum\u0026#39;) # 方法2：groupby + unstack gb = df.groupby([\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;])[\u0026#39;C\u0026#39;].sum().unstack() print(\u0026#34;pivot_table:\u0026#34;) print(pt) print(\u0026#34;\\ngroupby + unstack:\u0026#34;) print(gb) 输出一致： B x y A a 1 2 b 3 4 其他变形函数 crosstab交叉表（频次统计） 功能：计算两个或多个变量的频数表。\n案例：性别与科目交叉表\n1 2 3 4 5 6 7 8 df = pd.DataFrame({ \u0026#39;性别\u0026#39;: [\u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;], \u0026#39;科目\u0026#39;: [\u0026#39;数学\u0026#39;, \u0026#39;数学\u0026#39;, \u0026#39;语文\u0026#39;, \u0026#39;语文\u0026#39;] }) ct = pd.crosstab(df[\u0026#39;性别\u0026#39;], df[\u0026#39;科目\u0026#39;]) print(\u0026#34;crosstab 交叉表：\u0026#34;) print(ct) 输出：\n1 2 3 4 科目 数学 语文 性别 女 1 1 男 1 1 explode将列表元素展开为多行 功能：将一列中的列表/元组展开，每元素占一行。\n案例：学生兴趣班\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 df = pd.DataFrame({ \u0026#39;学生\u0026#39;: [\u0026#39;小明\u0026#39;, \u0026#39;小红\u0026#39;], \u0026#39;兴趣\u0026#39;: [[\u0026#39;篮球\u0026#39;, \u0026#39;音乐\u0026#39;], [\u0026#39;绘画\u0026#39;]] }) df_exploded = df.explode(\u0026#39;兴趣\u0026#39;) print(\u0026#34;explode 展开：\u0026#34;) print(df_exploded) 输出： 学生 兴趣 0 小明 篮球 0 小明 音乐 1 小红 绘画 get_dummies独热编码（One-Hot Encoding） 功能：将分类变量转为多列 0/1。\n案例：科目独热编码\n1 2 3 4 5 6 7 8 9 10 11 12 13 df = pd.DataFrame({\u0026#39;科目\u0026#39;: [\u0026#39;数学\u0026#39;, \u0026#39;语文\u0026#39;, \u0026#39;数学\u0026#39;]}) dummies = pd.get_dummies(df[\u0026#39;科目\u0026#39;], prefix=\u0026#39;科目\u0026#39;) print(\u0026#34;get_dummies 独热编码：\u0026#34;) print(dummies) 输出： 科目_数学 科目_语文 0 1 0 1 0 1 2 1 0 总结：何时使用哪种变形？ 场景 推荐函数 长表 → 宽表（无重复） pivot 长表 → 宽表（有重复，需聚合） pivot_table 宽表 → 长表 melt / wide_to_long 列 ↔ 行索引转换 stack / unstack 频次统计表 crosstab 列表展开为行 explode 分类变量编码 get_dummies ","date":"2025-09-21T00:00:00Z","permalink":"https://example.com/p/4.pandas%E5%8F%98%E5%BD%A2/","title":"4.Pandas变形"},{"content":"什么是 PySimpleGUI PySimpleGUI 是一个封装了 Tkinter（默认）、Qt、WxPython、Remi 的 简易 GUI 框架。 它的目标：用最少的代码，快速写出桌面应用 GUI。 特点：语法直观、学习曲线低，适合初学者和快速原型开发。\nPySimpleGUI 的三大核心 布局（Layout） 界面由控件（如按钮、文本、输入框）组成，控件排布在一个二维列表中。 每一行是一个列表，整个窗口是一个大的列表。\n窗口（Window） 用 sg.Window 创建窗口。 接收标题、布局等参数。\n事件循环（Event Loop） GUI 需要不断等待用户操作（事件），比如点击按钮、输入文本。 用 window.read() 获取 event 和 values。 在 PySimpleGUI 中，event 的值通常就是你为控件设置的 key。\nPySimpleGUI 常用控件速查表 基础元素 控件类型 代码示例 说明 文本 sg.Text(\u0026quot;显示文本\u0026quot;, key=\u0026quot;text\u0026quot;) 显示一段静态文字 输入框 sg.Input(key=\u0026quot;input\u0026quot;) 单行文本输入 多行输入 sg.Multiline(size=(40, 5), key=\u0026quot;multiline\u0026quot;) 多行文本输入，支持滚动 按钮 sg.Button(\u0026quot;确定\u0026quot;, key=\u0026quot;submit\u0026quot;) 点击触发事件 图片 sg.Image(\u0026quot;logo.png\u0026quot;, key=\u0026quot;image\u0026quot;) 显示本地图片文件 选择类控件 控件类型 代码示例 说明 复选框 sg.Checkbox(\u0026quot;同意协议\u0026quot;, key=\u0026quot;chk_agree\u0026quot;) 可多选，返回布尔值 单选框 sg.Radio(\u0026quot;男\u0026quot;, \u0026quot;gender\u0026quot;, key=\u0026quot;radio_male\u0026quot;) 同一组内互斥，\u0026quot;gender\u0026quot; 为组名 下拉框 sg.Combo([\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot;], key=\u0026quot;combo_selection\u0026quot;) 下拉选择，返回选中项 列表框 sg.Listbox(values=[\u0026quot;苹果\u0026quot;, \u0026quot;香蕉\u0026quot;], size=(20, 3), key=\u0026quot;list_items\u0026quot;) 可多选或单选，返回列表 滑块 sg.Slider(range=(0, 100), key=\u0026quot;slider_value\u0026quot;) 拖动选择数值 文件与文件夹 功能 代码示例 说明 选择文件 sg.FileBrowse(key=\u0026quot;file_browse\u0026quot;) 打开文件选择对话框 保存文件 sg.FileSaveAs(key=\u0026quot;file_saveas\u0026quot;) 打开“另存为”对话框 选择文件夹 sg.FolderBrowse(key=\u0026quot;folder_browse\u0026quot;) 选择目录路径 输入+选择 [sg.Input(key=\u0026quot;file_input\u0026quot;), sg.FileBrowse(key=\u0026quot;file_browse_btn\u0026quot;)] 组合：输入框 + 文件选择按钮 进度与状态 控件类型 代码示例 说明 进度条 sg.ProgressBar(max_value=100, orientation=\u0026quot;h\u0026quot;, size=(20, 20), key=\u0026quot;progress_bar\u0026quot;) 显示任务进度，需配合更新 状态栏 sg.StatusBar(\u0026quot;就绪\u0026quot;, size=(40, 1), key=\u0026quot;status_bar\u0026quot;) 通常放在窗口底部，显示状态信息 容器布局 容器类型 代码示例 说明 框架 sg.Frame(\u0026quot;设置\u0026quot;, [[sg.Text(\u0026quot;内容\u0026quot;, key=\u0026quot;frame_text\u0026quot;)]], key=\u0026quot;frame_settings\u0026quot;) 将控件分组，带标题边框 页签 sg.Tab(\u0026quot;第一页\u0026quot;, [[sg.Text(\u0026quot;内容1\u0026quot;, key=\u0026quot;tab1_text\u0026quot;)]], key=\u0026quot;tab1\u0026quot;) 单个页签内容容器 页签组 sg.TabGroup([[tab1, tab2]], key=\u0026quot;tab_group\u0026quot;) 包含多个 Tab 的容器，实现多页界面 弹窗（Popup） 弹窗类型 代码示例 返回值 / 说明 普通提示 sg.popup(\u0026quot;消息\u0026quot;) 显示消息，点击“确定”关闭 是/否选择 sg.popup_yes_no(\u0026quot;确定吗?\u0026quot;) 返回 \u0026quot;Yes\u0026quot; 或 \u0026quot;No\u0026quot; 确定/取消 sg.popup_ok_cancel(\u0026quot;继续吗?\u0026quot;) 返回 \u0026quot;OK\u0026quot; 或 \u0026quot;Cancel\u0026quot; 文件选择 sg.popup_get_file(\u0026quot;选择文件\u0026quot;) 返回文件路径，或 None 错误提示 sg.popup_error(\u0026quot;错误!\u0026quot;) 红色主题，突出显示错误 可滚动文本 sg.popup_scrolled(\u0026quot;很多很多文字...\u0026quot;) 内容过多时可滚动查看 应用示例 输入窗口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import PySimpleGUI as sg # 1. 定义布局 layout = [ [sg.Text(\u0026#34;请输入你的名字:\u0026#34;)], [sg.Input(key=\u0026#34;name\u0026#34;)], [sg.Button(\u0026#34;确定\u0026#34;), sg.Button(\u0026#34;退出\u0026#34;)] ] # 2. 创建窗口 window = sg.Window(\u0026#34;Hello PySimpleGUI\u0026#34;, layout) # 3. 事件循环 while True: event, values = window.read() # 事件, 输入值字典 if event == sg.WIN_CLOSED or event == \u0026#34;退出\u0026#34;: break if event == \u0026#34;确定\u0026#34;: sg.popup(f\u0026#34;你好, {values[\u0026#39;name\u0026#39;]}!\u0026#34;) # 4. 关闭窗口 window.close() 👉 运行效果：\n输入名字，点“确定”，会弹出提示框。\n点“退出”或关闭窗口，就结束程序。\n登录窗口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import PySimpleGUI as sg layout = [ [sg.Text(\u0026#34;用户名:\u0026#34;), sg.Input(key=\u0026#34;username\u0026#34;)], [sg.Text(\u0026#34;密码:\u0026#34;), sg.Input(key=\u0026#34;password\u0026#34;, password_char=\u0026#34;*\u0026#34;)], [sg.Button(\u0026#34;登录\u0026#34;), sg.Button(\u0026#34;取消\u0026#34;)] ] window = sg.Window(\u0026#34;登录系统\u0026#34;, layout) while True: event, values = window.read() if event in (sg.WIN_CLOSED, \u0026#34;取消\u0026#34;): break if event == \u0026#34;登录\u0026#34;: if values[\u0026#34;username\u0026#34;] == \u0026#34;admin\u0026#34; and values[\u0026#34;password\u0026#34;] == \u0026#34;123\u0026#34;: sg.popup(\u0026#34;登录成功!\u0026#34;) else: sg.popup(\u0026#34;用户名或密码错误!\u0026#34;) window.close() 文件选择器 1 2 3 4 5 6 7 import PySimpleGUI as sg layout = [ [sg.Text(\u0026#34;选择文件:\u0026#34;), sg.Input(key=\u0026#34;file\u0026#34;), sg.FileBrowse()], [sg.Button(\u0026#34;提交\u0026#34;), sg.Button(\u0026#34;退出\u0026#34;)] ] window = sg.Window(\u0026#34;文件选择器\u0026#34;, layout) while True: event, values = window.read() if event in (sg.WIN_CLOSED, \u0026ldquo;退出\u0026rdquo;): break if event == \u0026ldquo;提交\u0026rdquo;: sg.popup(f\u0026quot;你选择的文件是:\\n{values[\u0026lsquo;file\u0026rsquo;]}\u0026quot;)\nwindow.close()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ## 简单记事本 ```python import PySimpleGUI as sg layout = [ [sg.Multiline(size=(40, 10), key=\u0026#34;text\u0026#34;)], [sg.Button(\u0026#34;保存\u0026#34;), sg.Button(\u0026#34;退出\u0026#34;)] ] window = sg.Window(\u0026#34;记事本\u0026#34;, layout) while True: event, values = window.read() if event in (sg.WIN_CLOSED, \u0026#34;退出\u0026#34;): break if event == \u0026#34;保存\u0026#34;: with open(\u0026#34;note.txt\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: f.write(values[\u0026#34;text\u0026#34;]) sg.popup(\u0026#34;保存成功!\u0026#34;) window.close() 基本事件循环模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import PySimpleGUI as sg layout = [ [sg.Text(\u0026#34;名字:\u0026#34;), sg.Input(key=\u0026#34;name\u0026#34;)], [sg.Button(\u0026#34;确定\u0026#34;), sg.Button(\u0026#34;退出\u0026#34;)] ] window = sg.Window(\u0026#34;Demo\u0026#34;, layout) while True: event, values = window.read() if event in (sg.WIN_CLOSED, \u0026#34;退出\u0026#34;): break if event == \u0026#34;确定\u0026#34;: sg.popup(f\u0026#34;你好, {values[\u0026#39;name\u0026#39;]}!\u0026#34;) window.close() 引用注册装饰器注册事件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 import PySimpleGUI as sg # ============================== # 全局登记本：按钮 → 对应函数 # ============================== event_handlers = {} def register_event(event_name): \u0026#34;\u0026#34;\u0026#34;装饰器：登记事件处理函数\u0026#34;\u0026#34;\u0026#34; def decorator(func): event_handlers[event_name] = func return func return decorator # ============================== # 功能函数：加减乘除 # ============================== @register_event(\u0026#34;加法\u0026#34;) def add(values): try: a, b = float(values[\u0026#34;num1\u0026#34;]), float(values[\u0026#34;num2\u0026#34;]) sg.popup(f\u0026#34;结果: {a} + {b} = {a + b}\u0026#34;) except ValueError: sg.popup_error(\u0026#34;请输入数字！\u0026#34;) @register_event(\u0026#34;减法\u0026#34;) def sub(values): try: a, b = float(values[\u0026#34;num1\u0026#34;]), float(values[\u0026#34;num2\u0026#34;]) sg.popup(f\u0026#34;结果: {a} - {b} = {a - b}\u0026#34;) except ValueError: sg.popup_error(\u0026#34;请输入数字！\u0026#34;) @register_event(\u0026#34;乘法\u0026#34;) def mul(values): try: a, b = float(values[\u0026#34;num1\u0026#34;]), float(values[\u0026#34;num2\u0026#34;]) sg.popup(f\u0026#34;结果: {a} × {b} = {a * b}\u0026#34;) except ValueError: sg.popup_error(\u0026#34;请输入数字！\u0026#34;) @register_event(\u0026#34;除法\u0026#34;) def div(values): try: a, b = float(values[\u0026#34;num1\u0026#34;]), float(values[\u0026#34;num2\u0026#34;]) if b == 0: sg.popup_error(\u0026#34;除数不能为 0！\u0026#34;) else: sg.popup(f\u0026#34;结果: {a} ÷ {b} = {a / b}\u0026#34;) except ValueError: sg.popup_error(\u0026#34;请输入数字！\u0026#34;) # ============================== # GUI 布局 # ============================== layout = [ [sg.Text(\u0026#34;数字1:\u0026#34;), sg.Input(key=\u0026#34;num1\u0026#34;)], [sg.Text(\u0026#34;数字2:\u0026#34;), sg.Input(key=\u0026#34;num2\u0026#34;)], [sg.Button(\u0026#34;加法\u0026#34;), sg.Button(\u0026#34;减法\u0026#34;), sg.Button(\u0026#34;乘法\u0026#34;), sg.Button(\u0026#34;除法\u0026#34;)], [sg.Button(\u0026#34;退出\u0026#34;)] ] window = sg.Window(\u0026#34;装饰器计算器\u0026#34;, layout) # ============================== # 事件循环 # ============================== while True: event, values = window.read() if event in (sg.WIN_CLOSED, \u0026#34;退出\u0026#34;): break handler = event_handlers.get(event) if handler: handler(values) window.close() ","date":"2025-09-21T00:00:00Z","permalink":"https://example.com/p/pysimplegui/","title":"PySimPleGUI"},{"content":"https://zhuanlan.zhihu.com/p/691339803\n什么是嵌入式打包？ 嵌入式解释器（Windows embeddable package） 是 Python 官方专门提供给“打包场景”的：\n从 python.org/downloads/windows/ 下载 Windows embeddable package (32/64-bit)。 它是一个绿色版 zip 包，不需要安装，解压后就是一个最小可运行的 Python。 适合用来嵌入到 PyStand / PyInstaller / cx_Freeze 等打包工具里。 适用版本：Python 3.5 及以上（因为嵌入式解释器是 3.5 开始提供的）。 嵌入式解释器和开发环境的版本保持一致 打包原理 你把这个 embeddable 包解压到你的项目目录。 把你写的 Python 脚本（或编译成 .pyc/.pyd/.pyo）放进去。 配置好 pythonXY._pth 文件（类似虚拟环境的 sys.path 设置），让它能找到你项目的依赖。 区别于 PyInstaller、cx_Freeze 等工具 PyInstaller：把代码和解释器打成一个单独 exe。 Embeddable：保留一个完整的独立 Python 环境 + 你的程序，更像是“便携版 Python + 应用”。 如果你下载了 python-3.12.9-embed-amd64.zip，解压后结构大概是：\n1 2 3 |-- python.exe |-- python312.zip ← 标准库，不用解压占用空间小，Python 启动时直接从 zip 里加载模块。 |-- python312._pth ← 配置搜索路径 打包准备 准备代码 main.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import sys import numpy as np import pandas as pd from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget, QLabel from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas from matplotlib.figure import Figure class MplCanvas(FigureCanvas): \u0026#34;\u0026#34;\u0026#34;Ultimately, this is a QWidget (as well as a FigureCanvasAgg, etc.).\u0026#34;\u0026#34;\u0026#34; def __init__(self, parent=None, width=5, height=4, dpi=100): fig = Figure(figsize=(width, height), dpi=dpi) self.axes = fig.add_subplot() # 初始化父类 super(MplCanvas, self).__init__(fig) class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() # 创建MplCanvas实例作为窗口中的中央部件 self.canvas = MplCanvas(self, width=5, height=4, dpi=100) # 生成数据并绘制 x_values = np.linspace(0, 2 * np.pi, num=200) y_values = np.sin(x_values) df = pd.DataFrame({\u0026#39;x\u0026#39;: x_values, \u0026#39;sin(x)\u0026#39;: y_values}) self.canvas.axes.plot(x_values, y_values, label=\u0026#39;Sine Function\u0026#39;) # 设置图表标题、坐标轴标签等 self.canvas.axes.set_xlabel(\u0026#39;X axis (x)\u0026#39;) self.canvas.axes.set_ylabel(\u0026#39;Y axis(sin(x))\u0026#39;) self.canvas.axes.set_title(\u0026#39;y = sin(x)\u0026#39;) self.canvas.axes.legend() # 布局管理 layout = QVBoxLayout() layout.addWidget(self.canvas) self.text=QLabel(str(df.info)) layout.addWidget(self.text) container = QWidget() container.setLayout(layout) self.setCentralWidget(container) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) main_win = MainWindow() main_win.show() sys.exit(app.exec_()) 准备虚拟环境 pycharm创建虚拟环境项目，将代码文件放进去,运行一次\n使用pystand壳打包 1.下载pystand项目中的pystand程序，这是一个C++编写的壳，用来调用python解释器运行代码。\n你也可以不用这个壳，直接bat命令调用python解释器运行main.py文件，但这样多少显得不太美观。\nhttps://github.com/skywind3000/PyStand/releases\n只需要看这两个就行，一个是py38-x64，一个是py38，分别对应64位解释器和32位解释器，同时也对应了64位的pystand及32位的pystand，请注意这俩一定要对应上。不能用32位的pystand去运行64位的python解释器。\n其他Releases版本内包含的pyqt5,pyside2等，都是32位的 pystand-v1.1.1-exe.zip，这个Releases版本也挺重要的，里面包含了无界面与有界面的pystand壳，适用于不同的应用场合，看你的项目是否需要命令行界面（那个黑框）。\n2.本文以64位为例，下载PyStand-py38-x64.7z。下载到本地后，它应该长这样。 runtime文件夹里面放的是python embeddable解释器，这里面自带的是python3.8.10。 site-packages里面放的是第三方库，空的。 pystand.exe是一个c++写的壳，双击即可运行 pystand.int中保存的是python代码，你可以理解为main.py文件，这个文件中必须是python代码（注意哦，必须是明文代码，原因可以去看pystand源码），用作程序入口。 你可以选择将runtime文件夹里面的内容删掉，自己去官网下载其他版本的python embeddable解释器，我这里以python 3.12为例， python.org/downloads/windows/ 去官网下载，并替换runtime文件夹中的文件。\n3.将你的项目所依赖的虚拟环境下的site-package文件夹下所有内容copy到pystand的site-package文件夹下，请注意，如果你的项目所依赖的虚拟环境并不是特别的干净，比如还有项目根本没用到的scipy库等，我建议你重新新建虚拟环境，安装好依赖后拷贝。（其实拷贝系统环境也行，就是一般没那么干净。有很多冗余的库）\n（这步操作一般没啥问题，但是有些第三方库不讲武德，比如最新版torch库，它把二进制依赖dll文件扔到sitepackage外面，只复制sitepackage里面的内容，会报错dll load failed，这种时候有其他的处理办法）\n到这儿，打包程序的环境配置完毕。\n4，在pystand目录下，新建script目录，将程序代码拷贝到里面去。并对代码入口做简要修改，注释掉 if name == \u0026lsquo;main\u0026rsquo;:，新建入口函数，名称随意，这里以start为例。\n1 2 3 4 5 6 7 8 9 10 11 12 def start(): app = QApplication(sys.argv) main_win = MainWindow() main_win.show() sys.exit(app.exec_()) # if __name__ == \u0026#39;__main__\u0026#39;: # app = QApplication(sys.argv) # main_win = MainWindow() # main_win.show() # sys.exit(app.exec_()) 5，修改pystand.int中的代码，以文本编辑器打开该文件，直接清空内容，输入以下代码。这样就表示，从start函数启动程序。\n1 2 3 4 from main import start if __name__ == \u0026#34;__main__\u0026#34;: #运行入口函数 start() 但是第4步我们将main.py文件扔到了scripts文件夹下，程序是不知道main.py文件在哪儿的，所以会报错： from main import start ModuleNotFoundError: no module named \u0026ldquo;main\u0026rdquo; 去改runtime文件夹里面的._pth文件，加一行../scripts就ok了\n1 2 3 4 5 python312.zip . ../scripts # Uncomment to run site.main() automatically import site 6，双击pystand.exe，运行程序，可得到如期结果。到这儿，打包算初步完成。\n如果不能如期运行，可以使用cmd命令运行pystand.exe，可以查看到报错信息。\n如果需要自定义程序名字，需要同时修改pystand.exe及http://pystand.int两个文件，保持同名即可。\n如果觉得保持同名很麻烦，想允许用户自己随便改名，那么请将http://pystand.int改名为http://pystand_static.int即可。\n如果觉得int文件有点碍眼，那就得修改pystand源码了，稍微改一下就可以让pystand去runtime里面找int文件，就可以藏起来了。（但是不推荐改，最好用韦神提供的exe，他拿去报白名单了，报毒概率低哦）\n如果需要自定义程序图标，请使用Resource Hacker 更换图标，非常简单。\n程序源代码是以源码形式放在script目录中的，建议使用nuitka批量将py文件转为pyd文件，提升运行速度的同时隐藏了源码。\n体积优化 优化第一步 删除不需要的固有第三方库，请删除sitepackage文件夹下的pip，pip-info，wheel，wheel-info，setuptools，setuptools-info，合计6个文件夹，这大概是15M。请删除runtime文件夹下的get-pip.py文件，这个是python官方提供拿来安装pip的，不需要。\n优化第二步 使用神秘脚本删除程序运行不需要的第三方库文件。\n请到下面的链接获取，如果觉得好用，请大力宣传哦！\n打包瘦身脚本：https://github.com/mengdeer589/PythonSizeCruncher\n请仔细阅读该脚本使用说明，本文仅展示瘦身效果。\n注意注意：请对sitepackage文件夹使用哦，本脚本对runtime文件夹内的文件没有识别能力。\n加密源码 按照本文所推荐的打包方式，源码其实是放在script文件夹中，以python源码的形式存放的。现在我们来简单加密一下，不让别人随随便看见。\n请安装nuitka，然后对你的代码文件夹，使用\u0026ndash;module命令，将源码编译为pyd文件。上面已经提到了详细命令。\n而pyd文件比pyc文件安全的多，它类似于dll文件，一般人很难破解，想逆向还原源码，那更是不可能。\n但是pyd文件作为一个依赖模块，是可以直接通过dir函数查看其暴露的接口的，所以请将重要变量匿名化（不能被import，dir出来）\n常见问题 打包tkinter模块 官方提供的嵌入式解释器并不包含pip工具，以及tkinter模块，下面的步骤是怎么补上这个tkinter模块。\n注：本方法目的在于后续可以复用，所以并不按照官方的目录结构来。\n①复制tkinter模块。从已经安装了tkinter模块的相同python解释器环境中复制，该模块通常位于解释器的Lib文件夹下，将tkinter文件夹复制到pystand/runtime/Lib文件夹下，注意，这里需要新建一个Lib文件夹。\n②复制tcl文件夹里面所有的文件，到pystand/runtime/Lib文件夹下，tcl文件夹通常位于解释器的同级目录。\n③复制二进制模块。复制_tkinter.pyd，tcl86t.dll，tk86t.dll三个文件到pystand/runtime/Lib文件夹下，这三个文件通常位于解释器的DLLs文件夹下。\n④修改路径。修改runtime文件夹里面的python310._pth文件，增加一行./Lib。注意，这里有个点，代表同级目录的Lib文件夹。\ntips:20240907更新，若打包python版本为3.12，tkinter打包时，需复制系统python3.12解释器dlls文件夹下的zlib1.dll到pystand/runtime/Lib文件夹下。\n现在可以运行程序了。如果后续还需要打包tkinter模块。直接复制这里弄好的Lib文件夹跟._pth文件到runtime文件夹下即可实现复用。\n","date":"2025-09-20T00:00:00Z","permalink":"https://example.com/p/pystand%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/","title":"Pystand打包工具"},{"content":"Python调用大漠插件注意事项 管理员权限\nPyCharm 必须 以管理员身份运行（或者你用 python.exe 直接运行也要管理员权限）。 Python 必须是 32 位版本\n大漠插件本身是 32 位的 COM 组件，所以只能在 32 位 Python 下调用。 注册方式 传统方式（注册调用） 以前要调用大漠插件（dm.dll），需要先用 regsvr32 dm.dll来进行注册。这样做的实质是把COM 组件的信息写入 Windows 注册表，让系统知道 dm.dll 是一个 COM 对象，可以用 CreateObject(\u0026quot;dm.dmsoft\u0026quot;) 或者 new ActiveXObject(\u0026quot;dm.dmsoft\u0026quot;) 来创建。\n缺点：\n必须有管理员权限才能注册。 污染注册表，易被游戏检测 无注册方式（DmReg.dll） 从 大漠插件 3.1235 版本开始，可以用 DmReg.dll来绕过注册表，直接加载对应的dm.dll，也就是说你不需要再用regsvr32，只要在程序启动时调用 DmReg.dll 的接口就行。\nDmReg.dll暴露了 两个导出函数：\nSetDllPathA(const char* path, int mode) 参数 1：ASCII 字符串（插件所在路径，比如 \u0026quot;C:\\\\dm\u0026quot;）。 参数 2：线程模型（0=STA，1=MTA）。 SetDllPathW(const wchar_t* path, int mode) 参数 1：Unicode 字符串（同上）。 参数 2：线程模型（0=STA，1=MTA）。 调用这个函数后，dmreg.dll 会把路径下的 dm.dll 注册到内存中（只对当前进程生效），不依赖系统注册表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import ctypes import os from win32com.client import Dispatch def 注册大漠(注册码=\u0026#39;\u0026#39;, 附加码=\u0026#39;\u0026#39;): print(\u0026#39;正在初始化\u0026#39;) # 通过调用DmReg.dll注册大漠 这样不会把dm.dll写到系统中，从而实现免注册 patch = ctypes.windll.LoadLibrary(os.path.dirname(__file__) + \u0026#39;./DmReg.dll\u0026#39;) patch.SetDllPathW(os.path.dirname(__file__) + \u0026#39;./dm.dll\u0026#39;, 0) dm_主对象 = Dispatch(\u0026#39;dm.dmsoft\u0026#39;) # 创建对象 ver = dm_主对象.ver() print(\u0026#39;免注册调用初始化成功 版本号为:\u0026#39;, ver) # 注册大漠VIP if ver != \u0026#39;\u0026#39;: reg = dm_主对象.reg(注册码, 附加码) if reg == 1: print(\u0026#34;大漠vip注册成功\u0026#34;) return dm_主对象 else: print(f\u0026#34;大漠注册失败,错误代码: {reg}\u0026#34;) BindWindow 为什么需要 BindWindow？ BindWindow 是大漠插件的核心函数，建立上下文,用于将鼠标、键盘、图色等操作绑定到指定窗口，实现前台或后台自动化。\nBindWindow共有5个参数，其中第5个可选。\n1 result = dm.BindWindow(hwnd, display, mouse, keypad, mode) 参数 类型 必填 说明 hwnd 整数 (Integer) 必填 窗口句柄（Window Handle）。通常通过 dm.FindWindow 或 dm.FindWindowEx 获取。代表你要绑定的目标窗口。 display 字符串 (String) 必填 显示模式，决定如何获取窗口图像（用于图色、截图）。\n常见值：\n- \u0026quot;gdi\u0026quot;：GDI 模式，兼容性好，仅支持前台。\n- \u0026quot;dx\u0026quot; / \u0026quot;dx2\u0026quot;：DirectX 模式，支持后台截图和图色。\n- \u0026quot;opengl\u0026quot;：OpenGL 模式，用于 OpenGL 应用。\n- \u0026quot;normal\u0026quot;：普通模式。 mouse 字符串 (String) 必填 鼠标模式，决定鼠标操作的方式。\n常见值：\n- \u0026quot;windows\u0026quot;：前台鼠标（真实移动）。\n- \u0026quot;dx\u0026quot; / \u0026quot;dx2\u0026quot;：后台鼠标（发送消息）。\n- \u0026quot;windows2\u0026quot;：前台鼠标，支持某些特殊窗口。\n- \u0026quot;dx.mouse.position\u0026quot;：DX 高精度鼠标定位。 keypad 字符串 (String) 必填 键盘模式，决定键盘输入的方式。\n常见值：\n- \u0026quot;windows\u0026quot;：前台按键（真实按键）。\n- \u0026quot;dx\u0026quot; / \u0026quot;dx2\u0026quot;：后台按键（发送消息）。\n- \u0026quot;dx.keypad\u0026quot;：DX 优化键盘输入。\n- \u0026quot;normal\u0026quot;：普通键盘模式。 mode 整数 (Integer) 可选 附加模式，用于控制绑定行为。\n常用值：\n- 0：默认模式。\n- 1：强制绑定，即使窗口不可见也尝试绑定。\n- 2：绑定时不激活窗口（推荐用于后台脚本）。\n- 3：组合模式（如 1+2）。\n默认值为 0。 参数使用示例 普通前台绑定（适用于记事本、浏览器等） 1 2 hwnd = dm.FindWindow(\u0026#34;Notepad\u0026#34;, \u0026#34;无标题 - 记事本\u0026#34;) dm.BindWindow(hwnd, \u0026#34;gdi\u0026#34;, \u0026#34;windows\u0026#34;, \u0026#34;windows\u0026#34;, 0) DX 游戏后台绑定（推荐） 1 2 hwnd = dm.FindWindow(\u0026#34;GameWindow\u0026#34;, \u0026#34;My Game\u0026#34;) dm.BindWindow(hwnd, \u0026#34;dx\u0026#34;, \u0026#34;dx\u0026#34;, \u0026#34;dx\u0026#34;, 2) #mode=2: 不激活窗口 OpenGL应用绑定 1 2 hwnd = dm.FindWindow(\u0026#34;GLApp\u0026#34;, \u0026#34;OpenGL Viewer\u0026#34;) dm.BindWindow(hwnd, \u0026#34;opengl\u0026#34;, \u0026#34;opengl\u0026#34;, \u0026#34;opengl\u0026#34;, 0) 关键要点\n五个参数必须匹配：display、mouse、keypad 建议使用相同技术（如都用 \u0026ldquo;dx2\u0026rdquo;），避免兼容性问题。 mode=2 很重要：用于后台脚本，防止窗口被意外激活。 绑定后需验证：检查返回值： 1：绑定成功 0：失败（可能模式不支持或窗口无效） 1 2 3 4 if dm.BindWindow(hwnd, \u0026#34;dx2\u0026#34;, \u0026#34;dx2\u0026#34;, \u0026#34;dx2\u0026#34;, 2) == 1: print(\u0026#34;绑定成功，可进行后台操作\u0026#34;) else: print(\u0026#34;绑定失败，请检查模式或窗口\u0026#34;) 总结BindWindow 的 5 个参数分别控制：\n绑定哪个窗口（hwnd） 如何显示/截图（display） 如何模拟鼠标（mouse） 如何模拟键盘（keypad） 附加行为控制（mode） 正确配置这5个参数，是实现稳定、高效自动化（尤其是后台操作）的基础。 大漠插件截图是否根据窗口句柄？ 核心答案：\n大漠插件的 CapturePic 命令本身不直接使用窗口句柄（hwnd）作为参数，而是基于屏幕坐标进行截图。但通过 BindWindow 绑定窗口句柄后，可以间接实现“基于窗口句柄”的精准截图。\n详细解析 1. CapturePic 的基本用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 dm.CapturePic(x1, y1, x2, y2, \u0026#34;output.bmp\u0026#34;) •参数：x1, y1, x2, y2 是屏幕绝对坐标。 •原理：直接从屏幕缓冲区读取指定矩形区域的像素。 •不依赖句柄：即使不调用 BindWindow，也能执行 。 所以严格来说，CapturePic不是“根据窗口句柄”截图，而是“根据屏幕坐标”截图。 2. 为什么感觉“根据句柄截图”？因为最佳实践流程中，我们通过句柄获取窗口位置，再用位置去截图： # 1. 通过窗口类名/标题找到句柄 hwnd = dm.FindWindow(\u0026#34;Notepad\u0026#34;, \u0026#34;无标题 - 记事本\u0026#34;) # 2. 获取窗口在屏幕上的位置 left, top, right, bottom = dm.GetWindowRect(hwnd) # 例如：(100, 100, 900, 700) # 3. 截取整个窗口区域 dm.CapturePic(left, top, right, bottom, \u0026#34;window.bmp\u0026#34;) # 4. 或只截客户区（游戏画面区域） client_left, client_top, client_right, client_bottom = dm.GetClientSize(hwnd) dm.CapturePic(left + client_left, top + client_top, left + client_right, top + client_bottom, \u0026#34;client.bmp\u0026#34;) 在这个流程中：•句柄 (hwnd) 用于获取窗口位置。•位置 转化为屏幕坐标。•CapturePic 使用这些坐标截图。所以，句柄是“间接工具”，真正截图的是坐标。 对比：绑定窗口后截图（更推荐）# 绑定窗口（内部保存了句柄和上下文） dm.BindWindow(hwnd, \u0026#34;gdi\u0026#34;, \u0026#34;windows\u0026#34;, \u0026#34;0\u0026#34;) # 获取窗口矩形 left, top, right, bottom = dm.GetWindowRect(hwnd) # 基于句柄获取的位置截图 dm.CapturePic(left, top, right, bottom, \u0026#34;game.bmp\u0026#34;) BindWindow 后，大漠插件可以更高效地管理窗口上下文，确保截图与图色、鼠标操作坐标系统一致。 ","date":"2025-09-17T00:00:00Z","permalink":"https://example.com/p/%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/","title":"大漠插件"},{"content":"ghostbox.pyd #将该文件放入ddls下面D:\\software\\Python312\\DLLs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import ghostbox as gb import time # 打开设备 #按索引打开设备，返回 1 = 成功。index 即设备编号/ID（0 开始） # if gb.opendevice(0) != 1: # raise Exception(\u0026#34;幽灵键鼠设备打开失败\u0026#34;) #按 VID/PID 打开设备 if gb.opendevicebyid(20872,6145) == 1: print(\u0026#34;设备已连接，型号:\u0026#34;, gb.getmodel()) else: print(\u0026#34;设备打开失败，请检查 ID 或设备连接\u0026#34;) # 移动鼠标到指定位置 x, y = 200, 200 gb.movemouseto(x, y) print(f\u0026#34;鼠标移动到: ({x},{y})\u0026#34;) # 稍等几秒，观察效果 time.sleep(2) # 结束 if hasattr(gb, \u0026#34;closedevice\u0026#34;): gb.closedevice() ","date":"2025-09-17T00:00:00Z","permalink":"https://example.com/p/%E5%B9%BD%E7%81%B5%E9%94%AE%E9%BC%A0/","title":"幽灵键鼠"},{"content":"CPU 的“位” 32 位指的是什么？ CPU 的位数 = 寄存器宽度 + ALU 运算位宽 + 地址总线宽度 寄存器宽度 = 32 位 → 每个寄存器能存 4 字节数据 ALU = 32 位 → 一次运算处理 32 位数据 地址总线 = 32 位 → 可寻址空间 = 2³² 字节 = 4GB ✅ 关键点：“32 位”不是随便说的，而是 CPU 各个核心部件设计的一致结果。\n寄存器宽度 → 决定数据存储/运算能力 地址总线宽度 → 决定最大内存寻址范围 ALU 宽度 → 决定一次能处理多少位的数据 CPU 操作寄存器与内存的区别 CPU 访问寄存器的方式 位置：CPU 内部的小型高速存储 寄存器存的是什么：数据本身（整数、浮点数、指针等） 访问方式：直接访问 例：MOV EAX, 5 → EAX 直接存储数值 5（32 位） 特点：容量小、速度最快 CPU 访问内存的方式 位置：CPU 外部的大容量存储\n内存存的是什么：数据（通过地址编号访问）\n访问方式：CPU 自身不能“存储”内存地址编号，它只是通过地址总线发出地址信号到内存，从而读写对应位置的数据。\n例：MOV EAX, [0x1000] → CPU 按地址 0x1000 取数据到 EAX CPU 内存寻址规则\n地址总线宽度：32 位 → 可表示 2³² 个不同的地址编号\n最小寻址单位：1 个地址编号对应 1 字节（8 位）\n最大寻址范围：2³² × 1B = 4GB\n关键点：\nCPU 访问的是 地址编号，而不是数据本身 数据必须通过地址读取到寄存器或 ALU 才能操作 对比总结 存储位置 存储内容 访问方式 特点 寄存器 数据本身 直接读写 极快，数量少 内存 数据（地址定位） 先通过地址寻址再取/存 容量大，速度慢 类比记忆 寄存器 = 手里的小盒子 直接装数据，随取随用 内存 = 仓库 需要地址（门牌号）才能去取东西 寄存器可以先装一个地址，再让 CPU 按地址访问仓库 核心结论 寄存器宽度 = CPU 位数，决定一次能存多少数据（32 位 = 4 字节）。 地址总线宽度 = CPU 位数，决定最大可寻址内存（32 位 = 4GB）。 寄存器存的是数据，内存是通过地址访问的数据。 CPU 运行时往往是：寄存器里存放一个地址 → 再去内存取数据。 内存 每个应用程序都会有自己的独立 4GB 内存空间。\n注意：这里的“内存”指的是程序可用的虚拟内存空间，而不是物理内存条。\n内存与寄存器的区别 寄存器\nCPU 内部的小型高速存储 数量有限、造价高 可以给每个寄存器取名字（例如 EAX、EBX） 内存\n外部大容量存储 太大无法命名，因此使用 编号 编号称为 内存地址 CPU 访问内存的数据单位 内存地址宽度：32 位 → 地址编号由 32 个二进制位表示\n一般使用 16 进制表示，例如：0x00000000 最小寻址单位：1 个地址对应 1 字节（8 位）\n程序可访问内存范围：0x00000000 ~ 0xFFFFFFFF\n可存储的位数计算：\n总块数 = 0xFFFFFFFF + 1（加 1 是因为编号从 0 开始） 每块 1 字节 = 8 位 总位数 = (0xFFFFFFFF + 1) × 8 换算为容量： 1 2 3 4 34359738368 Bit ÷ 8 = 4294967296 Byte 4294967296 Byte ÷ 1024 = 4194304 KB 4194304 KB ÷ 1024 = 4096 MB 4096 MB ÷ 1024 = 4 GB ✅ 因此，每个程序都有独立的 4GB 虚拟内存空间。\n寄存器与内存的区别 基本特点 寄存器\n位于 CPU 内部，高速执行 数量有限、造价高 可以命名（如 EAX、BX、AH 等） 内存\n外部大容量存储，速度相对较慢 成本低，可以做得很大 数量庞大，无法逐个命名，只能用编号（地址）代替 共同点\n都是存储数据的容器 都是定宽的（都有最大存储范围） 计量单位 计算机常用\nBYTE（字节） = 8 bit WORD（字） = 16 bit DWORD（双字） = 32 bit 生活中常用\n1 KB = 1024 Byte 1 MB = 1024 KB 1 GB = 1024 MB 32 位 / 64 位计算机的含义 误区：不是说 32 位 CPU 寄存器或内存最大宽度是 32 bit 正确理解： CPU 的位数主要指 最大寻址范围 CPU 中可能存在大于 32 位的寄存器，但寻址时地址不能超过 32 位 CPU 通过地址编号找到内存或寄存器中的数据 内存编号与地址 寄存器命名：数量少，可以取名字 内存编号：数量庞大，无法命名，用编号表示 → 这就是 内存地址 编号生成原理\n32 位地址线 = 32 根线路，每根线 0 或 1 32 根线的组合可表示 2³² 个编号 每个编号对应 1 字节（8 位） 通过编号 CPU 可以找到对应的内存单元 32 位地址表示 用 16 进制 表示：8 位十六进制数，如 0x00000000 ~ 0xFFFFFFFF 每个地址编号对应 1 字节（8 位） 可寻址内存计算\n地址总数：0xFFFFFFFF - 0x00000000 + 1 = 0x100000000 转换为十进制：2^32 = 4,294,967,296 个字节 = 约 4 GB 换算过程\n1 2 3 4,294,967,296 Byte ÷ 1024 = 4,194,304 KB 4,194,304 KB ÷ 1024 = 4,096 MB 4,096 MB ÷ 1024 = 4 GB ","date":"2025-09-03T00:00:00Z","permalink":"https://example.com/p/05.%E5%86%85%E5%AD%98/","title":"05.内存"},{"content":"寄存器 寄存器的基本概念 计算机存储数据的地方，有三个地方：CPU \u0026gt; 内存 \u0026gt; 硬盘 其中，寄存器是指 CPU 内部用来存储数据的高速存储单元。 如果你使用的是一个 32 位的 CPU，那么它能提供的寄存器通常有：8 位、16 位、32 位的访问形式。\n通用寄存器 在 CPU 里面，寄存器分很多类：\n通用寄存器（General Purpose Register, GPR） → 可以存数据、存地址、存中间运算结果，用途比较广。 专用寄存器 → 有固定功能，不能随便用，比如： EIP：指令指针寄存器，存放下一条要执行指令的地址 EFLAGS：标志寄存器，存放运算结果的标志位（零/进位/溢出等） 段寄存器：负责内存分段管理 因为通用寄存器不像 EIP、EFLAGS 那样被“锁死”在某个功能上，而是灵活多用，所以才叫 通用。\nx86 架构中的 32 位通用寄存器 在 32 位 CPU 中，常见的通用寄存器有 8 个：\n寄存器 编号 存储数据范围 EAX 0 0 - 0xFFFFFFFF ECX 1 0 - 0xFFFFFFFF EDX 2 0 - 0xFFFFFFFF EBX 3 0 - 0xFFFFFFFF ESP 4 0 - 0xFFFFFFFF EBP 5 0 - 0xFFFFFFFF ESI 6 0 - 0xFFFFFFFF EDI 7 0 - 0xFFFFFFFF 每个寄存器都是独立的存储单元 每个寄存器固定大小：32 位 → 4 字节 它们可以同时存储不同的数据，互不干扰，EAX 装的数据不会“占用” EBX、ECX 的空间。 虽然名字上都算“通用寄存器”，但在实际编程时它们会有习惯性用途：虽然名字上都叫“通用寄存器”，但在实际编程时，它们往往有习惯性用途：\nEAX：累加器（运算结果常放在这） ECX：计数器（循环次数常放这） EDX：数据寄存器（扩展乘除法时存高位） EBX：基址寄存器（有时存地址） ESI / EDI：源地址 / 目的地址寄存器（字符串操作常用） ESP / EBP：与栈相关（函数调用时常用） 但这些用途不是强制的，编译器或程序员完全可以把它们当普通存储单元来使用。\n子寄存器 1.子寄存器概念\n一个寄存器内部可以继续拆分成更小的“子寄存器”。\n1 2 3 4 5 EAX (32位) = 0x12345678 ├── 高16位 = 0x1234 ← 没有专门的寄存器名 └── AX (低16位) = 0x5678 ├── AH (高8位) = 0x56 └── AL (低8位) = 0x78 修改 AL → AX / EAX 的低 8 位会被改变 修改 AX → EAX 的低 16 位会被改变 修改 EAX → 整个 32 位寄存器会被改变 这些修改不会影响其他寄存器（如 EBX、ECX） 1 2 3 4 5 可以在OllyDbg上验证： MOV EAX,0xAAAAAAAA\tMOV AX,0xBBBB\tMOV AH,0xCC\tMOV AL,0xDD\t2.子寄存器存在的原因\n兼容历史 x86 架构从 **8 位 → 16 位 → 32 位 ** 逐步演进。 为了让早期程序在新 CPU 上仍能运行，Intel 保留了子寄存器的访问方式。 灵活性 有时候只需要处理 1 字节（8 位）或 2 字节（16 位）的数据，直接用子寄存器效率更高，不必操作整个32位寄存器。 32位寄存器 16位子寄存器 有无8位子寄存器 高8位 低8位 示例值（32/16/8位） 编号（二进制/十进制） EAX AX ✅ AH AL 0x12345678 / 0x5678 / 0x56/0x78 000 / 0 ECX CX ✅ CH CL 0x12345678 / 0x5678 / 0x56/0x78 001 / 1 EDX DX ✅ DH DL 0x12345678 / 0x5678 / 0x56/0x78 010 / 2 EBX BX ✅ BH BL 0x12345678 / 0x5678 / 0x56/0x78 011 / 3 ESP SP ❌ — — 0x12345678 / 0x5678 / — 100 / 4 EBP BP ❌ — — 0x12345678 / 0x5678 / — 101 / 5 ESI SI ❌ — — 0x12345678 / 0x5678 / — 110 / 6 EDI DI ❌ — — 0x12345678 / 0x5678 / — 111 / 7 认识OllyDbg 按F3打开一个EXE程序 修改寄存器中值 如何自己写汇编指令，双击程序正在执行的地址那一行的指令，可以新添加指令或者修改指令，最后按Assemble添加或修改成功。添加或修改后，这条指令会作为程序即将执行的指令，当按F8时，程序会执行你新添加的指令，添加多条，会依次向下覆盖，程序执行处在第一条你新添加的指令地址处\n注意因为寄存器是32位的，所以如果地址数值大于了32位，即会从低位取32位，多余的位将被丢弃MOV EAX,123456789 #会变成23456789\n1 2 3 4 5 MOV EAX,12345678 #MOV是汇编指令，EAX是寄存器，后面的数叫立即数，此指令的作用就是将立即数存在EAX中 ADD EAX,1 #将1与EAX中已经存储的数做加法运算，结果再存储在EAX中 MOV ECX,2 ADD EAX,ECX #将EAX与ECX中的值相加，将结果再放入EAX中 SUB EAX,3 #用EAX中的值-3，再将结果放入EAX中 汇编指令 指令作用与操作数表 指令 作用 目标操作数 源操作数 宽度要求 MOV 复制数据不改变源 寄存器/内存 寄存器/内存/立即数 必须一致（短补零，长截断） ADD 相加并存回目标 寄存器/内存 寄存器/内存/立即数 源可与目标宽度不一致（立即数可不同） SUB 相减并存回目标 寄存器/内存 寄存器/内存/立即数 源可与目标宽度不一致（立即数可不同） AND 与 → 存回目标 寄存器/内存 寄存器/内存/立即数 源可与目标宽度不一致（立即数可不同） OR 或 → 存回目标 寄存器/内存 寄存器/内存/立即数 源可与目标宽度不一致（立即数可不同） XOR 异或 → 存回目标 寄存器/内存 寄存器/内存/立即数 源可与目标宽度不一致（立即数可不同） NOT 非 → 存回操作数 寄存器/内存 — 单操作数 常用语法示例 MOV（数据传送） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 语法：MOV r32, imm32 # EAX = 0x12345678 MOV EAX, 0x12345678 # 结果 EAX = 0x12345678 # 语法：MOV r32, r32/m32 # EBX = EAX MOV EBX, EAX # 结果 EBX = 0x12345678 # 语法：MOV r32, r32/m32 # ECX = [0x00400000]（假设内存值=0x10） MOV ECX, [0x00400000] # 结果 ECX = 0x10 # 语法：MOV r32/m32, r32 # [0x00400000] = EAX MOV [0x00400000], EAX # 结果 [0x00400000] = 0x12345678 ADD（加法） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 语法：ADD r32, imm32 # EAX = EAX + 0x3（假设初始EAX=0x5） MOV EAX, 0x5 ADD EAX, 0x3 # 结果 EAX = 0x8 # 语法：ADD r32, r32/m32 # EAX = EAX + EBX（假设EAX=0x10, EBX=0x4） MOV EAX, 0x10 MOV EBX, 0x4 ADD EAX, EBX # 结果 EAX = 0x14 # 语法：ADD r32, r32/m32 # EAX = EAX + [0x00400000]（假设内存值=0x7） MOV EAX, 0 ADD EAX, [0x00400000] # 结果 EAX = 0x7 SUB（减法） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 语法：SUB r32, imm32 # EAX = EAX - 0x3（假设初始EAX=0x10） MOV EAX, 0x10 SUB EAX, 0x3 # 结果 EAX = 0xD # 语法：SUB r32, r32/m32 # EAX = EAX - EBX（假设EAX=0x20, EBX=0x5） MOV EAX, 0x20 MOV EBX, 0x5 SUB EAX, EBX # 结果 EAX = 0x1B # 语法：SUB r32, r32/m32 # EAX = EAX - [0x00400000]（假设内存值=0x4） MOV EAX, 0x10 SUB EAX, [0x00400000] # 结果 EAX = 0xC AND（按位与） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 语法：AND r32, imm32 # EAX = EAX \u0026amp; 0x0F（假设初始EAX=0xFF） MOV EAX, 0xFF AND EAX, 0x0F # 结果 EAX = 0x0F # 语法：AND r32, r32/m32 # EAX = EAX \u0026amp; EBX（假设EAX=0xF0, EBX=0x0F） MOV EAX, 0xF0 MOV EBX, 0x0F AND EAX, EBX # 结果 EAX = 0x00 # 语法：AND r32, r32/m32 # EAX = EAX \u0026amp; [0x00400000]（假设内存值=0x0F） MOV EAX, 0xFF AND EAX, [0x00400000] # 结果 EAX = 0x0F OR（按位或） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 语法：OR r32, imm32 # EAX = EAX | 0xF（假设初始EAX=0x0） MOV EAX, 0x0 OR EAX, 0xF # 结果 EAX = 0xF # 语法：OR r32, r32/m32 # EAX = EAX | EBX（假设EAX=0x10, EBX=0x01） MOV EAX, 0x10 MOV EBX, 0x01 OR EAX, EBX # 结果 EAX = 0x11 # 语法：OR r32, r32/m32 # EAX = EAX | [0x00400000]（假设内存值=0x05） MOV EAX, 0 OR EAX, [0x00400000] # 结果 EAX = 0x5 XOR（按位异或） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 语法：XOR r32, imm32 # EAX = EAX ^ 0xFF（假设初始EAX=0x55） MOV EAX, 0x55 XOR EAX, 0xFF # 结果 EAX = 0xAA # 语法：XOR r32, r32/m32 # EAX = EAX ^ EBX（假设EAX=0xAA, EBX=0x0F） MOV EAX, 0xAA MOV EBX, 0x0F XOR EAX, EBX # 结果 EAX = 0xA5 # 语法：XOR r32, r32/m32 # EAX = EAX ^ [0x00400000]（假设内存值=0x05） MOV EAX, 0 XOR EAX, [0x00400000] # 结果 EAX = 0x5 NOT（按位取反） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 语法：NOT r32/m32 # EAX = ~EAX（假设初始EAX=0x0F） MOV EAX, 0x0F NOT EAX # 结果 EAX = 0xFFFFFFF0 # 语法：NOT r8/m8 # AL = ~AL（假设初始AL=0x0F） MOV AL, 0x0F NOT AL # 结果 AL = 0xF0 # 语法：NOT r32/m32 # [0x00400000] = ~[0x00400000]（假设内存值=0x0F） NOT [0x00400000] # 结果 [0x00400000] = 0xF0 r 通用寄存器；m 代表内存；imm 代表立即数；r8 代表8位通用寄存器；m8 代表8位内存；imm8 代表8位立即数\n源、目标不能同时为内存\n寄存器 ← 寄存器 寄存器 ← 内存 寄存器 ← 立即数 内存 ← 寄存器 汇编指令总结 1️⃣ MOV（数据传送）\n作用：把一个值从寄存器、内存或立即数，传送到另一个寄存器或内存。 底层实现： 不经过加法器或逻辑运算 只是 把数据直接写入目标寄存器/内存 硬件上通常是 总线传输 + 寄存器写入，可能会有时序控制 简单来说，MOV 就是 数据搬运，不做数学计算。 2️⃣ ADD/SUB\n作用：执行数学运算 底层实现： 统一用 加法器 + 补码（SUB 通过补码转换） 每一位用逻辑门（XOR、AND、OR、NOT）处理 本质上是 数学计算 + 位运算。 3️⃣ 总结对比\n指令 本质 底层 MOV 数据搬运 总线传输 + 寄存器/内存写入 ADD 加法 加法器 + 逻辑门（XOR/AND/OR） SUB 减法 加法器 + 补码 + 逻辑门 AND/OR/XOR/NOT 按位运算 逻辑门（XOR/AND/OR/NOT） ","date":"2025-08-31T00:00:00Z","permalink":"https://example.com/p/04.%E5%AF%84%E5%AD%98%E5%99%A8/","title":"04.寄存器"},{"content":"逻辑运算的引入 如果现在只是将数据存到计算机的容器中，是没有任何意义的，我们还需要告诉计算机这些数据有什么用，让计算机对这些数做运算。所以我们知道计算机到底是如何做运算的，所以我们引入逻辑运算\n逻辑运算 由于计算机受硬件的限制影响，CPU再复杂可以理解为一条条的线路组成的，而电信号只有两种形式0和1，所以一般计算机的逻辑运算的对象都是二进制数\n逻辑运算分为：\n逻辑运算 汇编符号 C语言符号 口诀 与 AND \u0026amp; 有0则0，全1才1 或 OR ` ` 异或 XOR ^ 相同为0，相异为1 非 NOT ! 或 ~ 0变1，1变0 CPU是如何计算2+3 初始数据（二进制表示） x = 2，二进制表示：0010 y = 3，二进制表示：0011\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 0010\txor 0011 ------------ 0001 R:0001 0010 and 0011 ------------ 0010 \u0026lt;\u0026lt;1 得 0100 #\u0026lt;\u0026lt;1表示左移一位 此时计算机会判断0100是否全为0,如果全为0表示运算结束,将R中此时的值作为结果输出,如果不为0则将R中的值赋给x。0100赋给y再做一次同样运算 0001 xor 0100 ------------- 0101 R:0101 0001 and 0100 ------------- 0000 \u0026lt;\u0026lt;1 得 0000 判断0000全为0,则运算结束,将R中的值0101作为运算的结果,化成十进制即为5 总结\n这个过程模拟了 加法运算，通过 XOR 来计算和，使用 AND 来计算进位，然后通过 左移 来处理进位，最终得到结果 5。\n计算3-2 x = 3 → 二进制：0000 0011 y = 2 → 二进制：0000 0010\n-2 的补码：\n原码：0000 0010 反码：1111 1101 补码：1111 1110 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 补码0000 0010-\u0026gt;1111 1101-\u0026gt;1111 1110 ##############第一次运算 0000 0011 1111 1110 xor ---------- 1111 1101 R:1111 1101 0000 0011 1111 1110 and ---------- 0000 0100 \u0026lt;\u0026lt;进位1 得0000 0100 更新变量： x = 1111 1101 y = 0000 0100 ##############第二次运算 1111 1101 0000 0100 xor ---------- 1111 1001 R:1111 1001 1111 1101 0000 0100 and ---------- 0000 0100 \u0026lt;\u0026lt;进位1 得0000 1000 更新变量： x = 1111 1001 y = 0000 1000 ###############第三次运算 1111 1001 0000 1000 xor ------------- 1111 0001 R:1111 0001 1111 1001 0000 1000 and -------------- 0000 1000 进位0001 0000 更新变量： x = 1111 0001 y = 0001 0000 ############第四次运算 1111 0001 0001 0000 xor ------------- 1110 0001 R:1110 0001 1111 0001 0001 0000 and ------------- 0001 0000 进位0010 0000 更新变量： x = 1110 0001 y = 0010 0000 ############第五次运算 1110 0001 0010 0000 xor ------------- 1100 0001 R:1100 0001 1110 0001 0010 0000 and ------------- 0010 0001 进位0100 0001 更新变量： x = 1100 0001 y = 0100 0001 ############第六次运算 1100 0001 0100 0001 xor ------------- 1000 0001 R:1000 0001 1100 0001 0100 0001 and ------------- 0100 0001 进位1000 0001 更新变量： x = 1000 0001 y = 1000 0001 #########第七次运算 1000 0001 1000 0001 xor ------------- 0000 0000 R:1000 0001 1000 0001 1000 0001 and ------------- 0000 0000 进位00000 0000 计算2-3 x=2 y=3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 0000 0010 1111 1101 xor ------------- 1111 1111 0000 0010 1111 1101 and ------------- 0000 0000 1111 1111 取反 → 加1 → 得正数 → 加负号 0000 0000 0000 0001 -1 如何获取某个值的第N位是0还是1 比如现在某个寄存器中存了一个值，值化成二进制时，有些特殊的值每一位都有它的特殊含义，所以我们想要知道这个值的第N位是0还是1。如果我们把寄存器中的值取出来，一个一个数着看，就会很麻烦，但是如果做下面的运算，就会容易很多\n#现在想要查看某寄存器中的值的第4位是0还是1,我们就可以将寄存器中的值与0x08做与运算，如果得到结果中有一个1,则这个值的第四位就是1，如果结果全是0，则值的第四位就是0\n1 2 3 10001111 and\t00001000 ​\t00001000 用异或做加密解密 如果进行简单的加密，可以使用亦或运算，因为选择一个双方都知道密钥，用此密钥与数据做亦或加密加密过后，别人如果没有密钥则不好解开这个密文，而对于接受方，使用相同的密钥再做一次亦或即可得到原来的明文值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 要加密的数据:2015\t00100000\t00010101 ^\t01010100\t^\t01010100 ------------ ------------ 密钥:54\t01110100\t01000001 加密后的结果：\t74\t41 01110100\t01000001 ^\t01010100\t^ 01010100 ------------- ------------ 00100000\t00010101 解密后的结果：\t20\t15 ","date":"2025-08-30T00:00:00Z","permalink":"https://example.com/p/03.%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/","title":"03.逻辑运算"},{"content":"什么是数据宽度 计算机中存储的数据最终都是二进制存储的，计算机只认识1和0，但是不是一下子全部存进去的，而是分成很多的容器，每个容器都有最大容量，比如有的可以装4个二进制数，有的可以装8个二进制数。所以在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度）\n如果要存储的数超过了容器的数据宽度计算机怎么处理呢？直接将高位多出来的位丢弃！\n比如一个容器的数据宽度为4位，那么如果我现在存一个数16，化为二进制为10000，由于只能存4位，那么进位的多出来的位会被丢弃，最终读到的是0000，即0\n存储过程\n容器只有 4 位，意味着它本质就是一个 4 位寄存器/存储单元。 当你把 16（二进制 10000）写进去时，计算机会 只保留低 4 位： 10000 （5 位原始数据） ↓ 截断高位 0000 （只剩 4 位） 结果：读出来是 0 再看几个例子\n存 8（二进制 1000） → 1000（还能放得下） → 结果 = 8 存 15（二进制 1111） → 1111 → 结果 = 15 存 16（二进制 10000） → 截断 → 0000 → 结果 = 0 存 17（二进制 10001） → 截断 → 0001 → 结果 = 1 存 18（二进制 10010） → 截断 → 0010 → 结果 = 2 无符号数、有符号数 以前我们只是记住：如果一个存储单元只有 4 位，\n无符号数：4 位全部用来表示数值，可表示 0000 到 1111，总共有 16 种可能。 有符号数：最高位作为符号位，0000 到 0111（最高位 0）表示正数，1000 到 1111（最高位 1）表示负数。 但实际上，计算机并不“认识”正负号。原码、反码、补码只是人类为了表示有符号数和方便运算而制定的规则，硬件只处理 0 和 1，并不会理解这些数的正负意义。\n4位宽度(理论示例) 注意：1 位是理论上的最小存储单位，但在现代 CPU 和汇编实践中，最小的可操作单位通常是 8 位（1 字节），所以计算机中没有4位容器，我们只是为了引入方便理解。\n假设计算机只能存 4 位二进制数\n一共可以表示2^4=16 种数 对应十六进制： 1 2 二进制：0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 16进制： 0 1 2 3 4 5 6 7 8 9 A=10 B=11 C=12 D=13 E=14 F=15 1️⃣ 无符号数（Unsigned）\n定义：全部4位都用来表示数值，不区分正负 范围：0~15 规则：超过15再加1会绕到0（如16→0，17→1） 理解：计算机只认识0和1，它不“知道”正负。正负只是我们人为定义的解释方式。 2️⃣ 有符号数（Signed，补码表示）\n问题：4 位二进制数，同时要表示正数和负数\n解决：用 最高位 作为符号位（0正，1负），剩下3位表示数值\n范围：\n正数：000-0111 → 0到7 负数：1000-1111 → -8到-1 为什么 F 是 -1？\n4位补码规则：负数存储为 补码\n负数的补码 = 正数原码取反 + 1 以 1111 为例：\n最高位是1 → 是负数\n取反 + 1： 补码：1111 取反：0000 +1 ：0001\n得到原码 = 0001 → 十进制 1\n加上符号 → -1\n类似地：\n1110 → 取反 0001 → +1 → 0010 → -2 1101 → 取反 0010 → +1 → 0011 → -3 1000 → 取反 0111 → +1 → 1000（其实是4位的原码表示-8）\n补码的主要作用 是为了让负数可以在计算机中表示，并且加减运算可以统一。\n所以说它是 存储负数的一种方法，但更准确是 存储整数（正负数）的一种编码方式\n8位宽度 假设现在4位不够表示我要存的数了，我换一个大一点的容器，存储数据的范围为0x00到0xFF，即数据宽度为8位，那么此时容器如何表示\n1. 无符号数表示\n对于 8位无符号数，范围从 0x00 到 0xFF，也就是从 0 到 255，共有 256 个可能的数值。这是因为每个位置上可以是 0 或 1，所以有 2^8 = 256 种不同的组合。\n最小值：0x00，即 0。 最大值：0xFF，即 255。 2. 有符号数表示\n对于 8位有符号数，我们需要使用 补码表示法。为了表示正负数，通常约定 最高位（即 符号位）为 0 时表示正数，符号位为 1 时表示负数。根据补码的规则，范围被分为两半：\n正数范围：0x00 到 0x7F，即从 0 到 127，这部分数据用补码表示时，符号位为 0，其余 7 位表示正数。\n0x00 = 00000000，表示正数 0。\n0x7F = 01111111，表示正数 127（符号位为 0）。\n负数范围：0x80 到 0xFF，即从 -128 到 -1，符号位为 1，剩余部分表示负数。负数的补码是通过对正数取反加 1 来得到的。\n0x80 = 10000000，表示负数 -128（符号位为 1）。\n0xFF = 11111111，表示负数 -1。即11111111 → 取反 00000000 → +1 → 00000000 → -1\n16位宽度 16位数据宽度容器存储无符号数范围是从0到FFFF 存储有符号数从0到7FFF表示正数，从8000到FFFF表示负数 32位宽度 目前计算机中最常见的也是这个数据宽度的容器\n32位数据宽度容器存储无符号数范围是从0到FFFFFFFF 存储有符号数从0到7FFFFFFF表示正数，从80000000到FFFFFFFF表示负数 补码 为什么需要补码 现代计算机的 CPU 通常没有独立的“减法器”电路，它通过“补码 + 加法器”来实现减法。 换句话说：计算机“假装”能做减法，其实是用加法“模拟”出来的。\n补码的核心目的： 让减法变成加法，从而只用一个加法器就能处理所有整数运算。\n补码的基本概念 补码是一种二进制编码方式，用于在计算机中表示有符号整数（正数、负数、零）,这使得计算机能通过加法器来同时执行加法和减法运算。\n补码是存储整数的编码方式 正数的补码：和原码是一样的，保持不变。 负数的补码：是通过对其原码取反然后加1。 为什么补码统一了加法和减法？ 补码的最大优势之一就是它让计算机的硬件（加法器）可以 统一处理加法和减法。具体来说： 加法：对于正数，补码的加法就像普通的加法一样；对于负数，计算机会使用补码来进行加法，从而正确地计算出负数的加法结果。 减法：减法可以通过加法来转换。比如 A - B 可以转换为 A + (-B)，也就是说，计算机通过补码将减法问题转化为加法问题。 补码规则与原码转换 核心规则：\n正数：原码 = 补码（无需转换） 负数：需要转换 0：原码和补码都是 00000000（补码只有一个 0） 负数：原码 → 补码 示例：-5 的原码 → 补码\n步骤 二进制 说明 原码 10000101 符号位 1，数值 5=0000101 取反 11111010 符号位不变，数值位取反 加 1 11111011 11111010 + 1 = 11111011 所以 -5 的补码是：11111011\n负数：补码 → 原码 负数的补码再求一次补码，就变回原码！\n示例：补码 11111011 → 原码\n取反：10000100 加 1：10000101 = 5 加负号：-5 原码：10000101 总结：转换口诀 转换方向 口诀 原码 → 补码 “取反加一” 补码 → 原码 “再求一次补码” 正数/0 原码 = 补码，无需转换 补码加减法案例（8位） 加法 5 + 3 = 8\n1 2 3 00000101 (5) 00000011 (3) 00001000 = 8 5 + (-3) = 2\n1 2 3 4 - `-3` 补码：`11111101` 00000101 (5) 11111101 (-3) 00000010 = 2 (-3) + (-2) = -5\n1 2 3 4 - `-2` 补码：`11111110` 11111101 (-3) 11111110 (-2) 11111011 → 取反加1 → 5 → -5 减法（转加法） 7 - 3 = 4\n1 2 3 00000111 (7) 11111101 (-3) 00000100 = 4 5 - (-3) = 8\n1 2 3 00000101 (5) 00000011 (3) 00001000 = 8 (-3) - 2 = -5\n1 2 3 4 11111101 (-3) 11111110 (-2) ------------ 11111011 → -5 特殊 127 + 1 = -128（溢出）\n1 2 3 4 01111111 (127) 00000001 (1) -------------- 10000000 → -128 3 + (-3) = 0\n1 2 3 00000011 11111101 00000000 = 0 所有运算 = 补码 + 加法器\n补码计算结果解读流程图 1 2 3 4 5 6 7 8 9 10 11 12 13 开始 ↓ 看结果的最高位 ↓ ┌───────────────┐ ↓ ↓ 是 0？ 是 1？ ↓ ↓ 正数或 0 负数 ↓ ↓ 直接转十进制 取反 → 加1 → 得正数 → 加负号 ↓ ↓ 完成 完成 数据单位 存储单位\n名称 大小 位-BIT █（1位） 字节-Byte █|█|█|█|█|█|█|█（8位） 字-Word █|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█（16位） 双字-Doubleword █|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█（32位） 存储范围\n名称 大小 二进制位数 十六进制范围 十进制范围 位（Bit） 1 位 1 0 – 1 0 – 1 字节（Byte） 8 位 = 1 字节 8 0x00 – 0xFF 0 – 255 字（Word） 16 位 = 2 字节 16 0x0000 – 0xFFFF 0 – 65,535 双字（Double Word, DWORD） 32 位 = 4 字节 32 0x00000000 – 0xFFFFFFFF 0 – 4,294,967,295 当我们存储数据的时候，需要知道自己存储的数据的数据宽度是什么，假设你要存储一个1，要存入字节中，那么以二进制的表示即为：0000 0001，转为十六进制即为0x01 **字节（Byte）**的存储范围使用十六进制表示则为：0 - 0xFF **字（Word）**的存储范围：0 - 0xFFFF **双字（Doubleword）**的存储范围：0 - 0xFFFFFFFF\n","date":"2025-08-24T00:00:00Z","permalink":"https://example.com/p/02.%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/","title":"02.数据宽度"},{"content":"计算机与数字的关系 信息的二进制表示 计算机处理的任何信息，包括图片、视频、音乐、文字、程序，最终都是以 二进制 0 和 1 的形式存储和处理的。 二进制是计算机唯一“能理解”的语言。 为什么计算机使用二进制\n二进制足够表达所有信息 每一位只有 0 和 1，组合起来可以表示任意数据。 受硬件制约 电子电路中开关只有两种状态：通/断、亮/灭，对应 1/0 二进制与硬件自然匹配，可靠且稳定 进制的本质 如果将进制定义成这样，你有何想法?\n1 2 3 4 5 6 7 十进制的定义 由十个符号组成 如果改成这样呢? 9152476380 逢十进一，10是多少呢？用19表示 -或写成这样呢？ @ # ! $ ^ \u0026amp; * ( = 逢十进一，十用#@表示 了解事物的本质，如果将上面的符号用于加密，那会给解密者代理极大的麻烦 所以2+3=1成立吗？\n1 2 3 成立的，元素是可以自己定义的 自定义符号： 0 2 3 1 8 7 6 9 5 4 标准数值： 0 1 2 3 4 5 6 7 8 9 世界上有多少种进制？\n1 2 3 4 5 6 世界可以有任何进制，但一进制除外 进制要求：满 N 进 1 老师让学生数 5 只羊, 学生画：| | | | | 或者刻“正”字 不进位，只是重复堆符号 常用的进制 在计算机中，常用的数值进制包括二进制、八进制、十进制和十六进制。\n二进制\n只有两个数字：0 和 1 每一位称为 bit（位） 适合计算机底层使用（电平高低） 示例：0b1010 表示十进制的 10 八进制\n符号：通常写作 0o，例如 0o17\n位数：每位数字 0~7\n用途：\n曾经用于计算机汇编编程\n方便把二进制每三位分组表示\n八进制的每一位正好对应二进制的三位\n十进制\n符号：普通数字 0~9 用途：人类日常使用，编程中输入/输出数据时通常用十进制表示 示例：1234 是标准的十进制表示 十六进制\n符号：通常以 0x 开头 位数：0 1 2 3 4 5 6 7 8 9 a b c d e f 用途：常用来表示内存地址、颜色、机器码等 一个十六进制位用4个二进制位表示 示例：0x1A3F == 二进制 0001 1010 0011 1111 == 十进制 6719 进制运算 计算的核心，就是查数（掰手指）\n十进制表 加法表\n1 2 3 4 5 6 7 8 9 1+1=2 1+2=3 2+2=4 1+3=4 2+3=5 3+3=6 1+4=5 2+4=6 3+4=7 4+4=8 1+5=6 2+5=7 3+5=8 4+5=9 5+5=10 1+6=7 2+6=8 3+6=9 4+6=10 5+6=11 6+6=12 1+7=8 2+7=9 3+7=10 4+7=11 5+7=12 6+7=13 7+7=14 1+8=9 2+8=10 3+8=11 4+8=12 5+8=13 6+8=14 7+8=15 8+8=16 1+9=10 2+9=11 3+9=12 4+9=13 5+9=14 6+9=15 7+9=16 8+9=17 9+9=18 乘法表\n1 2 3 4 5 6 7 8 9 1×1=1 1×2=2 2×2=4 1×3=3 2×3=6 3×3=9 1×4=4 2×4=8 3×4=12 4×4=16 1×5=5 2×5=10 3×5=15 4×5=20 5×5=25 1×6=6 2×6=12 3×6=18 4×6=24 5×6=30 6×6=36 1×7=7 2×7=14 3×7=21 4×7=28 5×7=35 6×7=42 7×7=49 1×8=8 2×8=16 3×8=24 4×8=32 5×8=40 6×8=48 7×8=56 8×8=64 1×9=9 2×9=18 3×9=27 4×9=36 5×9=45 6×9=54 7×9=63 8×9=72 9×9=81 八进制 数数表\n1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 40 41 42 43 44 45 46 47 50 51 52 53 54 55 56 57 60 61 62 63 64 65 66 67 70 71 72 73 74 75 76 77 100 八进制加法表\n1 2 3 4 5 6 7 1+1=2 1+2=3 2+2=4 1+3=4 2+3=5 3+3=6 1+4=5 2+4=6 3+4=7 4+4=10 1+5=6 2+5=7 3+5=10 4+5=11 5+5=12 1+6=7 2+6=10 3+6=11 4+6=12 5+6=13 6+6=14 1+7=10 2+7=11 3+7=12 4+7=13 5+7=14 6+7=15 7+7=16 八进制乘法表\n1 2 3 4 5 6 7 1×1=1 1×2=2 2×2=4 1×3=3 2×3=6 3×3=11 1×4=4 2×4=10 3×4=14 4×4=20 1×5=5 2×5=12 3×5=17 4×5=24 5×5=31 1×6=6 2×6=14 3×6=22 4×6=30 5×6=36 6×6=44 1×7=7 2×7=16 3×7=25 4×7=34 5×7=43 6×7=52 7×7=61 十六进制 数数表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 0 1 2 3 4 5 6 7 8 9 A B C D E F 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF 十六六乘法表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1×1=1 1×2=2 2×2=4 1×3=3 2×3=6 3×3=9 1×4=4 2×4=8 3×4=C 4×4=10 1×5=5 2×5=A 3×5=F 4×5=14 5×5=19 1×6=6 2×6=C 3×6=12 4×6=18 5×6=1E 6×6=24 1×7=7 2×7=E 3×7=15 4×7=1C 5×7=23 6×7=2A 7×7=31 1×8=8 2×8=10 3×8=18 4×8=20 5×8=28 6×8=30 7×8=38 8×8=40 1×9=9 2×9=12 3×9=1B 4×9=24 5×9=2D 6×9=36 7×9=3F 8×9=48 9×9=51 1×A=A 2×A=14 3×A=1E 4×A=28 5×A=32 6×A=3C 7×A=46 8×A=50 9×A=5A A×A=64 1×B=B 2×B=16 3×B=21 4×B=2C 5×B=37 6×B=42 7×B=4D 8×B=58 9×B=63 A×B=6E B×B=79 1×C=C 2×C=18 3×C=24 4×C=30 5×C=3C 6×C=48 7×C=54 8×C=60 9×C=6C A×C=78 B×C=84 C×C=90 1×D=D 2×D=1A 3×D=27 4×D=34 5×D=41 6×D=4E 7×D=5B 8×D=68 9×D=75 A×D=82 B×D=8F C×D=9C D×D=A9 1×E=E 2×E=1C 3×E=2A 4×E=38 5×E=46 6×E=54 7×E=62 8×E=70 9×E=7E A×E=8C B×E=9A C×E=A8 D×E=B6 E×E=C4 1×F=F 2×F=1E 3×F=2D 4×F=3C 5×F=4B 6×F=5A 7×F=69 8×F=78 9×F=87 A×F=96 B×F=A5 C×F=B4 D×F=C3 E×F=D2 F×F=E1 加法表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1+1=2 1+2=3 2+2=4 1+3=4 2+3=5 3+3=6 1+4=5 2+4=6 3+4=7 4+4=8 1+5=6 2+5=7 3+5=8 4+5=9 5+5=A 1+6=7 2+6=8 3+6=9 4+6=A 5+6=B 6+6=C 1+7=8 2+7=9 3+7=A 4+7=B 5+7=C 6+7=D 7+7=E 1+8=9 2+8=A 3+8=B 4+8=C 5+8=D 6+8=E 7+8=F 8+8=10 1+9=A 2+9=B 3+9=C 4+9=D 5+9=E 6+9=F 7+9=10 8+9=11 9+9=12 1+A=B 2+A=C 3+A=D 4+A=E 5+A=F 6+A=10 7+A=11 8+A=12 9+A=13 A+A=14 1+B=C 2+B=D 3+B=E 4+B=F 5+B=10 6+B=11 7+B=12 8+B=13 9+B=14 A+B=15 B+B=16 1+C=D 2+C=E 3+C=F 4+C=10 5+C=11 6+C=12 7+C=13 8+C=14 9+C=15 A+C=16 B+C=17 C+C=18 1+D=E 2+D=F 3+D=10 4+D=11 5+D=12 6+D=13 7+D=14 8+D=15 9+D=16 A+D=17 B+D=18 C+D=19 D+D=1A 1+E=F 2+E=10 3+E=11 4+E=12 5+E=13 6+E=14 7+E=15 8+E=16 9+E=17 A+E=18 B+E=19 C+E=1A D+E=1B E+E=1C 1+F=10 2+F=11 3+F=12 4+F=13 5+F=14 6+F=15 7+F=16 8+F=17 9+F=18 A+F=19 B+F=1A C+F=1B D+F=1C E+F=1D F+F=1E 进制进位技巧 标准三进制 1 2 3 0 1 2 10 11 12 20 21 22 #三进制只有012三个数。到22这里，已经没符号可表示了需要进位 22后续如何进位，我们来拆解：\n1 2 3 2 2 + 1 ------ 第一步：个位 2 + 1• 2 + 1 = 3 → 但三进制中没有 3•所以：3 ÷ 3 = 1 余 0 → 写 0，向前进位 1\n1 2 3 4 5 1← 2 2 + 1 ------ 0 第二步：十位 2 + 进位1 2 + 1 = 3 → 又满 3 了！•所以：3 ÷ 3 = 1 余 0 → 写 0，再向前进位 1\n1 2 3 4 5 1← 2 2 + 1 ------ 0 0 第三步：百位没有数字了，但还有进位 1•所以：在百位写 1\n1 2 3 4 2 2 + 1 ------ 1 0 0 继续写\n1 2 3 100 101 102 110 111 112 120 121 122 #122 如何进位? 同上方法 三进制举例更数值更明显。其他进制也是如此计算\n自定义三进制 自定义：9 4 6 标准值：0 1 2\n1 2 3 4 5 6 7 8 9 10 9 4 6 49 44 46 69 64 66 #如何进位？ 499 494 496 6 6 + 1 ------ 1 0 0 #100换成三进制499 二进制转换进制方法 二进制权重作用 权重的本质\n二进制每一位的权重 = 2 的位次\n权重只跟二进制本身有关，和你最终要转换成什么进制无关\n位数 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 权重 32768 16384 8192 4096 2048 1024 512 256 128 64 32 16 8 4 2 1 二进制转换 1️⃣ 分组法（快速法） 优点快速、直观、运算量小\n适用条件：\n适用于目标进制是 2 的幂（4、8、16、32、64 …） 每组二进制最大值刚好能表示目标进制的一位 如果目标进制不是 2 的整数次方（比如 3、5、6、7、9、10），就不能分组，只能先转十进制，再转目标进制。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 二进制：`10101111` - 每 4 位一组：`1010 1111` - 左边 1010 = 10 → A - 右边 1111 = 15 → F - 十六进制 = `AF` 二进制： 1 0 1 0 1 1 1 1 位次： 7 6 5 4 3 2 1 0 权重： 128 64 32 16 8 4 2 1 分组后： [1010] [1111] 分组权重： 8 4 2 1 8 4 2 1 十进制： 10 15 十六进制： A F 组合 → AF 目标进制 2 的幂 分组二进制位数 4 2² 2次方,2位二进制一组 2 8 2³ 3次方,3位二进制一组 3 16 2⁴ 4次方,4位二进制一组 4 32 2⁵ 5次方,5位二进制一组 5 64 2⁶ 6次方,6位二进制一组 6 2️⃣ 十进制中转法（通用法） 适用条件：目标进制 不是 2 的幂（3、5、6、7、9、10、12 …） 方法：二进制 → 十进制 → 任意进制 优点：通用，适用于所有进制 缺点：步骤多、计算量大 二进制 → 十进制（权重求和法） 示例：二进制 101101\n位次 5 4 3 2 1 0 二进制 1 0 1 1 0 1 权重 32 16 8 4 2 1 乘积 32 0 8 4 0 1 十进制 = 32 + 0 + 8 + 4 + 0 + 1 = 45\n十进制 → 目标进制（除基取余法） 公式：十进制数÷目标进制=商\u0026hellip;余数十进制数 ÷ 目标进制 = 商 \u0026hellip; 余数十进制数÷目标进制=商\u0026hellip;余数 余数 = 目标进制的最低位 商继续除基，直到商 = 0 余数 倒序排列 = 最终目标进制表示 示例：45 → 七进制\n45 ÷ 7 = 6 余 3 → 低位 = 3 6 ÷ 7 = 0 余 6 → 高位 = 6 七进制 = 63_7 ✅ 总结口诀： 目标进制 二进制权重作用 二转十进制 权重求和法 → 直接算 二转二的幂进制 分组法 → 每组权重内部依旧用 2 的幂求和 二转奇数进制 / 其他 十进制中转法 → 权重先算十进制，再除基取余 2进制转16进制表(必背) 每1个16进制位对应4个二进制位。\n三个关键点记忆\n2 -\u0026gt;10 #进位 3-\u0026gt;11 4-\u0026gt;100 4 -\u0026gt;100 #进位 5-101 6-\u0026gt;110 7-\u0026gt;111 8 -\u0026gt;1000 8 4 2 记前9个 后面记住关键点 A=1010 D=1100 然后都+1\n这个对应关系表需要熟练掌握，做到看见二进制可以直接转为十六进制，反之亦然。\n二进制 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 十六进制 0 1 2 3 4 5 6 7 8 9 A B C D E F ","date":"2025-08-23T00:00:00Z","permalink":"https://example.com/p/01.%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/","title":"01.进制基础"},{"content":"global语句 1 2 3 4 5 6 7 8 name = {\u0026#34;name\u0026#34;: \u0026#34;zhangsan\u0026#34;} #修改全局 def func(): global name name = {\u0026#34;name\u0026#34;: \u0026#34;lisi\u0026#34;} # 相当于重新赋值，需要 global def foo(): name[\u0026#34;name\u0026#34;] = \u0026#34;lisi\u0026#34; # 当只改内容，不换对象时， 不需要 global也可以修改全局 如果只是改字典/列表的“内容”（如 d[\u0026ldquo;key\u0026rdquo;] = value） → 不需要 global，函数可以直接修改全局的字典 如果要重新赋值整个变量（如 name = {}） → 必须加 global name，否则 Python 会创建局部变量\n装饰器 装饰器介绍 本质 装饰器本质就是一个函数，返回一个新的函数。 它的核心目的是：不改原函数代码，就能增加新功能 代码对比 比喻：毛坯房vs精装房（装饰器==房子装修队）\n装饰器前（原函数）\n1 2 def house(): print(\u0026#34;一个空的毛坯房，只有墙和门\u0026#34;) 手动改造（麻烦）\n1 2 3 4 5 def house(): print(\u0026#34;一个空的毛坯房，只有墙和门\u0026#34;) print(\u0026#34;装修队进场：铺地板、刷墙\u0026#34;) print(\u0026#34;家具进场：沙发、电视、冰箱\u0026#34;) #既破坏了原始函数，又不优雅。 装饰器写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def decorator_team(func): def decorated_house(): func() print(\u0026#34;装修队进场：铺地板、刷墙\u0026#34;) print(\u0026#34;家具进场：沙发、电视、冰箱\u0026#34;) return decorated_house # 返回精装房 #语法糖形式写法 @decorator_team def house(): print(\u0026#34;一个空的毛坯房，只有墙和门\u0026#34;) house() #下面等价于语法糖写法： def house(): print(\u0026#34;一个空的毛坯房，只有墙和门\u0026#34;) house = decorator_team(house) #开始装修！ #装修队decorator_team给毛坯房house装修！ #被装修的：house(原函数), #执行装修的：decorator_team(装饰器) #装修结果：decorated_house(新函数) house() # 谁在执行？ #你拿到是house已经是精装房了！因为 house现在指向的是decorated_house 带参数的装饰器 装修风格可以不同，比如豪华版、简约版。 这时装饰器需要 接受参数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def decorator_team(style): #外层函数（接受参数）（豪华 / 简约 …） def wrapper(func): #中层（接受被装饰的函数） def decorated_house(): #内层（包装函数，执行逻辑） func() print(f\u0026#34;装修队进场：{style} 风格装修\u0026#34;) print(\u0026#34;家具进场：沙发、电视、冰箱\u0026#34;) return decorated_house return wrapper @decorator_team(\u0026#34;豪华\u0026#34;) def house(): print(\u0026#34;一个空的毛坯房，只有墙和门\u0026#34;) house() 多层装饰器 你可以叠加多个装修队：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def add_floor(func): def wrapper(): print(\u0026#34;加一层楼！\u0026#34;) func() return wrapper def add_garden(func): def wrapper(): func() print(\u0026#34;再加个花园！\u0026#34;) return wrapper @add_garden @add_floor def house(): print(\u0026#34;一个空的毛坯房，只有墙和门\u0026#34;) house() 输出\n加一层楼！ 一个空的毛坯房，只有墙和门 再加个花园！\n注册类装饰器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import PySimpleGUI as sg \u0026#34;\u0026#34;\u0026#34; 服务注册中心，类似微服务console/Nacos概念 \u0026#34;\u0026#34;\u0026#34; tasks = {} # 登记本：家务任务 -\u0026gt; 执行函数 def assign(task_name): \u0026#34;\u0026#34;\u0026#34;注册装饰器：登记谁负责做哪件家务\u0026#34;\u0026#34;\u0026#34; def decorator(func): tasks[task_name] = func print(f\u0026#34;[登记] 家务 \u0026#39;{task_name}\u0026#39; -\u0026gt; {func.__name__} 负责\u0026#34;) return func return decorator \u0026#34;\u0026#34;\u0026#34; 服务提供者 \u0026#34;\u0026#34;\u0026#34; # ----------------------------- # 定义家务（函数定义时自动登记） # ----------------------------- @assign(\u0026#34;洗碗\u0026#34;) def zhangsan(): sg.popup(\u0026#34;Zhangsan 在洗碗~\u0026#34;) @assign(\u0026#34;扫地\u0026#34;) def lisi(): sg.popup(\u0026#34;Lisi 在扫地~\u0026#34;) @assign(\u0026#34;倒垃圾\u0026#34;) def wangwu(): sg.popup(\u0026#34;Wangwu 在倒垃圾~\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 服务消费者 \u0026#34;\u0026#34;\u0026#34; # ----------------------------- # GUI 部分 # ----------------------------- layout = [ [sg.Text(\u0026#34;请选择要执行的家务:\u0026#34;)], [sg.Button(task) for task in tasks.keys()], [sg.Button(\u0026#34;退出\u0026#34;)] ] window = sg.Window(\u0026#34;家务执行器\u0026#34;, layout) while True: event, values = window.read() if event in (sg.WINDOW_CLOSED, \u0026#34;退出\u0026#34;): break if event in tasks: # 服务发现 tasks[event]() # 服务消费 window.close() ","date":"2025-08-21T00:00:00Z","permalink":"https://example.com/p/python%E5%87%BD%E6%95%B0/","title":"Python函数"},{"content":"一、文件的读取和导入 数据读取 1 2 3 4 5 6 7 8 import pandas as pd print(pd.__version__) #查看版本 # 读取 csv df_csv = pd.read_csv(r\u0026#34;data/my_csv.csv\u0026#34;) # 推荐使用相对路径 # 读取 txt df_txt = pd.read_table(r\u0026#34;data/my_table.txt\u0026#34;) # 读取 excel df_excel = pd.read_excel(r\u0026#34;data/my_excel.xlsx\u0026#34;) 常用参数：\nheader=None 第一行不作为列名 index_col 指定某列作为索引 usecols 指定读取的列 parse_dates 指定需要转为时间的列 nrows 指定读取的行数 指定分隔符 sep\nsep=\u0026rsquo;,\u0026rsquo; → 逗号分隔 sep=\u0026rsquo;\\t\u0026rsquo; → 制表符分隔（read_table 默认就是 \\t） sep=\u0026rsquo;\\s+\u0026rsquo; → 多个空格分隔 sep=\u0026rsquo;;\u0026rsquo; → 分号分隔 read_csv() 默认 sep=','，读取 csv 文件无需显式写 sep=','。 read_table() 默认 sep='\\t'，所以读取制表符 txt 文件可以直接用，不用改 sep。 read_excel 不需要 sep，因为 Excel 文件本身有单元格结构，不是纯文本分隔的。\n数据写入 常用：index=False 避免保存索引\n1 2 3 df_csv.to_csv(r\u0026#34;data/my_csv_saved.csv\u0026#34;, index=False) df_excel.to_excel(r\u0026#34;data/my_excel_saved.xlsx\u0026#34;, index=False) df_txt.to_csv(r\u0026#34;data/my_table_saved.txt\u0026#34;, sep=\u0026#39;\\t\u0026#39;, index=False) 如果想要把表格转换为 markdown 和 latex 语言，可以使用 to_markdown 和 to_latex 函数，此处需要安装 tabulate 包。\n1 2 df_csv.to_markdown() df_csv.to_latex() 二、基本数据结构 1. Series 1 2 3 4 s = pd.Series([100, \u0026#39;a\u0026#39;, {\u0026#39;dic1\u0026#39;: 5}, 1], index=pd.Index([\u0026#39;id1\u0026#39;, 20, \u0026#39;third\u0026#39;, \u0026#39;id2\u0026#39;], name=\u0026#39;my_idx\u0026#39;), dtype=\u0026#39;object\u0026#39;, name=\u0026#39;my_name\u0026#39;) 常用属性\ns.values 返回 Series 的 数据值（NumPy 数组形式） 例子输出：array([100, 'a', {'dic1':5}, 1], dtype=object) s.index 返回 Series 的 索引（Index 对象） 例子输出：Index(['id1', 20, 'third', 'id2'], dtype='object', name='my_idx') 可以用来访问或操作索引 s.dtype 返回 Series 数据类型 例子输出：object 因为这里混合了数字、字符串和字典，所以 dtype 是 object s.name 返回 Series 的 名称 例子输出：'my_name' 方便在 DataFrame 中作为列名使用 s.shape 返回 Series 的 形状 例子输出：(4,) → 一维，有 4 个元素 s[\u0026lsquo;id1\u0026rsquo;] 根据索引取单个值 输出：100 2. DataFrame 1 2 3 4 5 6 7 8 data = [[1, \u0026#39;a\u0026#39;, 1.2], [2, \u0026#39;b\u0026#39;, 2.2], [3, \u0026#39;c\u0026#39;, 3.2]] df = pd.DataFrame(data, index=[\u0026#39;row_0\u0026#39;,\u0026#39;row_1\u0026#39;,\u0026#39;row_2\u0026#39;], columns=[\u0026#39;col_0\u0026#39;,\u0026#39;col_1\u0026#39;,\u0026#39;col_2\u0026#39;]) 或使用字典构造： df = pd.DataFrame({\u0026#39;col_0\u0026#39;:[1,2,3], \u0026#39;col_1\u0026#39;:list(\u0026#39;abc\u0026#39;), \u0026#39;col_2\u0026#39;:[1.2,2.2,3.2]}, index=[\u0026#39;row_0\u0026#39;,\u0026#39;row_1\u0026#39;,\u0026#39;row_2\u0026#39;]) 常用属性 df[[\u0026lsquo;col_0\u0026rsquo;,\u0026lsquo;col_1\u0026rsquo;]] 获取多列，返回新的 DataFrame\n1 2 3 4 5 6 print(df[[\u0026#39;col_0\u0026#39;,\u0026#39;col_1\u0026#39;]]) # 输出示例： # col_0 col_1 # row_0 1 a # row_1 2 b # row_2 3 c df.values 返回 DataFrame 的数据值（NumPy 数组形式，不包含列名和索引）\n1 2 3 4 5 print(df.values) # 输出示例： # [[1 \u0026#39;a\u0026#39; 1.2] # [2 \u0026#39;b\u0026#39; 2.2] # [3 \u0026#39;c\u0026#39; 3.2]] df.index 返回 DataFrame 的行索引（Index 对象）\n1 2 3 print(df.index) # 输出示例： # Index([\u0026#39;row_0\u0026#39;,\u0026#39;row_1\u0026#39;,\u0026#39;row_2\u0026#39;], dtype=\u0026#39;object\u0026#39;) df.dtypes 返回每列的数据类型（Series）\n1 2 3 4 5 6 print(df.dtypes) # 输出示例： # col_0 int64 # col_1 object # col_2 float64 # dtype: object df.shape 返回 DataFrame 形状 (行数, 列数)\n1 2 3 print(df.shape) # 输出示例： # (3, 3) df.T DataFrame 转置，行列互换\n1 2 3 4 5 6 print(df.T) # 输出示例： row_0 row_1 row_2 col_0 1 2 3 col_1 a b c col_2 1.2 2.2 3.2 三、常用基本函数 创建 DataFrame：学生成绩数据\n1 2 3 4 5 6 7 8 9 10 data = { \u0026#39;name\u0026#39;: [\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;, \u0026#39;赵六\u0026#39;, \u0026#39;陈七\u0026#39;, \u0026#39;张三\u0026#39;, \u0026#39;孙八\u0026#39;, \u0026#39;周九\u0026#39;], \u0026#39;class\u0026#39;: [\u0026#39;A班\u0026#39;, \u0026#39;B班\u0026#39;, \u0026#39;A班\u0026#39;, \u0026#39;B班\u0026#39;, \u0026#39;A班\u0026#39;, \u0026#39;A班\u0026#39;, \u0026#39;B班\u0026#39;, \u0026#39;A班\u0026#39;], \u0026#39;gender\u0026#39;: [\u0026#39;男\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;, \u0026#39;男\u0026#39;], \u0026#39;math\u0026#39;: [85, 92, 78, 96, 88, 85, 73, 90], \u0026#39;english\u0026#39;: [80, 85, 90, 75, 82, 80, 88, 86], \u0026#39;science\u0026#39;: [np.nan, 88, 85, 92, 78, 95, 80, 84], \u0026#39;city\u0026#39;: [\u0026#39;北京\u0026#39;, \u0026#39;上海\u0026#39;, \u0026#39;广州\u0026#39;, \u0026#39;深圳\u0026#39;, \u0026#39;北京\u0026#39;, \u0026#39;北京\u0026#39;, \u0026#39;杭州\u0026#39;, \u0026#39;深圳\u0026#39;] } df = pd.DataFrame(data) 1.汇总函数（快速查看数据） 1 2 3 4 5 6 7 8 head(n) - 查看前 n 行 print(df.head(3)) tail(n) - 查看后 n 行 print(df.tail(2)) info() - 查看数据结构（列名、非空值、类型） df.info() describe() - 数值列的统计摘要 print(df.describe()) 2、特征统计函数（对数值列操作） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 选择数值列 numeric_cols = [\u0026#39;math\u0026#39;, \u0026#39;english\u0026#39;, \u0026#39;science\u0026#39;] sum: 求和 print(df[numeric_cols].sum()) mean: 平均值 print(df[numeric_cols].mean()) median: 中位数 print(df[numeric_cols].median()) var: 方差 print(df[numeric_cols].var()) std: 标准差 print(df[numeric_cols].std()) max/min: 最大最小值 print(df[numeric_cols].max()) print(df[numeric_cols].min()) quantile: 分位数 print(\u0026#34;quantile(0.25):\\n\u0026#34;, df[numeric_cols].quantile(0.25)) count: 非空值数量（注意：science 少一个） print(\u0026#34;count:\\n\u0026#34;, df[numeric_cols].count()) idxmax: 最大值的索引位置 print(\u0026#34;idxmax (math 最高分是谁?):\\n\u0026#34;, df[\u0026#39;math\u0026#39;].idxmax()) 3、唯一值函数（处理分类 / 文本列） 1 2 3 4 5 6 7 8 9 10 11 12 unique: 返回唯一值（去重） print(df[\u0026#39;gender\u0026#39;].unique()) nunique: 唯一值个数 print(df[\u0026#39;class\u0026#39;].nunique()) value_counts: 各值出现次数 print(df[\u0026#39;gender\u0026#39;].value_counts()) duplicated: 返回每行是否是重复行 print(df.duplicated(subset=[\u0026#39;name\u0026#39;])) drop_duplicates: 删除重复行 df_no_dup = df.drop_duplicates(subset=[\u0026#39;name\u0026#39;], keep=\u0026#39;first\u0026#39;) print(df_no_dup[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;]]) subset = [\u0026#39;name\u0026#39;]表示按姓名去重，keep = \u0026#39;first\u0026#39;保留第一次出现的 4、替换函数（replace） 方法1：单值替换\n1 2 df[\u0026#39;gender\u0026#39;] = df[\u0026#39;gender\u0026#39;].replace(\u0026#39;男\u0026#39;, \u0026#39;Male\u0026#39;) print(\u0026#34;性别替换为英文:\\n\u0026#34;, df[[\u0026#39;name\u0026#39;, \u0026#39;gender\u0026#39;]]) 方法2：字典替换\n1 2 df[\u0026#39;class\u0026#39;] = df[\u0026#39;class\u0026#39;].replace({\u0026#39;A班\u0026#39;: \u0026#39;Class A\u0026#39;, \u0026#39;B班\u0026#39;: \u0026#39;Class B\u0026#39;}) print(\u0026#34;班级替换:\\n\u0026#34;, df[[\u0026#39;name\u0026#39;, \u0026#39;class\u0026#39;]].head(3)) 方法3：用 np.nan 替换异常值\n1 2 df[\u0026#39;math\u0026#39;] = df[\u0026#39;math\u0026#39;].replace(96, np.nan) print(\u0026#34;数学96替换为NaN:\\n\u0026#34;, df[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;]].head(4)) 5、排序函数（Sorting） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 sort_values()：按值排序 df_sorted = df.sort_values(by=\u0026#39;math\u0026#39;, ascending=False) print(df_sorted[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;]]) # 输出：赵六96 → 周九90 → 李四92 → ... print(\u0026#34;\\n2. 按多个列排序：先按班级，再按数学成绩降序：\u0026#34;) df_sorted2 = df.sort_values(by=[\u0026#39;class\u0026#39;, \u0026#39;math\u0026#39;], ascending=[True, False]) print(df_sorted2[[\u0026#39;name\u0026#39;, \u0026#39;class\u0026#39;, \u0026#39;math\u0026#39;]]) # 先排A班，数学高的在前；再排B班 print(\u0026#34;\\n3. 按姓名字符串排序（升序）：\u0026#34;) df_sorted_name = df.sort_values(by=\u0026#39;name\u0026#39;, ascending=True) print(df_sorted_name[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;]]) 中文按拼音排序：陈七 → 李四 → 孙八 → 王五 → 张三 → 赵六 → 周九2.sort_index()：按索引排序 # 打乱索引示例 df_shuffled = df.sample(frac=1) # 随机打乱行 print(\u0026#34;\\n打乱后：\u0026#34;) print(df_shuffled[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;]]) print(\u0026#34;\\n按索引排序恢复：\u0026#34;) df_restored = df_shuffled.sort_index() print(df_restored[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;]]) 适用于索引有序但被打乱的情况 6、apply方法（数据转换利器） apply可以对行、列、元素应用自定义函数。 1).对某一列使用apply\n1 2 3 4 5 6 7 8 示例：判断数学是否优秀 def is_good_math(score): return \u0026#39;优秀\u0026#39; if score \u0026gt;= 90 else \u0026#39;良好\u0026#39; df[\u0026#39;math_level\u0026#39;] = df[\u0026#39;math\u0026#39;].apply(is_good_math) print(df[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;, \u0026#39;math_level\u0026#39;]]) 示例：字符串处理（城市加“市”） df[\u0026#39;city_full\u0026#39;] = df[\u0026#39;city\u0026#39;].apply(lambda x: x + \u0026#34;市\u0026#34;) print(df[[\u0026#39;city\u0026#39;, \u0026#39;city_full\u0026#39;]]) 2).对多列使用\n1 2 3 4 5 6 7 apply（axis = 1表示按行） 示例1：计算总分（跳过NaN） def calculate_total(row): return row[\u0026#39;math\u0026#39;] + row[\u0026#39;english\u0026#39;] + (row[\u0026#39;science\u0026#39;] if pd.notna(row[\u0026#39;science\u0026#39;]) else 0) df[\u0026#39;total\u0026#39;] = df.apply(calculate_total, axis=1) print(\u0026#34;\\n6. 每人总分：\u0026#34;) print(df[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;, \u0026#39;english\u0026#39;, \u0026#39;science\u0026#39;, \u0026#39;total\u0026#39;]]) 示例2：计算总分后，生成评语\n1 2 3 4 5 6 7 8 9 10 def get_comment(row): if row[\u0026#39;total\u0026#39;] \u0026gt; 250: return \u0026#34;优秀\u0026#34; elif row[\u0026#39;total\u0026#39;] \u0026gt; 230: return \u0026#34;良好\u0026#34; else: return \u0026#34;加油\u0026#34; df[\u0026#39;comment\u0026#39;] = df.apply(get_comment, axis=1) print(\u0026#34;\\n7. 添加评语：\u0026#34;) print(df[[\u0026#39;name\u0026#39;, \u0026#39;total\u0026#39;, \u0026#39;comment\u0026#39;]]) 3).对整个Series或DataFrame使用apply\n1 2 3 4 5 6 对多列同时 apply（比如标准化） print(\u0026#34;\\n8. 数学成绩标准化（减均值除标准差）：\u0026#34;) mean = df[\u0026#39;math\u0026#39;].mean() std = df[\u0026#39;math\u0026#39;].std() df[\u0026#39;math_std\u0026#39;] = df[\u0026#39;math\u0026#39;].apply(lambda x: (x - mean) / std) print(df[[\u0026#39;name\u0026#39;, \u0026#39;math\u0026#39;, \u0026#39;math_std\u0026#39;]].round(2)) 四、窗口函数（Window Functions） Pandas 提供了 3 种窗口类型，常用于时间序列或顺序数据。我们先构造一个时间序列数据来演示：\n1 2 3 4 5 6 7 #创建时间序列数据：某产品每日销量 dates = pd.date_range(\u0026#39;2025-01-01\u0026#39;, periods=10) sales = [100, 120, 110, 130, 140, 135, 150, 160, 155, 170] df_ts = pd.DataFrame({\u0026#39;date\u0026#39;: dates, \u0026#39;sales\u0026#39;: sales}) df_ts.set_index(\u0026#39;date\u0026#39;, inplace=True) print(\u0026#34;时间序列数据:\u0026#34;) print(df_ts) 滑动窗口 rolling()（最常用）计算固定窗口大小的统计值，如“过去3天的平均销量”。\n1 2 3 4 5 6 7 8 9 10 11 # 3日移动平均 df_ts[\u0026#39;ma_3\u0026#39;] = df_ts[\u0026#39;sales\u0026#39;].rolling(window=3).mean() print(\u0026#34;\\n1. 3日移动平均:\u0026#34;) print(df_ts[[\u0026#39;sales\u0026#39;, \u0026#39;ma_3\u0026#39;]]) 输出： sales ma_3 2025-01-01 100 NaN 2025-01-02 120 NaN 2025-01-03 110 110.000000 2025-01-04 130 120.000000 ... 前两行是 NaN，因为不够3个数据 扩张窗口 expanding()\n1 2 3 4 5 6 #从开始到当前的所有数据进行计算，如“累计平均”。 #累计平均销量 df_ts[\u0026#39;expanding_mean\u0026#39;] = df_ts[\u0026#39;sales\u0026#39;].expanding().mean() print(\u0026#34;\\n2. 累计平均:\u0026#34;) print(df_ts[[\u0026#39;sales\u0026#39;, \u0026#39;expanding_mean\u0026#39;]]) #越往后，窗口越大，结果越稳定 指数加权窗口： ewm()（Exponentially Weighted）越近的数据权重越高，适合趋势预测。\n1 2 3 4 5 #指数加权移动平均（EWMA） df_ts[\u0026#39;ewm_mean\u0026#39;] = df_ts[\u0026#39;sales\u0026#39;].ewm(alpha=0.3).mean() print(\u0026#34;\\n3. 指数加权平均 (alpha=0.3):\u0026#34;) print(df_ts[[\u0026#39;sales\u0026#39;, \u0026#39;ewm_mean\u0026#39;]]) alpha 越大，越重视近期数据 ​\n","date":"2025-08-18T00:00:00Z","permalink":"https://example.com/p/1.pandas%E5%9F%BA%E7%A1%80/","title":"1.Pandas基础"},{"content":"Pandas 索引器与多级索引笔记 一、索引器（Indexers） Pandas 提供了多种方式来访问数据：\nloc ：基于标签（label）索引 iloc ：基于整数位置（position）索引 at ：快速标签访问单个标量 iat ：快速位置访问单个标量 示例\n1 2 3 4 5 6 7 8 9 10 11 import pandas as pd df = pd.DataFrame({ \u0026#34;A\u0026#34;: [1, 2, 3], \u0026#34;B\u0026#34;: [4, 5, 6] }, index=[\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;]) print(df.loc[\u0026#34;x\u0026#34;, \u0026#34;A\u0026#34;]) # 标签索引 → 1 print(df.iloc[0, 0]) # 位置索引 → 1 print(df.at[\u0026#34;y\u0026#34;, \u0026#34;B\u0026#34;]) # 快速标签取值 → 5 print(df.iat[2, 1]) # 快速位置取值 → 6 二、单级索引（普通 Index） df.index ：索引对象\ndf.columns ：列索引\ndf.reset_index() ：恢复为普通列\ndf.set_index(\u0026quot;col\u0026quot;) ：设置某列为索引\n1 2 3 4 5 6 7 8 df = pd.DataFrame({ \u0026#34;id\u0026#34;: [101, 102, 103], \u0026#34;name\u0026#34;: [\u0026#34;Tom\u0026#34;, \u0026#34;Jerry\u0026#34;, \u0026#34;Anna\u0026#34;] }) df2 = df.set_index(\u0026#34;id\u0026#34;) print(df2) print(df2.index) # Index([101, 102, 103], dtype=\u0026#34;int64\u0026#34;) 三、多级索引（MultiIndex） 多级索引（层次化索引）用于表示分层的数据结构，可以应用于 行 或 列。\n1. 创建多级索引 1 2 3 4 5 6 7 8 arrays = [ [\u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;], [1, 2, 1, 2] ] index = pd.MultiIndex.from_arrays(arrays, names=(\u0026#34;level1\u0026#34;, \u0026#34;level2\u0026#34;)) df = pd.DataFrame({\u0026#34;value\u0026#34;: [10, 20, 30, 40]}, index=index) print(df) 输出\n1 2 3 4 5 level1 level2 value a 1 10 2 20 b 1 30 2 40 2. 多级索引取值 1 2 3 print(df.loc[\u0026#34;a\u0026#34;]) # 取 level1 = \u0026#34;a\u0026#34; print(df.loc[(\u0026#34;b\u0026#34;, 1)]) # 取 level1=\u0026#34;b\u0026#34; 且 level2=1 print(df.loc[(\u0026#34;a\u0026#34;, slice(None))]) # 取 level1=\u0026#34;a\u0026#34; 所有值 四、多级索引常用操作 查看层级名称\n1 print(df.index.names) # [\u0026#39;level1\u0026#39;, \u0026#39;level2\u0026#39;] 交换层级顺序\n1 print(df.swaplevel()) 按索引排序\n1 print(df.sort_index(level=0)) # 按第0层排序 恢复普通列\n1 print(df.reset_index()) 📌 总结：\nloc / iloc / at / iat → 数据访问方式 单级索引适合一维标签，set_index / reset_index 转换灵活 多级索引能表示层级关系，常见于透视表、分组结果 常用操作有 swaplevel、sort_index、reset_index ","date":"2025-08-18T00:00:00Z","permalink":"https://example.com/p/2.pandas%E7%B4%A2%E5%BC%95/","title":"2.Pandas索引"},{"content":"Jupyter 是一个交互式的计算环境，主要用于写、运行和展示代码（Python、R、Julia 等），非常适合做数据分析、可视化、机器学习实验或者写教程笔记。\n安装 Jupyter Jupyter 需要 Python 环境\n1 2 3 4 pip install notebook pip install jupyterlab-language-pack-zh-CN jupyter notebook #进入你想工作的文件夹，然后启动。 jupyter lab #这是另一种启动方式,jupyterlab是jupyter notebook的下一代产品，集成了更多功能 浏览器会自动打开 http://localhost:8888 如果浏览器没自动打开，会在终端看到一个链接，复制到浏览器即可。 启动后在Settings\u0026ndash;Language-Chinese (Simplified, China)-中文(简体,中国)，进行切换显示语言。\n基本使用 创建新 Notebook 在网页右上角选择 New → Python 3（或其它语言） 会出现一个 .ipynb 文件，分为 Cell（单元格）\n单元格类型\n1 2 3 Code：写代码并运行（Shift + Enter 执行） Markdown：写文字说明（支持标题、公式、图片） Raw：原始文本，不执行 常用快捷键（命令模式下） 1 2 3 4 5 6 7 8 9 10 11 Esc 进入命令模式，Enter 进入编辑模式 A 在上方插入单元格 B 在下方插入单元格 DD 删除单元格 M 把单元格改为 Markdown Y 把单元格改为 Code Shift + Enter 运行并跳到下一格 在 Jupyter Notebook 里，打开帮助文档的快捷键是： 按 Shift + Tab，把光标放到函数或对象名后面，按一次 Shift + Tab 会弹出简要帮助提示（参数说明）。 连续按 Shift + Tab 两次或三次，会展开更详细的文档窗口。 进阶技巧 可视化示例 1 2 3 4 5 import matplotlib.pyplot as plt x = [1, 2, 3, 4] y = [1, 4, 9, 16] plt.plot(x, y) plt.show() Jupyter + Pandas 数据分析入门示例 安装必要的库\n1 pip install pandas matplotlib 代码示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import pandas as pd import matplotlib.pyplot as plt # 让图表直接显示在 Notebook 中 %matplotlib inline # 设置中文字体 plt.rcParams[\u0026#34;font.family\u0026#34;] = [\u0026#34;Microsoft YaHei\u0026#34;] plt.rcParams[\u0026#34;axes.unicode_minus\u0026#34;] = False # ===== 1. 创建模拟账单数据 ===== data = { \u0026#34;日期\u0026#34;: [\u0026#34;2025-08-01\u0026#34;, \u0026#34;2025-08-01\u0026#34;, \u0026#34;2025-08-02\u0026#34;, \u0026#34;2025-08-02\u0026#34;, \u0026#34;2025-08-03\u0026#34;], \u0026#34;分类\u0026#34;: [\u0026#34;餐饮\u0026#34;, \u0026#34;交通\u0026#34;, \u0026#34;餐饮\u0026#34;, \u0026#34;购物\u0026#34;, \u0026#34;交通\u0026#34;], \u0026#34;金额\u0026#34;: [35.5, 12.0, 58.0, 200.0, 18.0], \u0026#34;备注\u0026#34;: [\u0026#34;早餐\u0026#34;, \u0026#34;地铁\u0026#34;, \u0026#34;午餐\u0026#34;, \u0026#34;超市\u0026#34;, \u0026#34;公交\u0026#34;] } df = pd.DataFrame(data) df[\u0026#34;日期\u0026#34;] = pd.to_datetime(df[\u0026#34;日期\u0026#34;]) print(\u0026#34;=== 原始数据 ===\u0026#34;) print(df) print(\u0026#34;\\n=== 餐饮类消费 ===\u0026#34;) print(df[df[\u0026#34;分类\u0026#34;] == \u0026#34;餐饮\u0026#34;]) category_sum = df.groupby(\u0026#34;分类\u0026#34;)[\u0026#34;金额\u0026#34;].sum().reset_index() print(\u0026#34;\\n=== 按分类汇总 ===\u0026#34;) print(category_sum) plt.figure(figsize=(5, 5)) plt.pie(category_sum[\u0026#34;金额\u0026#34;], labels=category_sum[\u0026#34;分类\u0026#34;], autopct=\u0026#34;%.1f%%\u0026#34;) plt.title(\u0026#34;各类消费占比\u0026#34;) plt.show() daily_sum = df.groupby(\u0026#34;日期\u0026#34;)[\u0026#34;金额\u0026#34;].sum().reset_index() plt.figure(figsize=(6, 4)) plt.plot(daily_sum[\u0026#34;日期\u0026#34;], daily_sum[\u0026#34;金额\u0026#34;], marker=\u0026#34;o\u0026#34;) plt.title(\u0026#34;每日总消费趋势\u0026#34;) plt.xlabel(\u0026#34;日期\u0026#34;) plt.ylabel(\u0026#34;金额 (元)\u0026#34;) plt.grid(True) plt.show() ","date":"2025-08-11T00:00:00Z","permalink":"https://example.com/p/jupyter%E4%BD%BF%E7%94%A8/","title":"Jupyter使用"},{"content":"安装git 1 2 3 4 5 6 7 8 9 10 11 [root@localhost ~]# git --version git version 1.8.3.1 #centos默认自带的版本是1.8，生产环境一般2.7以上 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker wget https://github.com/git/git/archive/v2.20.0.zip unzip v2.20.0.zip cd git-2.20.0/ make prefix=/usr/local/git all make prefix=/usr/local/git install cp /usr/local/git/bin/* /usr/bin/ git --version git文件状态 按照文件的存放位置分：\n在你自建的Git本地仓库中，有三个区域：\nGit仓库：是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。\n工作目录：是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。\n暂存区域：是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也称作`‘索引’\u0026rsquo;，不过一般说法还是叫暂存区域。\n按照文件的状态分： 工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪\n未跟踪的文件：改动不受到Git的版本控制，即为Unstracked状态,还没有被git管理 已跟踪的文件：即被纳入版本控制的文件，又分为未修改（unmodified）、已修改（modified）、已暂存（staged）、已提交到版本库（committed）四种状态 git基本使用 1 2 3 4 5 6 7 git init，初始化，表示即将对当前文件夹进行版本控制。 git status，查看Git当前状态，如：那些文件被修改过、那些文件还未提交到版本库等。 git add 文件名，将指定文件添加到版本库的暂存状态。 git commit -m \u0026#34;xxx\u0026#34; 把暂存区的所有文件提交到仓库区，暂存区空空荡荡。 git push -u origin master 把仓库区的文件提交到远程仓库里。 git remote add origin https://github.com/name/name_cangku.git 把本地仓库与远程仓库连接起来。 git log，查看提交记录，即：历史版本记录 本地仓库 全局配置\n添加用户名邮箱，git在提交时候会记录当前版本由那个用户提交\n1 2 git config --global user.name \u0026#34;wangc\u0026#34; git config --global user.email wangc@example.com 创建本地仓库\n1 2 3 4 5 6 7 8 mkdir test cd test/ git init #初始化test目录，初始化后，会在当前目录自动创建 .git 文件夹，该文件是Git中最重要的文件夹，因为Git相关文件以及版本都将保存在该文件夹中，通过Git命令可以将所有版本保存在 .git 文件中 echo \u0026#34;print(\u0026#34;hello\u0026#34;)\u0026#34; \u0026gt;hello.py git status git add . #添加当前目录下所有文件到暂存区 git commit -m \u0026#39;第一次提交\u0026#39; git log 远程仓库 全局配置\n1 2 3 #添加用户名邮箱，git在提交时候会记录当前版本由那个用户提交 git config --global user.name \u0026#34;Administrator\u0026#34; git config --global user.email \u0026#34;admin@example.com\u0026#34; 使用场景1：克隆远程仓库 1 2 3 4 5 6 git clone git@192.168.100.163:root/python-demo.git cd python-demo touch README.md git add README.md git commit -m \u0026#34;add README\u0026#34; git push -u origin master 使用场景2：推送现有文件夹 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #假设本地已经有个test仓库了，但想把test里的代码，保存到远程python-demo仓库之上 mkdir test cd test/ git init touch hello.py git remote add origin git@192.168.100.163:root/python-demo.git #本地的仓库与Gitlab上的远程仓库做关联 git add . git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin master 使用场景3：项目迁移 git clone git@192.168.100.163:root/python-old.git #原服务器代码地址 cd python-old git remote rename origin old-origin #首先将原来的origin重命名一下 git remote add origin git@192.168.100.163:root/python-new.git #新服务器代码需要存放的地址 git push -u origin --all #上传到新服务器 git push -u origin --tags #上传tag 版本回滚 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [root@localhost test]# vim app.py [root@localhost test]# git add . [root@localhost test]# git commit -m \u0026#39;第二次提交\u0026#39; [root@localhost test]# git log commit 7e3180eb85d99fb0d6166f909d5228899fc339bf (HEAD -\u0026gt; master) Author: wangchuang \u0026lt;you@example.com\u0026gt; Date: Sun Jan 19 15:50:48 2020 +0800 第二次提交 commit 9e1b2841ef1ada74d66a4c19b81da394b260c873 Author: wangchuang \u0026lt;you@example.com\u0026gt; Date: Sun Jan 19 15:21:00 2020 +0800 第一次提交 [root@localhost test]# git reset --hard 9e1b2841ef1ada74d66a4c19b81da394b260c873 da394b260c873 HEAD 现在位于 9e1b284 第一次提交 回滚倒是完成了，但如果某一天想要再回到回滚前的版本怎么办呢？\n1 2 3 4 5 6 [root@localhost test]# git reflog 9e1b284 (HEAD -\u0026gt; master) HEAD@{0}: reset: moving to 9e1b2841ef1ada74d66a4c19b81da394b260c873 7e3180e HEAD@{1}: commit: 第二次提交 9e1b284 (HEAD -\u0026gt; master) HEAD@{2}: commit (initial): 第一次提交 [root@localhost test]# git reset --hard 7e3180e HEAD 现在位于 7e3180e 第二次提交 分支管理 1 2 3 4 5 6 7 8 git branch 分支名称 创建分支 git checkout 分支名称 切换分支 git branch -m 分支名称 创建并切换到指定分支 git branch 查看所有分支 git branch -d 分支名称 删除分支 git merge 分支名称 将指定分支合并到当前分支 git branch –merged #查看哪些分支被合并了 git branch –no-merged #查看哪些分支没有合并 branch称为分支，默认仅有一个名为master的分支。一般开发新功能流程为：开发新功能时会在分支dev上进行，开发完毕后再合并到master分支 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 [root@localhost test]# git branch dev # 创建新分支，即：拷贝一份当前所在分支代码到新分支 [root@localhost test]# git checkout dev # 切换到dev分支 [root@localhost test]# vim new.py [root@localhost test]# git status 位于分支 dev 未跟踪的文件: （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 以包含要提交的内容） new.py 提交为空，但是存在尚未跟踪的文件（使用 \u0026#34;git add\u0026#34; 建立跟踪） [root@localhost test]# git add . [root@localhost test]# git commit -m \u0026#39;新功能开发完毕\u0026#39; [dev be42e4d] 新功能开发完毕 1 file changed, 1 insertion(+) create mode 100644 new.py [root@localhost test]# git checkout master 切换到分支 \u0026#39;master\u0026#39; [root@localhost test]# git merge dev # 将dev分支内容合并到master分支 更新 7e3180e..be42e4d Fast-forward new.py | 1 + 1 file changed, 1 insertion(+) create mode 100644 new.py 按照着以上的流程进行开发，如果遇到上文开发到一般需要临时修复Bug的情况，可以按照下图的流程进行： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 [root@localhost test]# git branch * master [root@localhost test]# git branch dev # 创建dev分支用于开发新功能 [root@localhost test]# git checkout dev # 切换到dev分支 [root@localhost test]# vim new.py # 开发新功能到一半，需要紧急修复Bug [root@localhost test]# git add . [root@localhost test]# git commit -m \u0026#39;新功能开发一半\u0026#39; [dev 162d717] 新功能开发一半 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 new.py [root@localhost test]# git checkout master #切换回master分支 [root@localhost test]# git branch bug #创建bug分支 [root@localhost test]# git checkout bug #切换到bug分支 [root@localhost test]# vim bug.py #修改bug [root@localhost test]# git add . [root@localhost test]# git commit -m \u0026#39;紧急修复bug\u0026#39; #提交bug [root@localhost test]# git checkout master #切换回master [root@localhost test]# git merge bug #合并bug分子 [root@localhost test]# git checkout dev　＃继续开发 切换到分支 \u0026#39;dev\u0026#39; ","date":"2025-08-07T00:00:00Z","permalink":"https://example.com/p/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"Git使用教程"},{"content":"一、Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\nMarkdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\nMarkdown 编写的文档后缀为 .md, .markdown。\nMarkdown 能被使用来撰写电子书，如：Gitbook。/\n当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。 markdown编写Hello World!语法：\n1 # Hello World! 二、Markdown标题 使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。\n使用#号标记标题语法格式：\n1 2 3 4 5 6 7 8 9 10 11 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 三、Markdown段落 Markdown的段落没有特殊的格式，直接编写文字就好，段落的换行号是使用两个以上的空格加回车。\n3.1 字体\nMarkdown 可以使用以下几种字体：\n用1个星号*或底线_表示斜体 用2个星号*或底线_表示粗体 用3个星号*或底线_表示粗斜体 语法格式：\n1 2 3 4 5 6 7 8 9 10 11 *斜体文字* _斜体文字_ **粗体文字** __粗体文字__ ***粗斜体文字*** ___粗斜体文字___ 显示效果：\n斜体文字\n斜体文字\n粗体文字\n粗体文字\n*粗斜体文字*\n*粗斜体文字*\n3.2 分隔线\n可以在一行中用三个以上的星号*、减号-、底线_来建立一个分隔线，行内不能有其他东西，你也可以在星号或减号蹭插入空格。下面这种写法都可以建立分隔线：\n1 2 3 4 5 *** * * * ****** - - - ------ 显示效果：\n3.3 删除线\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线~~即可。\n语法格式：\n1 2 3 baidu.com sina.com ~~tencent.com~~ 显示效果如下：\nhttp://baidu.com http://sina.com tencent.com\n3.4 下划线\n下划线可以通过HTML的标签来实现\n1 \u0026lt;u\u0026gt;带下划线文本\u0026lt;/u\u0026gt; 显示效果如下： 带下划线文本\n3.5 脚注\n脚注是对文本的补充说明。\nMarkdown脚注的格式如下：\n1 [^要注明的文本]： 显示效果： [^要注明的文本]：\n四、Markdown 列表 4.1 有序列表和无序列表\nMarkdown支持有序列表和无序列表，无序列表使用星号(*)、加号(+)或者减号(-)作为标记：\n1 2 3 4 5 6 7 8 9 10 11 * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 显示效果：\n第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 有序列表直接在文字有加上1. 2. 3. 来表示，符号和文字之间加上一个空格字符，如：\n1 2 3 1. 第一项 2. 第二项 3. 第三项 第一项 第二项 第三项 4.2 列表嵌套\n列表嵌套只需在子列表的选项前添加四个空格即可：\n1 2 3 4 5 6 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 显示效果：\n第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第二个元素 五、Markdown区块 Markdown区块引用是在段落开头使用\u0026gt;符号，然后后面紧跟一个空格符号：\n1 2 3 \u0026gt; 区块引用 \u0026gt; Markdown教程 \u0026gt; 学的不仅是技术更是梦想 显示效果如下：\n区块引用 Markdown教程 学的不仅是技术更是梦想\n另外区块是可以嵌套的，一个\u0026gt;符号是最外层，两个符号是第一层嵌套，以此类推：\n1 2 3 \u0026gt; 最外层 \u0026gt;\u0026gt; 第一层嵌套 \u0026gt;\u0026gt;\u0026gt; 第二层嵌套 显示效果如下：\n最外层 第一层嵌套 第二层嵌套\n5.1 区块中使用列表\n区块中使用列表实例如下：\n1 2 3 4 5 6 \u0026gt; 区块中使用列表 \u0026gt; 1. 第一项 \u0026gt; 2. 第二项 \u0026gt; + 第一项 \u0026gt; + 第二项 \u0026gt; + 第三项 显示效果：\n区块中使用列表 1. 第一项 2. 第二项 + 第一项 + 第二项 + 第三项\n5.2 列表中使用区块\n如果要在列表项目内放进区块，那么就需要在\u0026gt;前添加四个空格和缩进。\n1 2 3 4 * 第一项 \u0026gt; Markdown教程 \u0026gt; 学的不仅是技术更是梦想 * 第二项 显示效果如下：\n第一项 \u0026gt; Markdown教程 \u0026gt; 学的不仅是技术更是梦想 第二项 六、Markdown代码框 如果是段落上的一个函数或片段的代码可以用两个\u0026rsquo;把它包起来。\n1 \u0026#39;print()\u0026#39; 函数 \u0026lsquo;print()\u0026rsquo; 函数\n6.1 代码区块\n代码区块使用4个空格或者一个制表符（Tab键）。\n1 2 3 4 \u0026lt;?Python print(\u0026#39;Markdown\u0026#39;) def test(): print(\u0026#39;Markdown test!\u0026#39;) 也可以用\u0026rsquo;\u0026lsquo;\u0026lsquo;包裹一段代码，并指定一种语言（也可以不指定）：\n1 2 3 4 5 \u0026#39;\u0026#39;\u0026#39;javascript $(document).read(function(){ alert(\u0026#39;Markdown\u0026#39;); }); \u0026#39;\u0026#39;\u0026#39; 显示效果：\n1 2 3 4 5 \u0026#39;\u0026#39;\u0026#39;javascript $(document).read(function){ alert(\u0026#39;Markdown\u0026#39;); }); \u0026#39;\u0026#39;\u0026#39; 七、Markdown链接 链接使用方法如下：\n1 2 3 [链接名称](链接地址) 或者 \u0026lt;链接地址\u0026gt; 例如：\n1 2 这是一个链接 [新浪新闻](https://news.sina.com.cn/) \u0026lt;https://news.sina.com.cn/\u0026gt; 显示效果如下：\n这是一个链接 新浪新闻\nhttps://news.sina.com.cn/\n7.1 高级链接\n1 2 3 4 5 6 7 链接也可以用变量来代替，文档末尾附带变量地址： 这个链接用1作为网址变量[baidu][1] 这个链接用markdown作为网址变量[Markdown][markdown] 然后文档的结尾为变量赋值(网址) [1]: http://www.baidu.com [markdown]: http://www.markdown.com 显示效果如下：\n链接也可以用变量来代替，文档末尾附带变量地址： 这个链接用1作为网址变量baidu 这个链接用markdown作为网址变量Markdown 然后文档的结尾为变量赋值(网址)\n八、Markdown图片 Markdown图片语法格式为：\n1 2 ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \u0026#34;可选标题\u0026#34;) 开头一个感叹号! 接着一个方括号，里面放上图片的代替文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的\u0026rsquo;title\u0026rsquo;属性文字。 实例如下：\n1 2 3 4 5 ![有问题上知乎 图标](https://pic4.zhimg.com/80/v2-a47051e92cf74930bedd7469978e6c08_hd.png) --- ![通信人家园 图标](http://www.txrjy.com/static/image/common/logo.gif) 显示效果如下：\n也可以像网址那样对图片使用变量：\n1 2 3 这个图片链接用1作为网址变量[zhihu][1] 然后在文档的结尾为变量赋值（网址） [1]: (https://pic4.zhimg.com/80/v2-a47051e92cf74930bedd7469978e6c08_hd.png) 显示效果如下：\n这个图片链接用1作为网址变量zhihu 然后在文档的结尾为变量赋值（网址）\nMarkdown 没有办法指定图片的高度与宽度，如果需要的话，可以使用普通的\n标签。\n1 \u0026lt;img src=“https://pic4.zhimg.com/80/v2-a47051e92cf74930bedd7469978e6c08_hd.png” width=10%\u0026gt; 显示效果：\n九、Markdown表格 Markdown制作表格使用|来分隔不同的单元格，使用-来分隔表头和其他行。\n语法格式：\n1 2 3 4 |表头1|表头2| |----|----| |单元格11|单元格12| |单元格21|单元格22| 显示效果：\n| 表头1 | 表头2 | | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026ndash; | | 单元格11 | 单元格12 | | 单元格21 | 单元格22 |\n9.1 对齐方式\n可以设置表头的对齐方式：\n-: 设置内容或标题栏右对齐 :- 设置内容或标题栏左对齐 :-: 设置内容或标题栏居中对齐 语法格式：\n1 2 3 4 |左对齐|居中对齐|右对齐| |:----|:----:|----:| |单元格11|单元格12|单元格13| |单元格21|单元格22|单元格23| 显示效果：\n| 左对齐 | 居中对齐 | 右对齐 | | :\u0026mdash;\u0026mdash;- | :\u0026mdash;\u0026mdash;: | \u0026mdash;\u0026mdash;-: | | 单元格11 | 单元格12 | 单元格13 | | 单元格21 | 单元格22 | 单元格23 |\n十、Markdown高级技巧 支持的HTML元素\n不在Markdown涵盖范围之内的标签，都可以直接在文档里面用HTML撰写。\n目前支持的HTML元素有： *等 ，如：*\n1 使用\u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Alt\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Del\u0026lt;/kbd\u0026gt;重启电脑 *显示效果如下：*\n*使用Ctrl+Alt+Del重启电脑*\n*10.1 转义*\n*Markdown使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown使用反斜杠转义特殊字符：*\n1 2 **文本加粗** \\*\\*正常显示星号\\*\\* *显示效果:*\n*文本加粗 *正常显示星号**\n*Mrkdown支持以下这些符号前面加上反斜杠来帮助插入普通符号：*\n1 2 3 4 5 6 7 8 9 10 11 12 \\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号 *10.2 数学公式*\n*当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。*\n*实例如下：*\n1 2 3 $$ \\int_0^1 {x^2} \\,{\\rm d}x $$ 十一、标题自动编号 https://blog.csdn.net/jyn15159/article/details/122978472\n打开Typora这款软件，点击左上角的“文件”，接着点击“偏好设置” 选择“外观”，点击“打开主题文件夹” 打开Typora的theme文件夹，新建样式文件base.user.css\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 /** initialize css counter */ #write { counter-reset: h1 } h1 { counter-reset: h2 } h2 { counter-reset: h3 } h3 { counter-reset: h4 } h4 { counter-reset: h5 } h5 { counter-reset: h6 } /** put counter result into headings */ #write h1:before { counter-increment: h1; content: counter(h1) \u0026#34;. \u0026#34; } #write h2:before { counter-increment: h2; content: counter(h1) \u0026#34;.\u0026#34; counter(h2) \u0026#34;. \u0026#34; } #write h3:before, h3.md-focus.md-heading:before /** override the default style for focused headings */ { counter-increment: h3; content: counter(h1) \u0026#34;.\u0026#34; counter(h2) \u0026#34;.\u0026#34; counter(h3) \u0026#34;. \u0026#34; } #write h4:before, h4.md-focus.md-heading:before { counter-increment: h4; content: counter(h1) \u0026#34;.\u0026#34; counter(h2) \u0026#34;.\u0026#34; counter(h3) \u0026#34;.\u0026#34; counter(h4) \u0026#34;. \u0026#34; } #write h5:before, h5.md-focus.md-heading:before counter-increment: h5; content: counter(h1) \u0026#34;.\u0026#34; counter(h2) \u0026#34;.\u0026#34; counter(h3) \u0026#34;.\u0026#34; counter(h4) \u0026#34;.\u0026#34; counter(h5) \u0026#34;. \u0026#34; } #write h6:before, h6.md-focus.md-heading:before { counter-increment: h6; content: counter(h1) \u0026#34;.\u0026#34; counter(h2) \u0026#34;.\u0026#34; counter(h3) \u0026#34;.\u0026#34; counter(h4) \u0026#34;.\u0026#34; counter(h5) \u0026#34;.\u0026#34; counter(h6) \u0026#34;. \u0026#34; } /** override the default style for focused headings */ #write\u0026gt;h3.md-focus:before, #write\u0026gt;h4.md-focus:before, #write\u0026gt;h5.md-focus:before, #write\u0026gt;h6.md-focus:before, h3.md-focus:before, h4.md-focus:before, h5.md-focus:before, h6.md-focus:before { color: inherit; border: inherit; border-radius: inherit; position: inherit; left:initial; float: none; top:initial; font-size: inherit; padding-left: inherit; padding-right: inherit; vertical-align: inherit; font-weight: inherit; line-height: inherit; } 保存base.user.css文件，重启Typora软件\n","date":"2025-08-07T00:00:00Z","permalink":"https://example.com/p/markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"Markdown使用教程"},{"content":" 1 2 https://www.elegantcrazy.com/posts/blog/build-blog-with-github-pages-hugo-and-papermod/ https://jimmysong.io/book/hugo-handbook/introduction/quick-start/ 1.安装 Git Hugo 项目通常需要 Git 进行版本控制和主题管理\n1 https://git-scm.com/downloads/win 2.创建仓库 在Github创建仓库，仓库名填写**[用户名].github.io**，注意[用户名]部分必须是Github用户名，否则Github Pages不会正常工作。\n1 2 3 新建两个仓库 wchuang099.github.io #博客仓库 hugo-blog-source #备份博客源文件 3.安装 Hugo 下载安装包，hugo免安装，解压添加环境变量即可\n1 2 3 # 注意 hugo和主题都找最新版的下载即可，老版本会有兼容的问题 https://github.com/gohugoio/hugo/releases/download/v0.148.2/hugo_extended_0.148.2_windows-amd64.zip hugo version 生成项目 1 2 hugo new site hugo-blog cd hugo-blog 这将创建标准的项目目录结构，包括： •\tarchetypes/ - 内容模板 •\tassets/ - 资源文件 •\tcontent/ - 内容源文件 •\tdata/ - 数据文件 •\tlayouts/ - 布局模板 •\tstatic/ - 静态文件 •\tthemes/ - 主题 •\thugo.toml – 配置文件，旧版本文件为config.toml\n下载主题 1 2 3 #可以去官网找自己喜欢的主题 https://themes.gohugo.io/ https://github.com/CaiJimmy/hugo-theme-stack/archive/refs/tags/v3.30.0.zip 解压到themes\\目录下 启动主题 1 2 3 4 5 复制样例文件hugo-blog\\themes\\hugo-theme-stack\\exampleSite找到content和hugo.yaml复制到hugo-blog目录下 hugo-blog\\content\\post\\rich-content #删除此目录，引用的一些国外网站会导致超时启动不了 hugo-blog\\hugo.toml #hugo.yaml可以修改下，符合自己的风格 参考https://github.com/wchuang099/hugo-blog-source/blob/main/hugo.yaml) 新建文章 在网站中添加第一篇文章：\n1 hugo new content post/myFirstBlog/index.md 新创建的内容文件位于 content/posts/my-first-post.md\n1 2 3 4 5 +++ date = \u0026#39;2025-08-04T19:05:29+08:00\u0026#39; draft = true title = \u0026#39;My First Post\u0026#39; +++ 注意draft的值是true，表示当前文档是草稿。默认情况下，Hugo在编译网站时不会发布草稿。\n开发与测试 启动开发服务器 1 hugo server -D -D 标志表示构建草稿内容。服务器会： •\t在本地构建网站并提供服务（通常在 http://localhost:1313） •\t监控项目目录中的文件变化 •\t检测到变化时自动重建并实时刷新浏览器（LiveReload）\n发布站点 准备发布 将草稿状态设置为 false或者直接删掉，默认false 将元数据调整如下，更符合自己的主题 1 2 3 4 5 6 7 8 --- title: \u0026#34;hugo使用\u0026#34; date: 2025-08-06 lastmod: 2025-08-07T10:30:00+08:00 tags: [\u0026#34;hugo\u0026#34;] categories: [\u0026#34;博客\u0026#34;] description: \u0026#34;如何使用hugo\u0026#34; --- 生成静态文件,运行构建命令： 1 hugo 这会在项目根目录下的 public 目录中生成完整的静态网站，包括： •\tHTML 文件 •\tCSS 和 JavaScript 文件 •\t图像等静态资源\n重要注意事项 •\tHugo 不会自动清空 public 目录 •\t构建时会覆盖现有文件，但不会删除旧文件 •\t根据需要手动清理该目录以避免文件残留 •\t默认情况下不包含草稿、未来或过期内容 调试工具 •\t使用 hugo server \u0026ndash;debug 获取详细日志 •\t使用 hugo config 查看完整站点配置 •\t使用 hugo list drafts 查看所有草稿文件 4.在Github Pages上部署网站 进入 public 目录（Hugo 生成的页面）\n1 2 3 4 5 6 7 8 9 git config --global https.proxy http://127.0.0.1:15715 git config --global http.proxy http://127.0.0.1:15715 cd public git init git remote add origin https://github.com/wchuang099/wchuang099.github.io.git git add . git commit -m \u0026#34;deploy\u0026#34; git branch -M main git push -f origin main 过几分钟访问即可：wchuang099.github.io\n更新流程 每次你写完文章或改完配置，只需要将以下保存bat执行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @echo off chcp 65001 REM 切换到博客源码目录 cd /d D:\\PyProject\\hugo-blog-source REM 删除旧 public rmdir /s /q public REM 生成静态文件 hugo REM 进入 public cd public REM 确保 Git 仓库存在 if not exist \u0026#34;.git\u0026#34; ( git init git checkout -b main git remote add origin https://github.com/wchuang099/wchuang099.github.io.git ) else ( git remote set-url origin https://github.com/wchuang099/wchuang099.github.io.git ) REM 提交并推送 git add . git commit -m \u0026#34;自动部署：%date% %time%\u0026#34; git push -f origin main echo ✅ 博客已成功部署！ pause 5备份网站 为了备份你的博客原始文件（包括 Markdown 笔记、配置文件、主题等），建议再建一个 源码仓库。\n✅ 推荐的结构：两个 Git 仓库\n用途 内容 GitHub 仓库 部署用 public/ 静态页面 yourusername.github.io 源码备份 所有博客源文件 hugo-blog-source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 添加 .gitignore 文件，避免上传 public/ 内容 在博客根目录下创建 .gitignore 文件，内容如下： public/ resources/ *.DS_Store *.log .hugo_build.lock desktop.ini .idea 第一次提交 cd hugo-blog # 你博客项目的根目录 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/wchuang099/hugo-blog-source.git git push -u origin main 自动发布备份脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @echo off chcp 65001 REM === Hugo 博客源码备份脚本 === REM === 将源码（含文章、主题等）备份到 GitHub === REM 提交并推送源码到 hugo-blog 仓库 git add . git commit -m \u0026#34;备份博客源码：%date% %time%\u0026#34; git remote remove origin git remote add origin https://github.com/wchuang099/hugo-blog-source.git git branch -M main git push -u origin main echo ✅ 博客源码备份完成！ pause ","date":"2025-08-06T00:00:00Z","permalink":"https://example.com/p/hugo%E4%BD%BF%E7%94%A8/","title":"hugo使用"},{"content":"数据分析：是把隐藏在一些看似杂乱无章的数据背后的信息提炼出来，总结出所研究对象的内在规律 数据分析三剑客：Numpy,Pandas,Matplotlib\nNumpy是Python语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。 NumPy 核心功能：\nNumPy 的核心是 ndarray（多维数组对象），它相比 Python 的 list 有几个优势： 存储更紧凑（同类型数据，连续内存） 运算速度快（底层 C 实现） 支持广播机制（不同形状数组自动匹配运算） 提供大量数学函数和线性代数工具 安装导入 1 2 3 pip install numpy import numpy as np print(np.__version__) 创建数组 一维数组（1D Array） 就像一个数字列表，只有一个维度。 结构类似 Python 里的列表 [1, 2, 3, 4]。 表示一条“线”上的数据。 1 2 3 4 5 arr_1d = np.array([10, 20, 30, 40]) print(arr_1d) # 输出: [10 20 30 40] print(arr_1d.shape) # 输出: (4,) 表示长度是4的一维数组 二维数组（2D Array） 类似于一个表格（矩阵），有“行”和“列”两个维度。\n结构类似 Python 里的嵌套列表 [[1, 2], [3, 4]]。\n表示“矩阵”或“二维平面”上的数据。\n1 2 3 4 5 6 7 arr_2d = np.array([[1, 2, 3], [4, 5, 6]]) print(arr_2d) # 输出:# [[1 2 3] # [4 5 6]] print(arr_2d.shape) # 输出: (2, 3) 表示2行3列的二维数组 三维数组（3D Array） 形状是 (层数, 行数, 列数)，就是多张二维矩阵叠加在一起。 类似于一个“数据立方体”。 常用于表示彩色图片（宽×高×RGB三通道）、视频帧序列，或者多组二维数据集合。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import numpy as np arr_3d = np.array([ [[1, 2, 3], # 第1层，第一行 [4, 5, 6]], # 第1层，第二行 [[7, 8, 9], # 第2层，第一行 [10, 11, 12]] # 第2层，第二行 ]) print(arr_3d) # 输出： # [[[ 1 2 3] # [ 4 5 6]] # # [[ 7 8 9] # [10 11 12]]] print(arr_3d.shape) # 输出：(2, 2, 3) # 表示2层，每层2行3列 维度 用途举例 视觉形象 1维 数组、向量 线 2维 矩阵、表格 面 3维 立体数据（视频、彩色图） 体（立方体） 更多维度就是在三维基础上继续“叠加”更多维度，但在实际应用中，超过 5~10 维的数组就非常少见了，太高维的数组很难直观理解和处理。\n注意: numpy默认ndarray的所有元素的类型是相同的 如果传进来的列表中包含不同的类型，则统一为同一类型，优先级:str\u0026gt;fioat\u0026gt;int\narr_2d = np.array([[1,2.1,3],[4,5,\u0026ldquo;six\u0026rdquo;]]) print(arr_ad) #([[\u0026lsquo;1\u0026rsquo;, \u0026lsquo;2.1\u0026rsquo;, \u0026lsquo;3\u0026rsquo;], #[\u0026lsquo;4\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;six\u0026rsquo;]], dtype=\u0026rsquo;\u0026lt;U32\u0026rsquo;)\n数组属性 1 2 3 4 arr.shape # 形状 arr.ndim # 维度 arr.size # 元素总数 arr.dtype # 数据类型 数组运算 1 2 3 4 5 6 7 8 9 10 a + b # 加 a - b # 减 a * b # 元素相乘 a / b # 元素相除 np.dot(a, b) # 矩阵乘法 np.sum(a) # 求和 np.mean(a) # 均值 np.max(a) # 最大值 np.min(a) # 最小值 np.sqrt(a) # 平方根 索引与切片 1 2 3 4 5 a[0, 2] # 第1行第3列 a[:, 0] # 第一列 a[1, :] # 第二行 a[0:2, 1:3] # 子数组切片 a[a \u0026gt; 5] # 布尔索引 形状变换 1 2 3 a.reshape(2, 3) # 改形状 a.flatten() # 拉平成一维 a.T # 转置 拼接与分割 1 2 3 np.concatenate([a, b], axis=0) # 行拼接 np.concatenate([a, b], axis=1) # 列拼接 np.split(a, 2, axis=0) # 按行分割 随机数 1 2 3 4 np.random.rand(2, 3) # 0-1均匀分布 np.random.randn(2, 3) # 标准正态分布 np.random.randint(0, 10, (2, 3)) # 整数 np.random.seed(42) # 固定随机数种子 ","date":"2025-08-06T00:00:00Z","permalink":"https://example.com/p/numpy/","title":"Numpy"},{"content":"目录 简介 安装步骤 验证安装 总结 简介 本文将介绍如何在 Linux 系统上安装 Docker，适合初学者快速上手。\n安装步骤 步骤1 步骤2\n总结 完成安装 123456\n","date":"2025-08-06T00:00:00Z","permalink":"https://example.com/p/%E5%AE%89%E8%A3%85-docker-%E6%95%99%E7%A8%8B/","title":"安装 Docker 教程"},{"content":"s\n","date":"2025-08-06T00:00:00Z","permalink":"https://example.com/p/%E5%AE%89%E8%A3%85-mysql-%E6%95%99%E7%A8%8B/","title":"安装 mysql 教程"},{"content":"","date":"2025-08-06T00:00:00Z","permalink":"https://example.com/p/%E5%AE%89%E8%A3%85-nginx-%E6%95%99%E7%A8%8B/","title":"安装 Nginx 教程"},{"content":"逆出实现思路，至于用什么语言来编写代码，就不重要了，但是建议学C，够底层\n正向注重逻辑算法\n逆向注重原理和思路\n正向和逆向相辅相成，一个强带动另一个\n","date":"0001-01-01T00:00:00Z","permalink":"https://example.com/p/","title":""}]